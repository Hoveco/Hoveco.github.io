<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JavaSE-学习笔记-GUI程序开发（八） | Hoveco Blog</title><meta name="author" content="Hoveco"><meta name="copyright" content="Hoveco"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="底部打赏杯奶茶奖励作者吧~">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE-学习笔记-GUI程序开发（八）">
<meta property="og:url" content="https://www.hoveco.top/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89GUI%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/index.html">
<meta property="og:site_name" content="Hoveco Blog">
<meta property="og:description" content="底部打赏杯奶茶奖励作者吧~">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://5b0988e595225.cdn.sohucs.com/images/20170823/972ca31aced141008aea907b4efacee9.jpeg">
<meta property="article:published_time" content="2023-10-12T00:30:00.000Z">
<meta property="article:modified_time" content="2023-10-12T14:49:22.837Z">
<meta property="article:author" content="Hoveco">
<meta property="article:tag" content="JavaSE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://5b0988e595225.cdn.sohucs.com/images/20170823/972ca31aced141008aea907b4efacee9.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JavaSE-学习笔记-GUI程序开发（八）",
  "url": "https://www.hoveco.top/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89GUI%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/",
  "image": "https://5b0988e595225.cdn.sohucs.com/images/20170823/972ca31aced141008aea907b4efacee9.jpeg",
  "datePublished": "2023-10-12T00:30:00.000Z",
  "dateModified": "2023-10-12T14:49:22.837Z",
  "author": [
    {
      "@type": "Person",
      "name": "nothing",
      "url": "https://www.hoveco.top/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://www.hoveco.top/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89GUI%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaSE-学习笔记-GUI程序开发（八）',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="baidu-site-verification" content="codeva-2q835l30p2" /><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hoveco Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page" href="/video/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-film"></i><span> 豆瓣记录</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://5b0988e595225.cdn.sohucs.com/images/20170823/972ca31aced141008aea907b4efacee9.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hoveco Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">JavaSE-学习笔记-GUI程序开发（八）</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page" href="/video/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-film"></i><span> 豆瓣记录</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">JavaSE-学习笔记-GUI程序开发（八）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-12T00:30:00.000Z" title="发表于 2023-10-12 08:30:00">2023-10-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-12T14:49:22.837Z" title="更新于 2023-10-12 22:49:22">2023-10-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">15.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>52分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><img src="https://s2.loli.net/2022/10/26/Mu6qwoA9fc7THbQ.png" alt="image-20221026154454258"></p>
<h1 id="GUI程序开发"><a href="#GUI程序开发" class="headerlink" title="GUI程序开发"></a>GUI程序开发</h1><p>注意：开始学习之前请确保你完成了《Java SE》篇视频教程。</p>
<p>前面我们已经完成了JavaSE部分的全部内容学习，只不过我们在初学阶段一直都是开发的控制台程序，也就是最原始的命令窗口形式的程序，而Java也可以开发桌面图形化程序，所以我们接着来学习一下Java的图形化界面的开发。</p>
<h2 id="AWT组件介绍"><a href="#AWT组件介绍" class="headerlink" title="AWT组件介绍"></a>AWT组件介绍</h2><p>在Java正式推出的时候，它还包含一个用于基本GUI程序设计的类库，名字叫 Abstract Window Toolkit，简称AWT，抽象窗口工具包，我们可以直接使用Java为我们提供的工具包来进行桌面应用程序的开发。只不过这套工具包依附于操作系统提供的UI，具体样式会根据不同操作系统提供的界面元素进行展示。</p>
<p>实际上我们现代操作系统都是图形化界面，应用程序都是以一个窗口的形式展示出来的，我们可以直接使用鼠标点击窗口内的元素来使用应用程序，相比传统的命令行形式，可方便太多了，比如在Windows和MacOS这两种操作系统下：</p>
<p><img src="https://s2.loli.net/2022/10/26/fMQDFCmyqIvJeTl.png" alt="image-20221026164200924"></p>
<p>可以看到，不同的操作系统的窗口样式稍微有一些不一样，但是大致的使用方式是差不多的，我们接着来看一下如何使用Java编写简单的桌面图形化程序。</p>
<h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><p>既然我们要编写一个桌面程序，那么肯定是需要窗口来展示我们程序的内容的，所以说，我们可以使用AWT为我们提供的组件来创建窗口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Frame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Frame</span>();   <span class="comment">//Frame是窗体，我们只需要创建这样一个对象就可以了，这样就会直接创建一个新的窗口</span></span><br><span class="line">    frame.setSize(<span class="number">500</span>, <span class="number">300</span>);   <span class="comment">//可以使用setSize方法设定窗体大小</span></span><br><span class="line">    frame.setVisible(<span class="literal">true</span>);    <span class="comment">//默认情况下窗体是不可见的，我们如果要展示出来，还需要设置窗体可见性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，桌面的左上角已经展示出我们的窗口了：</p>
<p><img src="https://s2.loli.net/2022/10/26/ZSQs1NhWlJeyMmi.png" alt="image-20221026165600076"></p>
<p>在不同的操作系统下，窗口的样式会不同。</p>
<p>我们可以通过Frame的各种方法来设置窗口的各项属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Frame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Frame</span>();</span><br><span class="line">    frame.setTitle(<span class="string">&quot;我是标题&quot;</span>);   <span class="comment">//设置窗口标题</span></span><br><span class="line">    frame.setSize(<span class="number">500</span>, <span class="number">300</span>);    <span class="comment">//设置窗口大小</span></span><br><span class="line">    frame.setBackground(Color.BLACK);   <span class="comment">//设置窗口背景颜色</span></span><br><span class="line">  	frame.setResizable(<span class="literal">false</span>);    <span class="comment">//设置窗口大小是否固定</span></span><br><span class="line">  	frame.setAlwaysOnTop(<span class="literal">true</span>);    <span class="comment">//设置窗口是否始终展示在最前面</span></span><br><span class="line">    frame.setVisible(<span class="literal">true</span>);    <span class="comment">//注意，只有将可见性变为true时才会展示出这个窗口，否则窗口是隐藏的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上当我们创建一个窗口之后，会在其他线程中进行处理，包括窗口的绘制、窗口事件的监听等，所以说我们的主线程不会卡住。</p>
<p>实际上我们的程序打开都是默认居中显示的，所以说我们可以调整一下窗口的位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame.setLocation(<span class="number">100</span>, <span class="number">200</span>);   <span class="comment">//setLocation可以调整窗口位置</span></span><br></pre></td></tr></table></figure>

<p>注意，这里的窗口位置以及窗口大小都是以像素为单位。整个屏幕有多少个像素，是根据各位小伙伴电脑的显示器屏幕分辨率来决定的，比如我们的电脑显示器屏幕分辨率为 1920 x 1080，那么我们显示器就可以显示长为1920个像素，宽1080个像素的矩形，只要是在这个范围内的窗口，都可以显示到屏幕上：</p>
<p><img src="https://s2.loli.net/2022/10/26/CknumyFjpz659Ya.png" alt="image-20221026170449235"></p>
<p>那么问题就来了，如果现在我们希望将这个窗口居中，就需要手动调整位置，但我们是要去适配各种分辨率的显示器才可以，不然到其他分辨率下，就无法居中了，我们可以动态获取分辨率来进行位置计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Frame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Frame</span>(<span class="string">&quot;我是标题&quot;</span>);</span><br><span class="line">    frame.setSize(<span class="number">500</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Dimension</span> <span class="variable">screenSize</span> <span class="operator">=</span> Toolkit.getDefaultToolkit().getScreenSize();  <span class="comment">//获取到屏幕尺寸</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) ((screenSize.getWidth() - frame.getWidth()) / <span class="number">2</span>);   <span class="comment">//居中位置就是：屏幕尺寸/2 - 窗口尺寸/2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) ((screenSize.getHeight() - frame.getHeight()) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    frame.setLocation(x, y);   <span class="comment">//位置设置好了之后再展示出来</span></span><br><span class="line">    frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们的窗口打开之后默认就是居中放置的了，是不是感觉用Java开发图形界面好像也不是那么难？</p>
<p>得益于Java已经为我们封装好了各种方法，所以说要实现什么功能直接调用对应的方法即可，比如我们想要个性化光标，我们可以使用<code>setCursor</code>方法来实现，JDK已经为我们提供了一些预设的光标样式：</p>
<p><img src="https://s2.loli.net/2022/10/27/drC1nx2NSK9Ewaf.png" alt="image-20221027151713661"></p>
<p>设定光标样式后，当我们的鼠标移动到这个窗口内部时，就会变成我们设定好的光标样式了。</p>
<p>有关其他方法，这里暂时不进行介绍。</p>
<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>我们可以为窗口添加一系列的监听器，监听器会监听窗口中发生的一些事件，比如我们点击关闭窗口、移动鼠标、鼠标点击等，当发生对应的事件时，就会通知到对应的监听器进行处理，从而我们能够在发生对应事件时进行对应处理。</p>
<p><img src="https://s2.loli.net/2022/10/27/DAz1hnUekV6RNqd.png" alt="image-20221027161611050"></p>
<p>比如我们现在希望点击关闭按钮关闭当前的窗口，但是我们发现默认情况下实际上是关不掉的，因为我们并没有对关闭事件进行处理，默认情况下对于这种点击时没有设定任何动作的，万一我们点了之后并不是要关闭窗口呢。要实现关闭窗口，我们可以使用<code>addXXXListener</code>来添加对应的事件监听器，比如窗口相关的操作那么就是WindowListener：</p>
<p><img src="https://s2.loli.net/2022/10/27/IiwomHF7YWe8Vuh.png" alt="image-20221027155830335"></p>
<p>这里我们可以给一个接口实现，或是使用对应的适配器（适配器模式是设计模式中的一种写法，因为接口中要实现的方法太多，但是实际上我们并不需要实现那么多，只需要实现对应的即可，所以说就可以使用适配器）我们只需要重写对应的方法，当发生对应事件时就会自动调用我们已经实现好的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">frame.addWindowListener(<span class="keyword">new</span> <span class="title class_">WindowAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosing</span><span class="params">(WindowEvent e)</span> &#123;   <span class="comment">//windowClosing方法对应的就是窗口关闭事件</span></span><br><span class="line">        frame.dispose();    <span class="comment">//当我们点击X号关闭窗口时，就会自动执行此方法了</span></span><br><span class="line">        <span class="comment">//使用dispose方法来关闭当前窗口</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosed</span><span class="params">(WindowEvent e)</span> &#123;   <span class="comment">//对应窗口已关闭事件</span></span><br><span class="line">        System.out.println(<span class="string">&quot;窗口已关闭！&quot;</span>);   <span class="comment">//当窗口成功关闭后，会执行这里重写的内容</span></span><br><span class="line">      	System.exit(<span class="number">0</span>);    <span class="comment">//窗口关闭后退出当前Java程序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们可以来看看效果，现在我们点击X号关闭窗口就可以成功执行了，并且窗口关闭后我们的Java程序就结束了。当然，监听器可以添加多个，并不是只能有一个。</p>
<p>这里总结一下窗口常用的事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WindowListener</span> <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowOpened</span><span class="params">(WindowEvent e)</span>;   <span class="comment">//当窗口的可见性首次变成true时会被调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosing</span><span class="params">(WindowEvent e)</span>;   <span class="comment">//当以后企图关闭窗口（也就是点击X号）时被调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosed</span><span class="params">(WindowEvent e)</span>;   <span class="comment">//窗口被我们成功关闭之后被调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowIconified</span><span class="params">(WindowEvent e)</span>;    <span class="comment">//窗口最小化时被调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowDeiconified</span><span class="params">(WindowEvent e)</span>;   <span class="comment">//窗口从最小化状态变成普通状态时调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowActivated</span><span class="params">(WindowEvent e)</span>;    <span class="comment">//当窗口变成活跃状态时被调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowDeactivated</span><span class="params">(WindowEvent e)</span>;   <span class="comment">//当窗口变成不活跃时被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了监听窗口相关的动作之外，我们也可以监听鼠标、键盘等操作的事件，比如键盘事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frame.addKeyListener(<span class="keyword">new</span> <span class="title class_">KeyAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyTyped</span><span class="params">(KeyEvent e)</span> &#123;    <span class="comment">//监听键盘输入事件，当我们在窗口中敲击键盘输入时会触发</span></span><br><span class="line">        System.out.print(e.getKeyChar());   <span class="comment">//可以通过KeyEvent对象来获取当前事件输入的对应字符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>键盘事件甚至可以细致到键盘按键的几种状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">KeyListener</span> <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyTyped</span><span class="params">(KeyEvent e)</span>;   <span class="comment">//当一个按键按下之后触发（感觉跟下面这个没啥区别）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyPressed</span><span class="params">(KeyEvent e)</span>;   <span class="comment">//当一个按键按下后触发（按下之后如果不松开会连续触发此事件）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyReleased</span><span class="params">(KeyEvent e)</span>;   <span class="comment">//当一个按键按下然后松开后触发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以监听鼠标相关的事件，比如当鼠标点击我们界面上某一个位置时，我们就可以获取一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frame.addMouseListener(<span class="keyword">new</span> <span class="title class_">MouseAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseClicked</span><span class="params">(MouseEvent e)</span> &#123;   <span class="comment">//mouseClicked是监听鼠标点击事件（必须要用真的鼠标点击，不知道为啥，笔记本的触摸板不行，可能是MacOS的BUG吧）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;鼠标点击：&quot;</span>+e.getX()+<span class="string">&quot;,&quot;</span>+e.getY());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样，当我们点击窗口中的某个位置时，就可以获取对应的坐标并打印出来：</p>
<p><img src="https://s2.loli.net/2022/10/27/VQm7FjSNidLhI1r.png" alt="image-20221027164500070"></p>
<p>注意这里的坐标并不是按照我们在数学中学习的平面直角坐标系来的，它的X轴是从左往右，但是Y轴是从上往下，原点也不是整个屏幕开始，而是我们的窗口左上角。所以说当我们点击右下角时，就会得到一个接近于窗口大小的坐标了。</p>
<p>我们也可以获取鼠标是使用哪个键点击的，我们的鼠标一般情况下有三个按键：</p>
<ul>
<li>BUTTON1   -   鼠标左键，也是我们用的最多的键</li>
<li>BUTTON2   -   鼠标中键，一般是鼠标滚轮，也是是可以点击的（不会有人以为鼠标滚轮只能滚不能按吧）</li>
<li>BUTTON3   -   鼠标右键，右键一般就是辅助点按，展开各种选项等</li>
</ul>
<p>如果是游戏鼠标，也许能监听到一些其他的按键，这里我们就不测试了，我们来尝试监听一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frame.addMouseListener(<span class="keyword">new</span> <span class="title class_">MouseAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseClicked</span><span class="params">(MouseEvent e)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鼠标点击：&quot;</span>+e.getButton());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>鼠标滚动事件也可以进行监听：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frame.addMouseWheelListener(<span class="keyword">new</span> <span class="title class_">MouseAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseWheelMoved</span><span class="params">(MouseWheelEvent e)</span> &#123;</span><br><span class="line">        System.out.println(e.getScrollAmount());    <span class="comment">//获取滚动数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>MacOS下的鼠标滚动是平滑滚动，会触发很多次，不像Windows下是一格一格的僵硬滚动。</p>
<p>通过使用这些监听器，我们就可以更好的控制我们的GUI程序了。</p>
<h3 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h3><p>前面我们介绍了监听器，我们接着来看看常用的一些组件，那么什么是组件呢？</p>
<p>组件实际上是AWT为我们预设好的一些可以直接使用的界面元素，比如按钮、文本框、标签等等，我们可以使用这些已经帮我们写好的组件来快速拼凑出一个好看且功能强大的程序：</p>
<p><img src="https://s2.loli.net/2022/10/27/D6hslN2pHybmVdF.png" alt="image-20221027170224462"></p>
<p>在开始学习组件之前，我们先将布局设定为<code>null</code>（因为默认情况下会采用BorderLayout作为布局）有关布局我们会在下一部分中进行介绍，这节课我们先介绍没有布局的情况下如何使用这些组件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame.setLayout(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>首先我们来介绍一下最简单的组件，标签组件相当于一个普通的文本内容，我们可以将自己的标签添加到窗口中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Label</span> <span class="variable">label</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;我是标签&quot;</span>);   <span class="comment">//添加标签只需要创建一个Label对象即可</span></span><br><span class="line">label.setLocation(<span class="number">20</span>, <span class="number">50</span>);   <span class="comment">//注意，必须设定标签的位置和大小，否则无法展示出来</span></span><br><span class="line">label.setSize(<span class="number">100</span>, <span class="number">20</span>);</span><br><span class="line">frame.add(label);    <span class="comment">//使用add方法添加组件到窗口中</span></span><br></pre></td></tr></table></figure>

<p>注意，组件的位置是以整个窗口的左上角为原点开始的（整个窗口指的是包括标题栏在内）所以说我们如果想要设置组件的位置，我们还得注意加上标题栏的高度，否则会被标题栏遮挡：</p>
<p><img src="https://s2.loli.net/2022/10/27/VjCdNbAUIi5R61Z.png" alt="image-20221027175842110"></p>
<p>我们可以自由修改文本的字体和大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接构造并传入一个Font对象即可</span></span><br><span class="line">label.setFont(<span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;SimSong&quot;</span>, Font.BOLD, <span class="number">15</span>));   <span class="comment">//Font构造方法需要字体名称、字体样式（加粗、斜体）、字体大小</span></span><br></pre></td></tr></table></figure>

<p>注意必须是操作系统已经安装的字体才支持展示，如果各位小伙伴不知道操作系统有哪些字体，可以使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GraphicsEnvironment.getLocalGraphicsEnvironment().getAllFonts()</span><br></pre></td></tr></table></figure>

<p>来获取所有的系统字体：</p>
<p><img src="https://s2.loli.net/2022/10/27/Fsj8PqHryUYdgeC.png" alt="image-20221027181909908"></p>
<p>这里我们直接使用前面的<code>family</code>即可，比如我们要使用宋体，那么就输入其名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label.setFont(<span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;Songti SC&quot;</span>, Font.BOLD, <span class="number">15</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/27/zy4L2T67rGQe3HI.png" alt="image-20221027182010485"></p>
<p>可以看到字体已经成功修改了，当然，为了方便，如果我们的窗口中有很多的标签都想统一使用某一个字体，我们可以直接对窗口设定字体，那么只要是添加到窗口中的组件都会默认使用这个字体，除非单独指定组件字体。</p>
<p>要修改字体的颜色也很简单，我们可以使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">label.setBackground(Color.BLACK);    <span class="comment">//setBackground依然是背景颜色，注意背景填充就是我们之前设定的大小</span></span><br><span class="line">label.setForeground(Color.WHITE);    <span class="comment">//setForeground是设定字体颜色</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/27/R5cDrYxoKtpCJk6.png" alt="image-20221027183745934"></p>
<p>我们接着来认识一下下一个组件，这个组件的名字叫做按钮，实际上按钮也是我们经常会使用的一个组件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;点击充值&quot;</span>);   <span class="comment">//Button是按钮组件</span></span><br><span class="line">button.setBounds(<span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">frame.add(button);</span><br></pre></td></tr></table></figure>

<p>这样就可以添加一个按钮到我们的窗口中了：</p>
<p><img src="https://s2.loli.net/2022/10/27/gArLdNTI1ClWh5K.png" alt="image-20221027182903783"></p>
<p>只不过，既然是按钮，那么肯定要添加一些点击动作才可以，比如点击按钮之后打印充值成功：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.addActionListener(e -&gt; System.out.println(<span class="string">&quot;充值成功&quot;</span>));  <span class="comment">//addActionListener就是按钮点击监听器</span></span><br></pre></td></tr></table></figure>

<p>是不是感觉还是很简单？当然，如果要修改按钮的字体或是颜色，依然使用之前的方式即可。</p>
<p>只不过光有按钮似乎太单调了一点，我们接着来认识下一个组件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TextField</span> <span class="variable">field</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();   <span class="comment">//TextField是文本框</span></span><br><span class="line">field.setBounds(<span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">25</span>);</span><br><span class="line">frame.add(field);</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/27/ZhpojvR6u5DTmVP.png" alt="image-20221027184138604"></p>
<p> 我们经常要在一些软件上登录，那么就要输入我们的用户名和密码，所以说文本框的作用还是非常明显的，我们也可以通过AWT组件来实现这些功能，我们可以来试试看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TextField</span> <span class="variable">field</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();</span><br><span class="line">field.setBounds(<span class="number">20</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">25</span>);</span><br><span class="line">frame.add(field);</span><br><span class="line"></span><br><span class="line"><span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;点击登录&quot;</span>);</span><br><span class="line">button.setBounds(<span class="number">20</span>, <span class="number">80</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">//点击按钮直接获取文本框中的文本内容，只需要调用getText方法即可</span></span><br><span class="line">button.addActionListener(e -&gt; System.out.println(<span class="string">&quot;输入的用户名是：&quot;</span>+field.getText()));</span><br><span class="line">frame.add(button);</span><br></pre></td></tr></table></figure>

<p>我们来试试看吧：</p>
<p><img src="https://s2.loli.net/2022/10/27/7re3aBis2jW9wvP.png" alt="image-20221027184618359"></p>
<p><img src="https://s2.loli.net/2022/10/27/Erb6npLZqsCPGzQ.png" alt="image-20221027184627653"></p>
<p>是不是感觉有内味了？当然，可能会有小伙伴觉得如果我们输入密码的话，不应该将展示的文字隐藏起来吗？我们可以这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">field.setEchoChar(<span class="string">&#x27;*&#x27;</span>);   <span class="comment">//setEchoChar设定展示字符，无论我们输入的是什么，最终展示出来的都是我们指定的字符</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/27/Er4wqYUNfAy2HBS.png" alt="image-20221027184814288"></p>
<p>当然，我们在获取输入的文本时还是输入的文本本身，不会变成展示的文本，只是一个视觉效果而已。这样，我们就可以将密码框做出来了。各位小伙伴可以尝试做一个登录界面。</p>
<p>但是肯定有小伙伴疑问，不是还有一个记住密码的勾选框吗？安排：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Checkbox</span> <span class="variable">checkbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Checkbox</span>(<span class="string">&quot;记住密码&quot;</span>);</span><br><span class="line">checkbox.setBounds(<span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">30</span>);   <span class="comment">//这个大小并不是勾选框的大小，具体的勾选框大小要根据操作系统决定，跟Label一样，是展示的空间大小</span></span><br><span class="line">frame.add(checkbox);</span><br></pre></td></tr></table></figure>

<p>最终展示出来的效果就是：</p>
<p><img src="https://s2.loli.net/2022/10/27/pErwuKAGOa3dQ5l.png" alt="image-20221027185748324"></p>
<p>效果还是挺不错的，我们也可以设定一个多选框：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CheckboxGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckboxGroup</span>();   <span class="comment">//创建勾选框组</span></span><br><span class="line"></span><br><span class="line"><span class="type">Checkbox</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Checkbox</span>(<span class="string">&quot;选我&quot;</span>);</span><br><span class="line">c1.setBounds(<span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br><span class="line">frame.add(c1);</span><br><span class="line"></span><br><span class="line"><span class="type">Checkbox</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Checkbox</span>(<span class="string">&quot;你干嘛&quot;</span>);</span><br><span class="line">c2.setBounds(<span class="number">20</span>, <span class="number">80</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br><span class="line">frame.add(c2);</span><br><span class="line"></span><br><span class="line">c1.setCheckboxGroup(group);    <span class="comment">//多个勾选框都可以添加到勾选框组中</span></span><br><span class="line">c2.setCheckboxGroup(group);</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/27/y8713x9VBlCaQm6.png" alt="image-20221027190207441"></p>
<p>我们可以使用<code>getSelectedCheckbox</code>方法来获取已经被选中的勾选框：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(group.getSelectedCheckbox());</span><br></pre></td></tr></table></figure>

<p>常用组件就暂时介绍到这里。</p>
<h3 id="布局和面板"><a href="#布局和面板" class="headerlink" title="布局和面板"></a>布局和面板</h3><p>前面我们介绍了各种各样的组件，现在我们就可以利用这些组件来拼凑一个好看的程序了。</p>
<p>只不过，如果不使用布局，那么我们只能手动设置组件的位置以及大小，这就使得我们的程序在尺寸的设计上很有限，因为一旦窗口的大小发生变化，我们的组件依然是会放置在原本的位置上，要保证我们的设计不被破坏就只能固定窗口大小，但是很多应用都是支持放大和缩小的，并且在不同的大小下组件会自己调整位置：</p>
<p><img src="https://s2.loli.net/2022/10/28/ro7Cxi5Oe8wuALv.png" alt="image-20221028135701447"></p>
<p>可以看到窗口的大小可以自由移动并且组件的位置会根据窗口大小自己进行调整。</p>
<p>这正是因为使用了布局实现的，布局可以根据自己的一些性质，对容器（这里可以是我们的窗口）内部的组件自动进行调整，包括组件的位置、组件的大小等，Java为我们提供了各种各样的布局管理器，我们来看看吧。</p>
<p>默认情况下，我们的窗口采用的是边界布局（BorderLayout）这种布局方式支持将组件放置到五个区域：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frame.setLayout(<span class="keyword">new</span> <span class="title class_">BorderLayout</span>());   <span class="comment">//使用边界布局</span></span><br><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;1号按钮&quot;</span>), BorderLayout.WEST);  <span class="comment">//在添加组件时，可以在后面加入约束</span></span><br><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;2号按钮&quot;</span>), BorderLayout.EAST);</span><br><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;3号按钮&quot;</span>), BorderLayout.SOUTH);</span><br><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;4号按钮&quot;</span>), BorderLayout.NORTH);</span><br><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;5号按钮&quot;</span>), BorderLayout.CENTER);</span><br></pre></td></tr></table></figure>

<p>注意，约束只有在当前容器为对应布局时才可以使用。这里我们采用的是边界布局，边界布局可以将组件设定到五个区域：</p>
<p><img src="https://s2.loli.net/2022/10/28/ZigtAkDbrMVqjWz.png" alt="image-20221028140816161"></p>
<p>可以看到，分别在东、南、西、北、中心位置都可以添加组件，组件的大小会被自动调整，并且随着我们的窗口大小变化，组件的大小也会跟着自动调整，是不是感觉挺方便的？边界布局的性质：</p>
<ul>
<li> BorderLayout布局的容器某个位置的某个组件会直接充满整个区域。</li>
<li>如果在某个位置重复添加组件，只有最后一个添加的组件可见。</li>
<li>缺少某个位置的组件时，其他位置的组件会延伸到该位置。</li>
</ul>
<p>我们还可以调整组件之间的间距：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BorderLayout</span> <span class="variable">borderLayout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BorderLayout</span>();</span><br><span class="line">borderLayout.setHgap(<span class="number">50</span>);   <span class="comment">//Hgap是横向间距</span></span><br><span class="line">borderLayout.setVgap(<span class="number">50</span>);   <span class="comment">//Vgap是纵向间距</span></span><br></pre></td></tr></table></figure>

<p>调整之后，边距就非常明显了：</p>
<p><img src="https://s2.loli.net/2022/10/28/XQqnd6GHa7hVOtR.png" alt="image-20221028143042506"></p>
<p>我们接着来认识一下下一个布局，FlowLayout 流式布局，流式布局实际上就是按顺序排列的一种布局：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">frame.setLayout(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>());   <span class="comment">//采用流式布局</span></span><br><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;1号按钮&quot;</span>));</span><br><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;2号按钮&quot;</span>));</span><br><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;3号按钮&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>采用流式布局后，按钮会根据内容大小，自动调整为对应的大小，并且他们之间是有间距的：</p>
<p><img src="https://s2.loli.net/2022/10/28/471ED3GaefjzHy8.png" alt="image-20221028142144585"></p>
<p>当我们对窗口大小进行调整时，流式布局也会进行自动调整：</p>
<p><img src="https://s2.loli.net/2022/10/28/hJrBtcVj7MDGqfw.png" alt="image-20221028142326191"></p>
<p>我们也可以在设定流式布局时指定对齐模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame.setLayout(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>(FlowLayout.RIGHT));   <span class="comment">//指定为右对齐</span></span><br></pre></td></tr></table></figure>

<p>对齐方式会直接决定组件的排列方式：</p>
<p><img src="https://s2.loli.net/2022/10/28/QlU8IPoVA2j4E6t.png" alt="image-20221028142506961"></p>
<p>我们同样可以使用Hgap和Vgap来调整组件之间的间距：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FlowLayout</span> <span class="variable">flowLayout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlowLayout</span>();</span><br><span class="line">flowLayout.setHgap(<span class="number">50</span>);</span><br><span class="line">flowLayout.setVgap(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/28/vVN4O8XynAdW5Jb.png" alt="image-20221028143230216"></p>
<p>我们接着来看卡片布局，CardLayout对象将卡片作为一个容器中的每个组件，这个卡片布局怎么说呢，有点像iOS14新出的叠放小组件（安卓应该也有）就像很多张卡片叠在一起，每次只能看到最顶上的这张卡片，但是我们可以将下层的卡片切到顶上来：</p>
<p><img src="https://s2.loli.net/2022/10/28/CqE9FkVSMJXOLY8.png" alt="image-20221028143949323"></p>
<p>卡片布局就是这样，我们可以添加多个组件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CardLayout</span> <span class="variable">layout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CardLayout</span>();</span><br><span class="line">frame.setLayout(layout);</span><br><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;我是1号&quot;</span>));</span><br><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;我是2号&quot;</span>));</span><br><span class="line"></span><br><span class="line">frame.setVisible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    layout.next(frame);    <span class="comment">//我们需要使用CardLayout对象来进行切换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们每三秒钟切换一次卡片，可以看到我们添加的标签每三秒就会变化一次，实际上我们可以利用卡片布局来做一个类似跑马灯的效果，是不是感觉很神奇？</p>
<p>我们接着来看网格布局，GridLayout以矩形网格的形式对组件进行管理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frame.setLayout(<span class="keyword">new</span> <span class="title class_">GridLayout</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(i + <span class="string">&quot;号按钮&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>这种布局就很好理解了，默认情况下会生成一行按格子划分的相等区域：</p>
<p><img src="https://s2.loli.net/2022/10/28/joR1s467rFzJqOE.png" alt="image-20221028145118733"></p>
<p>我们也可以手动指定行数和列数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GridLayout</span> <span class="variable">gridLayout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GridLayout</span>();</span><br><span class="line">gridLayout.setRows(<span class="number">2</span>);</span><br><span class="line">frame.setLayout(gridLayout);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(i + <span class="string">&quot;号按钮&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/28/DtnRaCJh7qzc4w3.png" alt="image-20221028145330522"></p>
<p>所有的组件都会整齐排列在网格中。</p>
<p>最后一种布局是GridBagLayout，是最灵活的布局管理器，它同样是按照网格进行划分，但是一个组件可以同时占据多个网格。这种情况其实也是经常会出现的，比如计算器上的按钮虽然看起来也是按照网格排列的，但是有些按钮同时占据了横向或是纵向的两个网格，这种情况使用GridBagLayout布局就可以很好的处理：</p>
<p><img src="https://s2.loli.net/2022/10/28/JNmjEVWIG2nkxbf.png" alt="image-20221028145752545"></p>
<p>虽然这个布局很强大，但是用起来也是很麻烦的，所以说这里就不做讲解了，感兴趣的小伙伴可以自行了解。</p>
<p>虽然认识了这么多的布局，但是我们发现，很多应用程序并不只是由单一的布局组成的，而是多种布局相互嵌套的结果，比如我们的IDEA界面，就不仅仅是一个布局完成的（这里只是举个例子）而是多种布局在嵌套使用：</p>
<p><img src="https://s2.loli.net/2022/10/28/9ZfvOxThctdPS6N.png" alt="image-20221028151242522"></p>
<p>但是只有我们的窗口才能设置布局啊，总不可能让多个窗口拼接在一起吧？实际上除了窗口可以作为容器之外，我们也可以使用其他的容器，这时，我们就需要用到面板。</p>
<p>类面板是最简单的容器类，它跟窗口一样，可以提供一个空间，同样可以随意添加组件到面板中，只不过面板本身也是一个组件，所以说面板是可以放到其他容器中的容器，就像：</p>
<p><img src="https://s2.loli.net/2022/10/28/jVGTNmd3i2ZRg5h.png" alt="image-20221028151701189"></p>
<p><img src="https://s2.loli.net/2022/10/28/6PGem8qMrV7NOZS.png" alt="image-20221028151845514"></p>
<p>面板本身也是容器，所以说也可以单独设置面板内部的布局，比如现在我们想要分两个区域，上半部分区域是流式布局，下半部分区域采用网格布局，那么我们就可以先将窗口采用网格布局，并在上下各添加一个面板：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GridLayout</span> <span class="variable">layout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GridLayout</span>();   <span class="comment">//先设置整个窗口的布局</span></span><br><span class="line">layout.setRows(<span class="number">2</span>);     <span class="comment">//设置行数为2，一会就会分成两行了</span></span><br><span class="line">frame.setLayout(layout);</span><br><span class="line"></span><br><span class="line"><span class="type">Panel</span> <span class="variable">top</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Panel</span>();     <span class="comment">//接着我们创建一下上半部分的面板和下半部分的面板</span></span><br><span class="line">top.setBackground(Color.PINK);   <span class="comment">//添加一个背景颜色方便区分</span></span><br><span class="line">frame.add(top);</span><br><span class="line"></span><br><span class="line"><span class="type">Panel</span> <span class="variable">bottom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Panel</span>();</span><br><span class="line">bottom.setBackground(Color.ORANGE);</span><br><span class="line">frame.add(bottom);</span><br></pre></td></tr></table></figure>

<p>这样，我们的两个面板就按照网格布局，被分成了上下两部分：</p>
<p><img src="https://s2.loli.net/2022/10/28/agMjZkqrSGUm9Ld.png" alt="image-20221028152352861"></p>
<p>接着我们就可以分别在上半部分的面板和下半部分的面板中进行单独配置了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Panel</span> <span class="variable">top</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Panel</span>();</span><br><span class="line">top.setBackground(Color.PINK);</span><br><span class="line">top.setLayout(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>());    <span class="comment">//面板默认会采用FlowLayout，所以说这里指不指定都一样</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)    <span class="comment">//面板就像窗口一样，可以设定布局和添加组件</span></span><br><span class="line">    top.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;流式&quot;</span>+i));</span><br><span class="line">frame.add(top);</span><br><span class="line"></span><br><span class="line"><span class="type">Panel</span> <span class="variable">bottom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Panel</span>();</span><br><span class="line">bottom.setBackground(Color.ORANGE);</span><br><span class="line">bottom.setLayout(<span class="keyword">new</span> <span class="title class_">GridLayout</span>());   <span class="comment">//下半部分我们采用网格布局</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    bottom.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;网格&quot;</span>+i));</span><br><span class="line">frame.add(bottom);</span><br></pre></td></tr></table></figure>

<p>这里我们将上半部分面板设定为流式布局，下半部分面板设定为网格布局：</p>
<p><img src="https://s2.loli.net/2022/10/28/RbiFpTDCEaN5fPl.png" alt="image-20221028152617119"></p>
<p>利用面板，我们就可以实现各种布局的自由组合，当然，面板在后面还会有更多的用处。</p>
<h3 id="滚动面板和列表"><a href="#滚动面板和列表" class="headerlink" title="滚动面板和列表"></a>滚动面板和列表</h3><p>有些时候，我们的窗口大小可能并不能完全显示内部的内容，比如出现了一张很大的图片。</p>
<p><img src="https://s2.loli.net/2022/10/28/7mKakMLhz95VbIp.png" alt="image-20221028153201386"></p>
<p>此时就会出现滚动条来让我们进行拖拽，这样就可以向下滑动查看没有完全展示出来的内容了。而我们之前开发的程序都没办法做到这样的滚动，超出部分会直接无法显示。</p>
<p>AWT也为我们提供了滚动面板组件，滚动面板也是一个容器，但是我们无法修改它的布局，它只能容纳单个组件，比如展示一个图片、或者是列表等，我们也可以将其与Panel配合使用，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScrollPane</span> <span class="variable">scrollPane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollPane</span>();   <span class="comment">//创建滚动面板</span></span><br><span class="line">frame.add(scrollPane);</span><br><span class="line"></span><br><span class="line"><span class="type">GridLayout</span> <span class="variable">layout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GridLayout</span>();    <span class="comment">//创建滚动面板内部的要展示的面板</span></span><br><span class="line">layout.setRows(<span class="number">20</span>);</span><br><span class="line"><span class="type">Panel</span> <span class="variable">panel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Panel</span>();</span><br><span class="line">panel.setLayout(layout);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    panel.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;我是按钮&quot;</span>+i));   <span class="comment">//为面板添加按钮</span></span><br><span class="line">scrollPane.add(panel);</span><br></pre></td></tr></table></figure>

<p>可以看到，无法显示的部分会自动变成滚动面板，我们滑动就可以展示了：</p>
<p><img src="https://s2.loli.net/2022/10/28/ZDa92CJVf7TbGk4.png" alt="image-20221028155050727"></p>
<p>这里需要特别提一下，我们看到这里的按钮大小采用的是自动生成的大小，但是如果我们希望按钮的大小按照我们喜欢的来怎么办呢？我们知道，使用布局之后，组件的大小实际上是自动决定的，只有未使用布局的情况下才能自由更改组件大小，那么我们怎么才能干预呢？我们可以为组件设定一个建议的大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    <span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;我是按钮&quot;</span> + i);</span><br><span class="line">    button.setPreferredSize(<span class="keyword">new</span> <span class="title class_">Dimension</span>(<span class="number">100</span>, <span class="number">50</span>));   <span class="comment">//设置首选大小</span></span><br><span class="line">    panel.add(button);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当布局管理器在自动调整内部组件大小时，如果不是必须要按照布局大小来展示或者是高度或宽度不确定，那么就会采用我们建议的大小展示，比如这里只能确定宽度，而高度是不确定的，那么就可以使用我们建议的大小来展示：</p>
<p><img src="https://s2.loli.net/2022/10/28/SQZapDy6vdLkHNx.png" alt="image-20221028155443331"></p>
<p>当然，首选大小可能不太好理解，还需要各位小伙伴多多尝试才能理解。</p>
<p>实际上滚动面板的最佳搭档就是List列表（注意这里的列表不是我们集合类里面学习的列表，而是展示出来的列表组件）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">List</span>();   <span class="comment">//注意是awt包下的List，别导错了</span></span><br><span class="line">list.add(<span class="string">&quot;小糍粑&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;锅巴洋芋&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;手抓饼&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;凉面&quot;</span>);</span><br><span class="line">list.setMultipleMode(<span class="literal">true</span>);   <span class="comment">//是否开启多选模式</span></span><br></pre></td></tr></table></figure>

<p>列表组件就像是一个选择列表一样：</p>
<p><img src="https://s2.loli.net/2022/10/28/ieDtpQqdkBzhsKF.png" alt="image-20221028160340931"></p>
<p>列表会将元素依次展示出来，我们可以选择列表中的某一项：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.addItemListener(System.out::println);</span><br></pre></td></tr></table></figure>

<p>列表可以添加监听器，当我们选择某个物品时，就会自动触发：</p>
<p><img src="https://s2.loli.net/2022/10/28/LXIvYhnFVBlQTGt.png" alt="image-20221028160611113"></p>
<p>列表就很时候拿来做文件列表。</p>
<h3 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h3><p>前面我们认识了各种各样的组件，我们接着来看菜单，实际上各位小伙伴会发现我们的程序上方一般都会有一排菜单：</p>
<p><img src="https://s2.loli.net/2022/10/28/Konar26QHWMTwqd.png" alt="image-20221028161209224"></p>
<p>在MacOS下是整合到状态栏中的：</p>
<p><img src="https://s2.loli.net/2022/10/28/G3NiRaBMkJLneVl.png" alt="image-20221028161239672"></p>
<p>这些菜单一般都会包含我们程序中的一些基本操作，实际上我们的程序中很多地方都会使用到下拉菜单：</p>
<p><img src="https://s2.loli.net/2022/10/28/hc354p1ri6NmGgA.png" alt="image-20221028161118028"></p>
<p>而我们编写AWT程序也可以添加这样的菜单，只需要为窗口设定一个菜单栏即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MenuBar</span> <span class="variable">bar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MenuBar</span>();    <span class="comment">//创建菜单栏 </span></span><br><span class="line"><span class="type">Menu</span> <span class="variable">menu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(<span class="string">&quot;我是1号菜单&quot;</span>);</span><br><span class="line">menu.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;测试1&quot;</span>));</span><br><span class="line">menu.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;测试2&quot;</span>));</span><br><span class="line">bar.add(menu);</span><br><span class="line">frame.setMenuBar(bar);    <span class="comment">//为窗口设定刚刚定义好的菜单栏</span></span><br></pre></td></tr></table></figure>

<p>设定好MenuBar之后，我们的程序就有菜单了：</p>
<p><img src="https://s2.loli.net/2022/10/28/wIWdRo2velTj1VS.png" alt="image-20221028161741397"></p>
<p>虽然有点丑，但是确实是内味，不过还是MacOS下好看：</p>
<p><img src="https://s2.loli.net/2022/10/28/7Dq6L1hbreYIy39.png" alt="image-20221028161910928"></p>
<p>我们着重来看一下MenuItem，这是我们菜单的每一个选项，我们可以为其添加监听器来监听用户是否点击：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MenuItem</span> <span class="variable">item</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;测试1&quot;</span>);</span><br><span class="line">item.addActionListener(e -&gt; System.out.println(<span class="string">&quot;一号选项被点击了！&quot;</span>));</span><br><span class="line">menu.add(item);</span><br></pre></td></tr></table></figure>

<p>其实跟我们之前学习的按钮是差不多的：</p>
<p><img src="https://s2.loli.net/2022/10/28/KskDE9J2QdRtlvV.png" alt="image-20221028162602244"></p>
<p>我们还可以为菜单中的选项设定快捷键：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MenuItem</span> <span class="variable">item</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;测试1&quot;</span>);</span><br><span class="line">item.setShortcut(<span class="keyword">new</span> <span class="title class_">MenuShortcut</span>(<span class="string">&#x27;A&#x27;</span>));   <span class="comment">//MenuShortcut就是指定快捷键组合，默认情况下是Ctrl+指定按键</span></span><br><span class="line"><span class="comment">//item.setShortcut(new MenuShortcut(&#x27;A&#x27;, true));   //第二个参数指定为true表示需要Ctrl+Shift+指定按键</span></span><br></pre></td></tr></table></figure>

<p>这里的效果就是Ctrl+A触发快捷键：</p>
<p><img src="https://s2.loli.net/2022/10/30/lwrjgRxu46UXHZk.png" alt="image-20221030173320786"></p>
<p>当然，除了这种普通的菜单选项之外，还有可以勾选的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">menu.add(<span class="keyword">new</span> <span class="title class_">CheckboxMenuItem</span>(<span class="string">&quot;测试2&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>CheckboxMenuItem是可以勾选的选项，它能够对状态进行记录，我们点击选项之后会变成勾选状态：</p>
<p><img src="https://s2.loli.net/2022/10/28/Q1RgUn7ejZXzH5E.png" alt="image-20221028162655033"></p>
<p>实际上要添加这样的菜单栏还是挺简单的的，我们接着来看弹出菜单，弹出菜单其实也经常出现，比如我们要新建一个类，我们就可以右键对应的包：</p>
<p><img src="https://s2.loli.net/2022/10/28/IKe1NL5wm834WdP.png" alt="image-20221028214019648"></p>
<p>弹出一个浮在窗口之上的，并且可以进行选择的菜单，这个就是弹出菜单。</p>
<p>比如我们想要实现右键窗口任意位置都弹出菜单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PopupMenu</span> <span class="variable">menu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PopupMenu</span>();    <span class="comment">//创建弹出菜单</span></span><br><span class="line">menu.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;选项1&quot;</span>));   <span class="comment">//每一个选项依然是使用MenuItem</span></span><br><span class="line">menu.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;选项2&quot;</span>));</span><br><span class="line">frame.add(menu);    <span class="comment">//注意，弹出菜单也要作为组件加入到窗口中（但是默认情况下不显示）</span></span><br><span class="line"></span><br><span class="line">frame.addMouseListener(<span class="keyword">new</span> <span class="title class_">MouseAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mousePressed</span><span class="params">(MouseEvent e)</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (e.getButton() == MouseEvent.BUTTON3) &#123;  <span class="comment">//监听鼠标右键</span></span><br><span class="line">            menu.show(frame, e.getX(), e.getY());   <span class="comment">//要展示弹出菜单，我们只需要调用show方法即可</span></span><br><span class="line">          	<span class="comment">//注意，第一个参数必须是弹出菜单所加入的窗口或是窗口中的任意一个组件</span></span><br><span class="line">          	<span class="comment">//后面的坐标就是相对于这个窗口或是组件的原点（左上角）这个位置进行弹出</span></span><br><span class="line">          	<span class="comment">//我们这里写的就是相对于当前窗口的左上角，鼠标点击位置的x、y位置弹出窗口</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们来看看实际效果吧：</p>
<p><img src="https://s2.loli.net/2022/10/28/tMRbdjE6ZhHuPaQ.png" alt="image-20221028215651667"></p>
<p>这样，我们就可以设计出更加高级的程序了。</p>
<h3 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h3><p>有些时候，我们点击关闭按钮之后，窗口并不会直接关闭，而是会弹出一个对话框询问我们是否要退出，比如我们使用记事本编辑完之后未保存就关闭记事本，就会提示我们：</p>
<p><img src="https://s2.loli.net/2022/10/28/VUshJzZXxC51gpb.png" alt="image-20221028220721666"></p>
<p>实际上像这样弹出的的一个对话框，在很多时候都很关键，我们也可以使用AWT为我们提供的对话框，比如我们现在希望在关闭窗口时询问我们是否真的要关闭：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dialog</span> <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dialog</span>(frame, <span class="string">&quot;我是对话框&quot;</span>, <span class="literal">true</span>);   </span><br><span class="line"><span class="comment">//第一个参数是父窗口或是父对话框（没错，对话框也可以由对话框唤起）</span></span><br><span class="line"><span class="comment">//最后一个参数是当对话框展示时，是否让父窗口（对话框）无法点击</span></span><br><span class="line">dialog.setSize(<span class="number">200</span>, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">frame.addWindowListener(<span class="keyword">new</span> <span class="title class_">WindowAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosing</span><span class="params">(WindowEvent e)</span> &#123;</span><br><span class="line">        dialog.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当我们点击关闭时：</p>
<p><img src="https://s2.loli.net/2022/10/28/VmajcUlSD6GPsrv.png" alt="image-20221028223431754"></p>
<p>可以看到这里确实弹出了一个对话框（这个对话框无法最小化到图标）也就是说我们只能通过操作对话框来关闭它。</p>
<p>只不过就单单是这样的一个对话框太过单调了，我们可以为其添加一些按钮之类的东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dialog</span> <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dialog</span>(frame, <span class="string">&quot;我是对话框&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">dialog.setResizable(<span class="literal">false</span>);</span><br><span class="line">dialog.add(<span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;确定是否要退出程序？&quot;</span>), BorderLayout.NORTH);   <span class="comment">//对话框默认采用的是边界布局</span></span><br><span class="line">dialog.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;取消&quot;</span>), BorderLayout.WEST);</span><br><span class="line">dialog.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;不退出&quot;</span>), BorderLayout.EAST);</span><br><span class="line">dialog.setSize(<span class="number">200</span>, <span class="number">80</span>);</span><br></pre></td></tr></table></figure>

<p>这样我们退出时，就有对应的提示了：</p>
<p><img src="https://s2.loli.net/2022/10/28/3v7ZJio9mMnK8zk.png" alt="image-20221028224410637"></p>
<p>对话框就像一个特殊的窗口一样，各位小伙伴可以自由发挥。</p>
<p>有些时候我们在使用应用程序的时候，可能需要我们去选择电脑上的一些文件，这个时候我们就可以使用文件对话框：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileDialog</span> <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileDialog</span>(frame, <span class="string">&quot;请选择一个文件&quot;</span>, FileDialog.LOAD);  <span class="comment">//选择文件对话框类型，可以是加载文件或是保存文件</span></span><br><span class="line"></span><br><span class="line">frame.addWindowListener(<span class="keyword">new</span> <span class="title class_">WindowAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosing</span><span class="params">(WindowEvent e)</span> &#123;</span><br><span class="line">        dialog.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>文件对话框是根据操作系统提供的文件选择器决定的：</p>
<p><img src="https://s2.loli.net/2022/10/28/TuHNLsmokZvMhIR.png" alt="image-20221028224815769"></p>
<p>我们可以通过文件对话框选择一个文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileDialog</span> <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileDialog</span>(frame, <span class="string">&quot;请选择一个文件&quot;</span>, FileDialog.LOAD);</span><br><span class="line"></span><br><span class="line">frame.addWindowListener(<span class="keyword">new</span> <span class="title class_">WindowAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosing</span><span class="params">(WindowEvent e)</span> &#123;</span><br><span class="line">        dialog.setVisible(<span class="literal">true</span>);   <span class="comment">//注意，需要将对话框展示出来之后，才能进行选择</span></span><br><span class="line">      	<span class="comment">//选择完成之后getDirectory和getFile方法就可以返回结果了，否则会阻塞</span></span><br><span class="line">        System.out.println(<span class="string">&quot;选择的文件为：&quot;</span>+dialog.getDirectory() + dialog.getFile());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>选择文件之后，我们可以通过对话框直接获取到对应的文件：</p>
<p><img src="https://s2.loli.net/2022/10/28/uRjWKPgFxCcGUvr.png" alt="image-20221028225343739"></p>
<p>是不是感觉还是挺简单的？</p>
<h3 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h3><p>除了使用官方提供的这些组件之外，我们也可以自己创建一些组件来使用，比如官方没有提供图片组件，我们可以自己编写一个图片组件用于在窗口中展示我们的图片。</p>
<p>要自己编写一个组件，需要完成下面的步骤：</p>
<ul>
<li>必须继承自Component类，表示这是一个AWT组件。</li>
<li>需要自己实现<code>paintComponent</code>方法，这个方法就是组件的绘制方法，最终绘制出来的结果就是展示出来的结果了。</li>
</ul>
<p>首先我们先把最简单的事情做了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageView</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;   <span class="comment">//继承自Component表示是一个组件</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImageView</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;    <span class="comment">//重写paint方法，这个方法就是组件的绘制方法</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以先创建一个这个组件并放到我们的窗口中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">ImageView</span>()); </span><br></pre></td></tr></table></figure>

<p>这里用的是边界布局，默认情况下组件会被添加到中心，占满整个窗口。但是由于我们并没有编写任何绘制内容，所以说组件是空白的一片。</p>
<p>我们来看看这个<code>paint</code>方法该如何重写，这个方法实际上是在窗口绘制时自动调用，那么到底什么是绘制呢？实际上绘制就是需要我们进行画图操作，当窗口首次展示或是修改大小时就会调用这个方法绘制组件（使用过OpenGL的小伙伴应该能够很容易上手）</p>
<p>这个方法给了我们一个Graphics对象，实际上这个对象就是我们用于绘制图形的工具，比如我们这个组件需要绘制的是一个矩形：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;   <span class="comment">//各位小伙伴可以将Graphics看做一只画笔，我们想让画笔做什么就做什么</span></span><br><span class="line">    g.setColor(Color.BLACK);      <span class="comment">//我们可以先将画笔切换为黑色</span></span><br><span class="line">    g.fillRect(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight());   <span class="comment">//drawRect就是绘制矩形区域，这里的x和y是相对于当前组件的位置来的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看最后会绘制成啥样：</p>
<p><img src="https://s2.loli.net/2022/10/28/qQweM6DprRJjCl7.png" alt="image-20221028232701565"></p>
<p>可以看到整个组件都被涂成了黑色，我们还可以绘制更多好玩的图形：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;</span><br><span class="line">    g.setColor(Color.BLACK);</span><br><span class="line">    g.fillRect(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight());</span><br><span class="line">    g.setColor(Color.RED);    <span class="comment">//画笔改成红色</span></span><br><span class="line">  	<span class="comment">//在中间画个圆角矩形边框</span></span><br><span class="line">    g.drawRoundRect(getWidth() / <span class="number">4</span>, getHeight() / <span class="number">4</span>, getWidth() / <span class="number">2</span>, getHeight() / <span class="number">2</span>, <span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的效果就是这样了：</p>
<p><img src="https://s2.loli.net/2022/10/28/xBsuijLa6beOwJy.png" alt="image-20221028233307877"></p>
<p>是不是感觉还挺好玩的，就像我们在玩画画游戏一样。这里列一下Graphics接口提供的所有功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Graphics</span> &#123;</span><br><span class="line">   	<span class="comment">//移动画笔原点到指定坐标，默认是(0,0)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">translate</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">    <span class="comment">//设定画笔颜色</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(Color c)</span>;</span><br><span class="line">    <span class="comment">//设置为普通绘画模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">setPaintMode</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//交替颜色模式，比较高级，小伙伴自行了解</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">setXORMode</span><span class="params">(Color c1)</span>;</span><br><span class="line">    <span class="comment">//设置字体，绘制文本内容时就按照这个字体来绘制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">setFont</span><span class="params">(Font font)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置裁剪区域，一旦设置裁剪区域，那么裁剪区域以外的地方即使绘制，也不会生效，绘制</span></span><br><span class="line">  	<span class="comment">//只会在裁剪区域内生效（有点像图层蒙版？）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">setClip</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span>;</span><br><span class="line">    <span class="comment">//设定自定义形状的裁剪区域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">setClip</span><span class="params">(Shape clip)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝指定区域的内容到另一个位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">copyArea</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height,</span></span><br><span class="line"><span class="params">                                  <span class="type">int</span> dx, <span class="type">int</span> dy)</span>;</span><br><span class="line">    <span class="comment">//绘制直线</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">drawLine</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span>;</span><br><span class="line">    <span class="comment">//填充矩形区域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fillRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span>;</span><br><span class="line">    <span class="comment">//绘制矩形边框</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span>;</span><br><span class="line">		<span class="comment">//绘制圆角矩形边框</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">drawRoundRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> arcWidth, <span class="type">int</span> arcHeight)</span>;</span><br><span class="line">    <span class="comment">//填充圆角矩形区域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fillRoundRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> arcWidth, <span class="type">int</span> arcHeight)</span>;</span><br><span class="line">    <span class="comment">//绘制3D矩形边框（其实就是加了个深色和浅色边框，有一个视觉效果罢了）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw3DRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> raised)</span>;</span><br><span class="line">    <span class="comment">//填充3D矩形区域（同上）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fill3DRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> raised)</span>;</span><br><span class="line">    <span class="comment">//绘制椭圆形边框</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">drawOval</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span>;</span><br><span class="line">    <span class="comment">//填充椭圆形区域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fillOval</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span>;</span><br><span class="line">    <span class="comment">//绘制弧线边框</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">drawArc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height,</span></span><br><span class="line"><span class="params">                                 <span class="type">int</span> startAngle, <span class="type">int</span> arcAngle)</span>;</span><br><span class="line">		<span class="comment">//填充扇形区域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fillArc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height,</span></span><br><span class="line"><span class="params">                                 <span class="type">int</span> startAngle, <span class="type">int</span> arcAngle)</span>;</span><br><span class="line">    <span class="comment">//绘制折线（需要提供多个坐标）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">drawPolyline</span><span class="params">(<span class="type">int</span> xPoints[], <span class="type">int</span> yPoints[],</span></span><br><span class="line"><span class="params">                                      <span class="type">int</span> nPoints)</span>;</span><br><span class="line">		<span class="comment">//绘制多边形边框</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">drawPolygon</span><span class="params">(<span class="type">int</span> xPoints[], <span class="type">int</span> yPoints[],</span></span><br><span class="line"><span class="params">                                     <span class="type">int</span> nPoints)</span>;</span><br><span class="line">    <span class="comment">//填充多边形区域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fillPolygon</span><span class="params">(<span class="type">int</span> xPoints[], <span class="type">int</span> yPoints[],</span></span><br><span class="line"><span class="params">                                     <span class="type">int</span> nPoints)</span>;</span><br><span class="line">    <span class="comment">//绘制文本</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">drawString</span><span class="params">(String str, <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">   	<span class="comment">//绘制图片（绘制大小为图片原本大小）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">drawImage</span><span class="params">(Image img, <span class="type">int</span> x, <span class="type">int</span> y,</span></span><br><span class="line"><span class="params">                                      ImageObserver observer)</span>;</span><br><span class="line">   	<span class="comment">//绘制按自定义大小缩放后的图片</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">drawImage</span><span class="params">(Image img, <span class="type">int</span> x, <span class="type">int</span> y,</span></span><br><span class="line"><span class="params">                                      <span class="type">int</span> width, <span class="type">int</span> height,</span></span><br><span class="line"><span class="params">                                      ImageObserver observer)</span>;</span><br><span class="line">    <span class="comment">//绘制图片时如果是透明部分则采用背景颜色填充</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">drawImage</span><span class="params">(Image img, <span class="type">int</span> x, <span class="type">int</span> y,</span></span><br><span class="line"><span class="params">                                      Color bgcolor,</span></span><br><span class="line"><span class="params">                                      ImageObserver observer)</span>;</span><br><span class="line">    <span class="comment">//绘制按自定义大小缩放后带背景颜色的图片</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">drawImage</span><span class="params">(Image img, <span class="type">int</span> x, <span class="type">int</span> y,</span></span><br><span class="line"><span class="params">                                      <span class="type">int</span> width, <span class="type">int</span> height,</span></span><br><span class="line"><span class="params">                                      Color bgcolor,</span></span><br><span class="line"><span class="params">                                      ImageObserver observer)</span>;</span><br><span class="line">    <span class="comment">//对原本的图片按照起始坐标和尺寸进行裁剪后，再以给定大小绘制到给定位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">drawImage</span><span class="params">(Image img,</span></span><br><span class="line"><span class="params">                                      <span class="type">int</span> dx1, <span class="type">int</span> dy1, <span class="type">int</span> dx2, <span class="type">int</span> dy2,</span></span><br><span class="line"><span class="params">                                      <span class="type">int</span> sx1, <span class="type">int</span> sy1, <span class="type">int</span> sx2, <span class="type">int</span> sy2,</span></span><br><span class="line"><span class="params">                                      ImageObserver observer)</span>;</span><br><span class="line">    <span class="comment">//累了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">drawImage</span><span class="params">(Image img,</span></span><br><span class="line"><span class="params">                                      <span class="type">int</span> dx1, <span class="type">int</span> dy1, <span class="type">int</span> dx2, <span class="type">int</span> dy2,</span></span><br><span class="line"><span class="params">                                      <span class="type">int</span> sx1, <span class="type">int</span> sy1, <span class="type">int</span> sx2, <span class="type">int</span> sy2,</span></span><br><span class="line"><span class="params">                                      Color bgcolor,</span></span><br><span class="line"><span class="params">                                      ImageObserver observer)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这里要实现的时绘制一个图片，那么我们就可以像这样编写了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageView</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Image image;   </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImageView</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filename);</span><br><span class="line">        image = ImageIO.read(file);   <span class="comment">//我们可以使用ImageIO类来快速将图片文件读取为Image对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;</span><br><span class="line">      	<span class="comment">//绘制图片需要提供Image对象</span></span><br><span class="line">        g.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight(), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来试试看效果吧：</p>
<p><img src="https://s2.loli.net/2022/10/28/5adDsGr2iRxywCX.png" alt="image-20221028235756338"></p>
<p>可以看到图片成功绘制出来了，这样，我们就提供自己编写绘制逻辑，成功完成了一个简单的自定义组件。</p>
<p>当然，现在我们讲了如何加载图片，顺便把设定自定义的程序图标介绍一下吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> ImageIO.read(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.png&quot;</span>));</span><br><span class="line">frame.setIconImage(image);</span><br></pre></td></tr></table></figure>

<p>注意，在MacOS下这样写没用，得用专用的增强包：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> ImageIO.read(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.png&quot;</span>));</span><br><span class="line">Application.getApplication().setDockIconImage(image);</span><br></pre></td></tr></table></figure>

<p>这样，我们的程序就会显示为我们自己定义的图标了。</p>
<h3 id="窗口修饰和自定义形状"><a href="#窗口修饰和自定义形状" class="headerlink" title="窗口修饰和自定义形状"></a>窗口修饰和自定义形状</h3><p>实际上我的窗口在默认情况下都是处于修饰状态，那么什么是修饰状态呢？</p>
<p>窗口修饰实际上就是我们窗口外面添加的边框：</p>
<p><img src="https://s2.loli.net/2022/10/26/fMQDFCmyqIvJeTl.png" alt="image-20221026164200924"></p>
<p>有些时候，可能我们并不需要系统为我们提供的窗口边框，我们希望能够自己编写窗口的边框，包括各种按钮等，此时我们就可以将窗口设定为非修饰状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Frame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Frame</span>(<span class="string">&quot;我是窗口&quot;</span>);</span><br><span class="line">    frame.setUndecorated(<span class="literal">true</span>);   <span class="comment">//将窗口设定为非修饰状态</span></span><br><span class="line">    frame.setSize(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">    frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非修饰状态下，就只有一个窗口本身了：</p>
<p><img src="https://s2.loli.net/2022/10/29/u9jSlmAc2GXr4VJ.png" alt="image-20221029111107959"></p>
<p>并且这个窗口是无法完成拖拽操作的，要实现拖拽还得我们自己编写（太原始了）可以看到，在默认情况下窗口的形状是一个方形的，我们可以将其调整为其他形状：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Frame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Frame</span>(<span class="string">&quot;我是窗口&quot;</span>);</span><br><span class="line">    frame.setUndecorated(<span class="literal">true</span>);</span><br><span class="line">    frame.setSize(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">  	<span class="comment">//注意，只有窗口在非修饰状态下才能设定形状</span></span><br><span class="line">  	<span class="comment">//这里我们使用圆角矩形，形状最好跟窗口大小一样</span></span><br><span class="line">    frame.setShape(<span class="keyword">new</span> <span class="title class_">RoundRectangle2D</span>.Double(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line">    frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们的窗口变成了这样：</p>
<p><img src="https://s2.loli.net/2022/10/29/areQf2g3I74mlpV.png" alt="image-20221029111439062"></p>
<p>变成了好看的圆角矩形（但是这个圆角处理得不太好，有点毛毛糙糙的）圆角矩形也是现代操作系统窗口的设计语言。</p>
<p>我们也可以自行为窗口添加标题栏，同样只需要重写一下<code>paint</code>方法自行绘制就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Frame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Frame</span>(<span class="string">&quot;我是窗口&quot;</span>) &#123;    <span class="comment">//使用匿名内部类（或者自己写个子类也行）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;</span><br><span class="line">        g.setColor(Color.LIGHT_GRAY);</span><br><span class="line">        g.fillRect(<span class="number">0</span>, <span class="number">0</span>, getWidth(), <span class="number">28</span>);   <span class="comment">//先绘制标题栏</span></span><br><span class="line">        g.setColor(Color.BLACK); </span><br><span class="line">        g.drawString(getTitle(), getWidth() / <span class="number">2</span>, <span class="number">20</span>);   <span class="comment">//绘制标题名称</span></span><br><span class="line">        <span class="built_in">super</span>.paint(g);   <span class="comment">//原本的绘制别覆盖了，该怎么做还要怎么做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们来看看效果吧：</p>
<p><img src="https://s2.loli.net/2022/10/29/hQ2YLjSgazM9Wkd.png" alt="image-20221029112035219"></p>
<p>是不是感觉不依靠操作系统，我们自己也能写一个好看的窗口出来了？</p>
<p>只不过这个窗口还不能拖动，我们来实现一下按住标题栏就可以拖动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">frame.addMouseMotionListener(<span class="keyword">new</span> <span class="title class_">MouseMotionAdapter</span>() &#123;   <span class="comment">//只需要写一个监听器就可以搞定了</span></span><br><span class="line">    <span class="type">int</span> oldX, oldY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseDragged</span><span class="params">(MouseEvent e)</span> &#123;   <span class="comment">//鼠标拖动时如果是标题栏，就将窗口位置修改</span></span><br><span class="line">        <span class="keyword">if</span>(e.getY() &lt;= <span class="number">28</span>)</span><br><span class="line">            frame.setLocation(e.getXOnScreen() - oldX, e.getYOnScreen() - oldY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseMoved</span><span class="params">(MouseEvent e)</span> &#123;   <span class="comment">//记录上一次的鼠标位置</span></span><br><span class="line">        oldX = e.getX();</span><br><span class="line">        oldY = e.getY();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>至此，有关AWT相关的内容，我们就讲解到这里，相信各位小伙伴肯定已经跃跃欲试想要开发一个自己的桌面应用程序了。只不过很遗憾，Java官方并没有再对AWT相关内容进行维护，因为AWT采用的是取不同操作系统交集策略，因为有些功能只有部分操作系统才有，这就导致很多功能都被砍掉，维护起来也很困难。下节课开始，我们会继续介绍Swing相关组件。</p>
<hr>
<h2 id="Swing组件介绍"><a href="#Swing组件介绍" class="headerlink" title="Swing组件介绍"></a>Swing组件介绍</h2><p>前面我们介绍了AWT，通过Java官方为我们提供的GUI框架，我们就可以编写出自己的桌面应用程序了，现在各位小伙伴应该已经有着良好的图形化界面开发基础了。</p>
<p>而Swing组件才是我们要学习的重点内容，它也是一套GUI框架，但是它是基于AWT编写的上层框架。</p>
<blockquote>
<p>Swing 是在AWT的基础上构建的一套新的图形界面系统，它提供了AWT 所能够提供的所有功能，并且用纯粹的Java代码对AWT 的功能进行了大幅度的扩充。例如说并不是所有的操作系统都提供了对树形控件的支持， Swing 利用了AWT 中所提供的基本作图方法对树形控件进行模拟。由于 Swing 控件是用100%的Java代码来实现的，因此在一个平台上设计的树形控件可以在其他平台上使用。由于在Swing 中没有使用本地方法来实现图形功能，我们通常把Swing控件称为轻量级控件。</p>
</blockquote>
<p>其实简单来说，这玩意就是AWT那一套东西的扩展，或者说是强化版，很多东西还是沿用的AWT中的。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>我们来看看如何使用Swing编写桌面程序，首先还是最重要的窗口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;我是窗口&quot;</span>);   <span class="comment">//Swing中的窗口叫做JFrame，对应的就是AWT中的Frame</span></span><br><span class="line">    <span class="comment">//它实际上就是Frame的子类，所以说我们之前怎么用的，现在怎么用就行了</span></span><br><span class="line">    frame.setSize(<span class="number">500</span>, <span class="number">300</span>);</span><br><span class="line">    frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是感觉学会AWT之后再看Swing也太简单了？</p>
<p>当然，既然是AWT的扩展，那肯定是有更多的新增功能的，比如我们之前想要实现点击X号关闭Java程序，这里我们只需要使用一个方法就可以设定了，不需要我们自己去写监听器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们可以直接为窗口设定关闭操作，JFrame已经为我们预设好了一些常用的操作了</span></span><br><span class="line">frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  <span class="comment">//EXIT_ON_CLOSE就是直接退出程序，默认是只隐藏</span></span><br></pre></td></tr></table></figure>

<p>Swing为我们提供了所有原本AWT中的组件的升级版，他们的名字前面都加上了J，比如按钮组件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;我是窗口&quot;</span>);</span><br><span class="line">    frame.setLayout(<span class="literal">null</span>);</span><br><span class="line">    <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;Link Start&quot;</span>);  <span class="comment">//Button组件对应的就是JButton了</span></span><br><span class="line">    button.setBounds(<span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">    frame.add(button);</span><br><span class="line">    frame.setSize(<span class="number">500</span>, <span class="number">300</span>);</span><br><span class="line">    frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Swing不像AWT那样，平台组件长啥样，就用什么，它的组件都是自行绘制的：</p>
<p><img src="https://s2.loli.net/2022/10/29/dy6R2VNuOYIJamA.png" alt="image-20221029120313940"></p>
<p>这样，我们在不同的平台上，看到的组件UI样式，都会是一样的，不会出现长得不一样的情况。并且我们可以为组件自由替换皮肤，我们会在后面进行介绍。</p>
<p>还有，Swing在没有设定布局时，组件的坐标原点并不是窗口的左上角，而是窗口标题栏下方的左上角：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;我是窗口&quot;</span>);</span><br><span class="line">frame.setSize(<span class="number">500</span>, <span class="number">300</span>);</span><br><span class="line">frame.setLayout(<span class="literal">null</span>);</span><br><span class="line">frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line"><span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;我是按钮&quot;</span>);</span><br><span class="line">button.setBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">frame.add(button);</span><br><span class="line">frame.setVisible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/11/05/RMJWl576CiSDs8b.png" alt="image-20221105171035570"></p>
<p>这一点确实比AWT好很多，不然咱都不知道不同平台的标题栏到底是多高。至于为什么是这样，这是因为JFrame内部实际上单独维护了一个面板来存放组件，很多操作都被重定向给了内部的面板，这里就不深入说了，知道就行。</p>
<p>同样的，如果我们要使用菜单，直接使用对应的类即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;我是窗口&quot;</span>);</span><br><span class="line"><span class="type">JMenuBar</span> <span class="variable">bar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JMenuBar</span>();    <span class="comment">//JMenuBar对应的就是MenuBar</span></span><br><span class="line"><span class="type">JMenu</span> <span class="variable">menu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JMenu</span>(<span class="string">&quot;我是菜单&quot;</span>);</span><br><span class="line">menu.add(<span class="keyword">new</span> <span class="title class_">JMenuItem</span>(<span class="string">&quot;选项1&quot;</span>));</span><br><span class="line">menu.add(<span class="keyword">new</span> <span class="title class_">JMenuItem</span>(<span class="string">&quot;选项2&quot;</span>));</span><br><span class="line">bar.add(menu);</span><br><span class="line">frame.setJMenuBar(bar);</span><br><span class="line">frame.setSize(<span class="number">500</span>, <span class="number">300</span>);</span><br><span class="line">frame.setVisible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>这个菜单也是Swing自己绘制的，如果是AWT的话，不同系统菜单位置还不一样，虽然这里是自己画的，但是效果看着还行：</p>
<p><img src="https://s2.loli.net/2022/10/29/aMGHTu8sl2Sg4vm.png" alt="image-20221029120737715"></p>
<p>所以，Swing相关组件在使用上其实和我们之前学习的AWT是差不多的，只要前面AWT学的没问题，这里简直So Easy。</p>
<p>因为Swing是沿用的AWT框架体系，所以说AWT提供的旧组件，也是可以用的，但是这里不推荐：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;我是窗口&quot;</span>);</span><br><span class="line">    frame.setSize(<span class="number">500</span>, <span class="number">300</span>);</span><br><span class="line">    frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;我是按钮&quot;</span>));   <span class="comment">//可以继续使用AWT组件，但是有新的咱肯定用新的啊</span></span><br><span class="line">    frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关其他组件还请各位小伙伴自行了解。</p>
<h3 id="新增组件介绍"><a href="#新增组件介绍" class="headerlink" title="新增组件介绍"></a>新增组件介绍</h3><p>Swing除了强化AWT提供的组件之外，还自行实现了各种各样新式的组件，我们来依次介绍一下。</p>
<p>首先是进度条组件：</p>
<p><img src="https://s2.loli.net/2022/11/05/SY8wjEkdcArvxnQ.png" alt="image-20221105163846233"></p>
<p>很多时候我们都会用到进度条来展示某些任务的完成进度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JProgressBar</span> <span class="variable">bar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JProgressBar</span>();</span><br><span class="line">bar.setMaximum(<span class="number">100</span>);    <span class="comment">//设定进度条的最大值</span></span><br><span class="line">bar.setValue(<span class="number">50</span>);    <span class="comment">//设定进度值</span></span><br><span class="line">bar.setBounds(<span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>我们可以利用进度条来写一个很简单的案例，比如文件的拷贝：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JProgressBar</span> <span class="variable">bar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JProgressBar</span>();   <span class="comment">//进度条显示文件拷贝进度</span></span><br><span class="line">bar.setMaximum(<span class="number">1000</span>);</span><br><span class="line">bar.setBounds(<span class="number">20</span>, <span class="number">50</span>, <span class="number">300</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;点击开始&quot;</span>);   <span class="comment">//点击按钮开始拷贝文件</span></span><br><span class="line">button.setBounds(<span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br><span class="line">button.addActionListener(e -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//注意，不能直接在这个线程里面处理，因为这个线程是负责图形界面的，得单独创建一个线程处理，否则图形界面会卡死</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;in.iso&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.iso&quot;</span>))&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> file.length(), current = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = in.read(bytes)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            current += len;</span><br><span class="line">            bar.setValue((<span class="type">int</span>) (bar.getMaximum() * (<span class="type">double</span>)current / size));   <span class="comment">//每次拷贝都更新进度条</span></span><br><span class="line">          	bar.repaint();  <span class="comment">//因为并不是每次更新值都会使得组件重新绘制，如果视觉上比较卡，可以每次拷贝都重新绘制组件</span></span><br><span class="line">            out.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException exception) &#123;</span><br><span class="line">        exception.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start());</span><br></pre></td></tr></table></figure>

<p>这样，我们在拷贝文件的时候，就有一个进度条实时显示当前的进度了：</p>
<p><img src="https://s2.loli.net/2022/11/05/qNoT6OwylH4Y8xc.png" alt="image-20221105165756172"></p>
<p>我们接着来看下一个组件，开关按钮：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JToggleButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JToggleButton</span>(<span class="string">&quot;我是切换按钮&quot;</span>);   <span class="comment">//开关按钮有两个状态，一个是开一个是关</span></span><br><span class="line">button.setBounds(<span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>它就像：</p>
<p><img src="https://s2.loli.net/2022/11/05/1fBdjMOy4SnADHu.png" alt="image-20221105170052200"></p>
<p>它有着两个状态，我们点击一次会使得其切换到另一种状态：</p>
<p><img src="https://s2.loli.net/2022/11/05/JXpw64yHb8rCRSg.png" alt="image-20221105170125623"></p>
<p>还有一些大型组件，比如颜色选择器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JColorChooser</span> <span class="variable">chooser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JColorChooser</span>();</span><br><span class="line">chooser.setBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">600</span>, <span class="number">300</span>);</span><br></pre></td></tr></table></figure>

<p>颜色选择器的主要作用顾名思义，就是让用户选择一个颜色：</p>
<p><img src="https://s2.loli.net/2022/11/05/zsjxuSoYEr9lvZy.png" alt="image-20221105170623359"></p>
<p>这个太高级了，看着就很专业。同样的还有文件选择器JFileChooser：</p>
<p><img src="https://s2.loli.net/2022/11/05/T6Vld1NMB9AJfct.png" alt="image-20221105170745920"></p>
<p>完了，这Mac越用咋越像Windows了。</p>
<p>当然，Swing考虑得不止这些，甚至连工具提示都有，啥是工具提示？</p>
<p><img src="https://s2.loli.net/2022/11/05/mGaU6X2ILvqQT1g.png" alt="image-20221105171336948"></p>
<p>实际上就是当我们鼠标移动到某个组件上时，会给出一个漂浮提示，告诉我们这个组件是干嘛用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;我是按钮&quot;</span>);</span><br><span class="line">button.setBounds(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br><span class="line">button.setToolTipText(<span class="string">&quot;这个按钮是用来解决你毕设的！&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/11/05/izpvcCbVA3Ut81u.png" alt="image-20221105171453445"></p>
<p><code>setToolTipText</code>方法是<code>JComponent</code>就带有的，因此任何组件都可以设置这样的工具提示，是不是感觉很高级？</p>
<p>还有文件树，我们经常在窗口中看到这样的：</p>
<p><img src="https://s2.loli.net/2022/11/05/gcCnLterFaqPvkK.png" alt="image-20221105171728838"></p>
<p>我们的文件实际上在硬盘上就是以树形存储的，而Swing也为我们提供了能够显示树形关系的组件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTree</span>();</span><br><span class="line">tree.setBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/11/05/IvjYykGRXiOAMtK.png" alt="image-20221105171813979"></p>
<p>这样，我们就可以用它来做一个文件资源管理器了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里我们让JTree展示.idea目录下所有文件</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.idea&quot;</span>);   <span class="comment">//这里我们列出.idea目录下所有文件</span></span><br><span class="line"><span class="type">DefaultMutableTreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMutableTreeNode</span>(file.getName()); <span class="comment">//既然是树形关系，肯定有一个根结点</span></span><br><span class="line"><span class="comment">//拿到当前目录下所有文件和文件夹</span></span><br><span class="line">File[] files = Optional.ofNullable(file.listFiles()).orElseGet(() -&gt; <span class="keyword">new</span> <span class="title class_">File</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (File f : files)</span><br><span class="line">    root.add(<span class="keyword">new</span> <span class="title class_">DefaultMutableTreeNode</span>(f.getName()));    <span class="comment">//构造子结点并连接</span></span><br><span class="line"></span><br><span class="line"><span class="type">JTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTree</span>(root);    <span class="comment">//设定默认的根结点</span></span><br><span class="line">tree.setBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<p>来看看效果吧：</p>
<p><img src="https://s2.loli.net/2022/11/05/YN4gKJbfstpRSCE.png" alt="image-20221105172802572"></p>
<p>你就说有没有内味吧。</p>
<h3 id="多面板和分割面板"><a href="#多面板和分割面板" class="headerlink" title="多面板和分割面板"></a>多面板和分割面板</h3><p>前面我们介绍了Swing为我们提供的丰富组件，我们接着来看多面板。</p>
<p><img src="https://s2.loli.net/2022/11/05/keDg2pnsJolaUZH.png" alt="image-20221105173345221"></p>
<p>多面板顾名思义，就是为了在一个窗口中展示多个面板，但是面板是可以自由切换的，在顶部会有一个小小的标签，我们点击之后就可以切换到对应的面板了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JTabbedPane</span> <span class="variable">pane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTabbedPane</span>();</span><br><span class="line">pane.setBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span>, <span class="number">300</span>);</span><br><span class="line">pane.addTab(<span class="string">&quot;一号&quot;</span>, <span class="keyword">new</span> <span class="title class_">JPanel</span>()&#123;&#123;setBackground(Color.ORANGE);&#125;&#125;);</span><br><span class="line">pane.addTab(<span class="string">&quot;二号&quot;</span>, <span class="keyword">new</span> <span class="title class_">JPanel</span>()&#123;&#123;setBackground(Color.PINK);&#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>JTabbedPane跟我们之前认识的Panel很像，相当于也是将我们的组件装进了内部，但是它可以同时装很多个，并且支持自由切换，所以说是很高级的。</p>
<p>这里我们创建两个面板，将一号面板设定为橙色，二号面板设定为粉色，分别添加到里面：</p>
<p><img src="https://s2.loli.net/2022/11/05/4jp1N9LnmwJGtOl.png" alt="image-20221105173821177"></p>
<p>这样，我们就可以布置一号面板做某些事情，二号面板做另外一些事情了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JTabbedPane</span> <span class="variable">pane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTabbedPane</span>();</span><br><span class="line">pane.setBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span>, <span class="number">300</span>); </span><br><span class="line">pane.addTab(<span class="string">&quot;一号&quot;</span>, <span class="keyword">new</span> <span class="title class_">JColorChooser</span>());   <span class="comment">//一号面板当颜色选择器</span></span><br><span class="line">pane.addTab(<span class="string">&quot;二号&quot;</span>, <span class="keyword">new</span> <span class="title class_">JFileChooser</span>());    <span class="comment">//二号面板当文件选择器</span></span><br></pre></td></tr></table></figure>

<p>高级感一下就出来了不是：</p>
<p><img src="https://s2.loli.net/2022/11/05/QBPn8lk9tFd6sgH.png" alt="image-20221105174105955"></p>
<p>除了多面板这样的特殊面板组件之外，我们也可以使用分割面板：</p>
<p><img src="https://s2.loli.net/2022/11/05/2gMxOrFGkHCJ73o.png" alt="image-20221105174239436"></p>
<p>分割面板将一块完整的面板分割为两个部分，这样，我们就可以分别在左右两边进行操作了，而且中间的分割线是可以拖动的，实际上我们的IDEA也是这样的：</p>
<p><img src="https://s2.loli.net/2022/11/05/21l4GHg75fCaFzP.png" alt="image-20221105174326135"></p>
<p>IDEA的左边是文件管理器，右边就是编辑区域，同样支持拖动中间的分割线，这样的设计是非常人性化的。</p>
<p>我们来看看如何创建分割面板：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JSplitPane</span> <span class="variable">pane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSplitPane</span>();</span><br><span class="line">pane.setOrientation(JSplitPane.HORIZONTAL_SPLIT);  <span class="comment">//设定为横向分割</span></span><br><span class="line"><span class="comment">//横向分割之后，我们需要指定左右两边的组件</span></span><br><span class="line">pane.setLeftComponent(<span class="keyword">new</span> <span class="title class_">JPanel</span>()&#123;&#123;setBackground(Color.ORANGE);&#125;&#125;);</span><br><span class="line">pane.setRightComponent(<span class="keyword">new</span> <span class="title class_">JPanel</span>()&#123;&#123;setBackground(Color.PINK);&#125;&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/11/05/3VjoCckOZG2qNIf.png" alt="image-20221105174609500"></p>
<p>配合我们之前的JTree组件和JTextArea组件，我们也可以写一个简单的IDEA软件出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JTextArea</span> <span class="variable">area</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextArea</span>();   <span class="comment">//右边就是我们需要编辑的文本域</span></span><br><span class="line"></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.idea&quot;</span>);</span><br><span class="line"><span class="type">DefaultMutableTreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMutableTreeNode</span>(file);</span><br><span class="line">File[] files = Optional.ofNullable(file.listFiles()).orElseGet(() -&gt; <span class="keyword">new</span> <span class="title class_">File</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (File f : files)</span><br><span class="line">    root.add(<span class="keyword">new</span> <span class="title class_">DefaultMutableTreeNode</span>(f.getName()));</span><br><span class="line"><span class="type">JTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTree</span>(root);   <span class="comment">//左边就是我们的文件树</span></span><br><span class="line">tree.addTreeSelectionListener(e -&gt; &#123;   <span class="comment">//点击文件之后，我们需要变换编辑窗口中的文本内容，这里加个监听器</span></span><br><span class="line">    area.setText(<span class="string">&quot;&quot;</span>);   <span class="comment">//先清空</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;.idea/&quot;</span>+e.getPath().getLastPathComponent().toString()))&#123;</span><br><span class="line">        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">128</span>];   <span class="comment">//直接开始读取内容</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = reader.read(chars)) &gt; <span class="number">0</span>)</span><br><span class="line">            area.setText(area.getText() + <span class="keyword">new</span> <span class="title class_">String</span>(chars, <span class="number">0</span>, len));   <span class="comment">//开始写入到编辑窗口中</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pane.setLeftComponent(<span class="keyword">new</span> <span class="title class_">JScrollPane</span>(tree));   <span class="comment">//文件树和编辑区域都套一个滚动面板，因为有可能会撑得很大</span></span><br><span class="line">pane.setRightComponent(<span class="keyword">new</span> <span class="title class_">JScrollPane</span>(area));</span><br></pre></td></tr></table></figure>

<p>我们来看看我们自己写的IDEA软件怎么样吧：</p>
<p><img src="https://s2.loli.net/2022/11/05/rwik4EqaOeMYWfz.png" alt="image-20221105180609195"></p>
<p>嗯，真不错，各位小伙伴赶紧去JetBrains投简历吧！</p>
<h3 id="选项窗口"><a href="#选项窗口" class="headerlink" title="选项窗口"></a>选项窗口</h3><p>前面我们介绍过对话框，但是AWT提供的对话框太过原始，很多功能都需要我们自行实现，而Swing为我们提供了一套已经实现好的预设选项对话框，我们只需要直接使用即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;我是窗口&quot;</span>);</span><br><span class="line">frame.setSize(<span class="number">500</span>, <span class="number">300</span>);</span><br><span class="line">frame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);  <span class="comment">//先将默认关闭行为设定为什么都不做</span></span><br><span class="line">frame.addWindowListener(<span class="keyword">new</span> <span class="title class_">WindowAdapter</span>() &#123;   <span class="comment">//我们自己来实现窗口关闭行为</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosing</span><span class="params">(WindowEvent e)</span> &#123;   <span class="comment">//这里我们可以直接展示一个预设好的确认对话框</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> JOptionPane.showConfirmDialog(frame, <span class="string">&quot;你真的要退出吗？&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(value == JOptionPane.OK_OPTION)    <span class="comment">//返回值就是用户的选择结果，也是预置好的，这里判断如果是OK那么就退出</span></span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们之前要实现这样的一个功能，非常麻烦，但是现在就很简单了：</p>
<p><img src="https://s2.loli.net/2022/11/06/ekOZLQnUR2dMXTN.png" alt="image-20221106162732123"></p>
<p>官方已经给我们预设好了一个对话框，我们直接用就可以了。当然，还有各种类型的，我们可以自己定义窗口的标题、图标等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JOptionPane.showConfirmDialog(frame, <span class="string">&quot;你真的要退出吗？&quot;</span>, <span class="string">&quot;退出程序&quot;</span>, JOptionPane.YES_NO_OPTION);</span><br></pre></td></tr></table></figure>

<p>除了这种简单的对话框，Swing还为我们提供了一些其他类型的对话框，比如单纯的消息提示框：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JOptionPane.showMessageDialog(frame, <span class="string">&quot;我是简单的提示消息！&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/11/06/YH8dgDRunsG9jPv.png" alt="image-20221106165351473"></p>
<p>还有用户输入文本的输入对话框：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;我是窗口&quot;</span>);</span><br><span class="line">frame.setSize(<span class="number">500</span>, <span class="number">300</span>);</span><br><span class="line">frame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);</span><br><span class="line">frame.addWindowListener(<span class="keyword">new</span> <span class="title class_">WindowAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosing</span><span class="params">(WindowEvent e)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> JOptionPane.showInputDialog(<span class="string">&quot;毕业后的你，将何去何从呢？&quot;</span>);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/11/06/ZwGfv1HqOjikEPn.png" alt="image-20221106165324954"></p>
<p>通过灵活使用这些对话框，用户与我们的交互就更加亲密了。</p>
<h3 id="自定义主题"><a href="#自定义主题" class="headerlink" title="自定义主题"></a>自定义主题</h3><p>Swing早就考虑到了不同平台可能会出现的组件样式差异，因此推出了皮肤机制。</p>
<p>就像我们可以给英雄换皮肤一样，我们的组件UI也是可以换皮肤的，官方名称叫做LookAndFeel，Swing官方为我们提供了很多套皮肤，这些皮肤都是可以跨平台的，当然也有某些平台专属的限定皮肤：</p>
<ul>
<li>MetalLookAndFeel  -  官方默认皮肤</li>
<li>WindowsLookAndFeel  -  Windows操作系统限定皮肤，其他平台无法使用</li>
<li>MotifLookAndFeel   -   官方皮肤</li>
<li>NimbusLookAndFeel   -   官方皮肤</li>
<li>AquaLookAndFeel    -    MacOS操作系统限定皮肤，其他平台无法使用</li>
</ul>
<p>更换皮肤很简单，我们只需要执行一个方法就可以，它是全局生效的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIManager.setLookAndFeel(<span class="keyword">new</span> <span class="title class_">AquaLookAndFeel</span>());</span><br></pre></td></tr></table></figure>

<p>这里我们将皮肤设定为MacOS的冰雪节限定皮肤AquaLookAndFeel：</p>
<p><img src="https://s2.loli.net/2022/11/06/L7HyUlVpA5P9iTZ.png" alt="image-20221106170921703"></p>
<p>是不是感觉视觉上和之前的皮肤不太一样？我们可以多看看其他的皮肤：</p>
<p><img src="https://s2.loli.net/2022/11/06/EGrWzIZuRfejXN2.png" alt="image-20221106171046755"></p>
<p><img src="https://s2.loli.net/2022/11/06/BOtWrIe7CuklMcZ.png" alt="image-20221106171110930"></p>
<p>实际上Swing组件的绘制并不是由组件本身编写的，而是在各个UI实现类中编写的，所以说要修改组件样式只需要更换皮肤即可。</p>
<p>除了全局设定皮肤之外，我们也可以单独对某些组件设定皮肤，每个组件都有自己的<code>getUI</code>方法，这个方法就是获取当前组件使用的UI样式的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(tree.getUI());</span><br></pre></td></tr></table></figure>

<p>这里得到的是：</p>
<p><img src="https://s2.loli.net/2022/11/06/2NChELXRkoqJGMQ.png" alt="image-20221106224348544"></p>
<p>我们可以自己编写一个UI样式来为组件进行设定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TestJButtonUI</span> <span class="keyword">extends</span> <span class="title class_">ButtonUI</span> &#123;   <span class="comment">//继承对应的UI父类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g, JComponent c)</span> &#123;   <span class="comment">//我们只需要重写对应UI的paint方法就可以了</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> c.getWidth(), height = c.getHeight();</span><br><span class="line">        g.setColor(Color.BLACK);</span><br><span class="line">        g.fillRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        g.setColor(Color.WHITE);</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> (JButton) c;</span><br><span class="line">        g.drawString(button.getText(), <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只需要使用set方法来设定即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;我是按钮&quot;</span>);</span><br><span class="line">button.setBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">30</span>);</span><br><span class="line">button.setUI(<span class="keyword">new</span> <span class="title class_">TestJButtonUI</span>());   <span class="comment">//将UI设定为我们自己定义的即可</span></span><br></pre></td></tr></table></figure>

<p>这样就换成我们自己的皮肤了：</p>
<p><img src="https://s2.loli.net/2022/11/06/53kHx2zTZ7wtUfC.png" alt="image-20221106231437842"></p>
<p>各位小伙伴甚至可以编写一套自己的UI，并制作成一个LookAndFeel，这样我们写出来的程序就非常个性化了。</p>
<hr>
<h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><p>前面我们已经学习了Swing的全部内容，最后我们还是来做一个小项目吧！</p>
<h3 id="Intellij-IDEA-Extreme"><a href="#Intellij-IDEA-Extreme" class="headerlink" title="Intellij IDEA Extreme"></a>Intellij IDEA Extreme</h3><p>我们的目标是用IDEA写一个IDEA（当然不会太复杂，只需要实现基本功能就可以了）</p>
<p>需求分析：</p>
<ul>
<li>支持创建项目、管理项目文件</li>
<li>支持对源代码文件的编辑</li>
<li>支持一键编译、运行</li>
</ul>
<p>做Swing项目，什么五子棋、坦克大战都弱爆了，这里我们直接手撕一个IDEA出来。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.hoveco.top">nothing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.hoveco.top/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89GUI%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/">https://www.hoveco.top/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89GUI%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.hoveco.top" target="_blank">Hoveco Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaSE/">JavaSE</a></div><div class="post-share"><div class="social-share" data-image="https://5b0988e595225.cdn.sohucs.com/images/20170823/972ca31aced141008aea907b4efacee9.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89/" title="JavaSE-学习笔记-集合类与IO（六）"><img class="cover" src="https://5b0988e595225.cdn.sohucs.com/images/20170823/972ca31aced141008aea907b4efacee9.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">JavaSE-学习笔记-集合类与IO（六）</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89/" title="JavaSE-学习笔记-多线程与反射（七）"><img class="cover" src="https://5b0988e595225.cdn.sohucs.com/images/20170823/972ca31aced141008aea907b4efacee9.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">JavaSE-学习笔记-多线程与反射（七）</div></div><div class="info-2"><div class="info-item-1"> 多线程与反射前面我们已经讲解了JavaSE的大部分核心内容，最后一章，我们还将继续学习JavaSE中提供的各种高级特性。这些高级特性对于我们之后的学习，会有着举足轻重的作用。 多线程注意：本章节会涉及到 操作系统...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/" title="JavaSE-学习笔记-新手入门（一）"><img class="cover" src="https://5b0988e595225.cdn.sohucs.com/images/20170823/972ca31aced141008aea907b4efacee9.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-12</div><div class="info-item-2">JavaSE-学习笔记-新手入门（一）</div></div><div class="info-2"><div class="info-item-1"> 新手入门篇注意：开始学习JavaSE之前建议学习的前置课程《C语言程序设计》《数据结构》《操作系统》《计算机组成原理》 欢迎各位小伙伴来到JavaSE视频教程，期待与各位小伙伴共度这一旅程！视频中所有的文档、资料，都可以直接在视频下方简介中找到，视频非培训机构出品，纯个人录制，不需要加任何公众号、小程序，直接自取即可。 教程开始之前，提醒各位小伙伴：  如果你对某样东西不熟悉，请务必保证跟视频中使用一模一样的环境、一模一样的操作方式去使用，不要自作主张，否则出现某些奇怪的问题又不知道怎么办，就会浪费很多时间。 视频依然是基于Java 8进行讲解，不要自己去安装一个其他的版本，想要了解新版本特性可以在另一个视频里面观看。 在学习过程中，尽可能避免出现中文文件夹，包括后面的环境安装、项目创建，都尽量不要放在中文路径下（因为使用中文常常出现奇奇怪怪的问题）建议使用对应的英文单词代替，或者是用拼音都可以，最好只出现英文字母和数字。 本系列教程使用...</div></div></div></a><a class="pagination-related" href="/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/" title="JavaSE-学习笔记-面向过程（二）"><img class="cover" src="https://5b0988e595225.cdn.sohucs.com/images/20170823/972ca31aced141008aea907b4efacee9.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-12</div><div class="info-item-2">JavaSE-学习笔记-面向过程（二）</div></div><div class="info-2"><div class="info-item-1"> 面向过程篇前面我们已经认识了Java语言的相关特性，并且已经成功配置好了开发环境，从这节课开始，我们就可以正式进入到Java语言的学习当中了。Java语言是一门面向对象的语言，但是在面向对象之前，我们还得先学会如何面向过程编程。 Java程序基础首先我们还是从最基本的Java程序基础开始讲解。 程序代码基本结构还记得我们之前使用的示例代码吗？ 12345public class Main &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;Hello World!&quot;);    &#125;&#125;  这段代码要实现的功能很简单，就是将 Hello World 输出到控制台就行。 由于我们还没有学习到类的相关性质，所以在第二章之前，各位小伙伴直接记住固定模式即可，首先我们创建的源文件名称需要为Main.java然后编写的代码第一行： 123public class Main &#123; ...</div></div></div></a><a class="pagination-related" href="/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/" title="JavaSE-学习笔记-面向对象基础（三）"><img class="cover" src="https://5b0988e595225.cdn.sohucs.com/images/20170823/972ca31aced141008aea907b4efacee9.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-12</div><div class="info-item-2">JavaSE-学习笔记-面向对象基础（三）</div></div><div class="info-2"><div class="info-item-1"> 面向对象基础篇我们在前面已经学习了面向过程编程，也可以自行编写出简单的程序了。我们接着就需要认识 面向对象程序设计（Object Oriented Programming）它是我们在Java语言中要学习的重要内容，面向对象也是高级语言的一大重要特性。  面向对象是新手成长的一道分水岭，有的人秒懂，有的人直到最后都无法理解。  这一章开始难度就上来了，所以说请各位小伙伴一定认真。 类与对象类的概念我们在生活中其实已经听说过很多了。 人类、鸟类、鱼类…...</div></div></div></a><a class="pagination-related" href="/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/" title="JavaSE-学习笔记-泛型（五）"><img class="cover" src="https://5b0988e595225.cdn.sohucs.com/images/20170823/972ca31aced141008aea907b4efacee9.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-12</div><div class="info-item-2">JavaSE-学习笔记-泛型（五）</div></div><div class="info-2"><div class="info-item-1"> 泛型程序设计在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们还会继续深入了解，从泛型开始，再到数据结构，最后再开始我们的集合类学习，循序渐进。 泛型为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以优秀、良好、合格 来作为结果，还有一种就是 60.0、75.5、92.5 这样的数字分数，可能高等数学这门课是以数字成绩进行结算，而计算机网络实验这门课是以等级进行结算，这两种分数类型都有可能出现，那么现在该如何去设计这样的一个Score类呢？ 现在的问题就是，成绩可能是String类型，也可能是Integer类型，如何才能很好的去存可能出现的两种类型呢？ 1234567891011public class Score &#123;    String name;    String id;    Object value;  //因为Object是所有类型的父类，因此既可以存放Integer也能存放String  	public...</div></div></div></a><a class="pagination-related" href="/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/" title="JavaSE-学习笔记-面向对象高级（四）"><img class="cover" src="https://5b0988e595225.cdn.sohucs.com/images/20170823/972ca31aced141008aea907b4efacee9.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-12</div><div class="info-item-2">JavaSE-学习笔记-面向对象高级（四）</div></div><div class="info-2"><div class="info-item-1"> 面向对象高级篇经过前面的学习，我们已经了解了面向对象编程的大部分基础内容，这一部分，我们将继续探索面向对象编程过程中一些常用的东西。 基本类型包装类Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。Java中的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！ 包装类介绍所有的包装类层次结构如下：  其中能够表示数字的基本类型包装类，继承自Number类，对应关系如下表：  byte  -&gt;  Byte boolean  -&gt;  Boolean short  -&gt;  Short char  -&gt;  Character int -&gt; Integer long -&gt;  Long float -&gt; Float double -&gt; Double  我们可以直接使用，这里我们以Integer类为例： 123public static void main(String[]...</div></div></div></a><a class="pagination-related" href="/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89/" title="JavaSE-学习笔记-集合类与IO（六）"><img class="cover" src="https://5b0988e595225.cdn.sohucs.com/images/20170823/972ca31aced141008aea907b4efacee9.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-12</div><div class="info-item-2">JavaSE-学习笔记-集合类与IO（六）</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Hoveco</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Hoveco"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Hoveco" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:hoveco@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #f26522;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临本站，若喜欢请收藏^_^</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#GUI%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91"><span class="toc-number">1.</span> <span class="toc-text">GUI程序开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AWT%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">AWT组件介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6"><span class="toc-number">1.1.1.</span> <span class="toc-text">基本框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">监听器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6"><span class="toc-number">1.1.3.</span> <span class="toc-text">常用组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B1%80%E5%92%8C%E9%9D%A2%E6%9D%BF"><span class="toc-number">1.1.4.</span> <span class="toc-text">布局和面板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E9%9D%A2%E6%9D%BF%E5%92%8C%E5%88%97%E8%A1%A8"><span class="toc-number">1.1.5.</span> <span class="toc-text">滚动面板和列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8F%9C%E5%8D%95%E6%A0%8F"><span class="toc-number">1.1.6.</span> <span class="toc-text">菜单栏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">1.1.7.</span> <span class="toc-text">对话框</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6"><span class="toc-number">1.1.8.</span> <span class="toc-text">自定义组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E4%BF%AE%E9%A5%B0%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BD%A2%E7%8A%B6"><span class="toc-number">1.1.9.</span> <span class="toc-text">窗口修饰和自定义形状</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Swing%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.</span> <span class="toc-text">Swing组件介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.2.</span> <span class="toc-text">新增组件介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%9D%A2%E6%9D%BF%E5%92%8C%E5%88%86%E5%89%B2%E9%9D%A2%E6%9D%BF"><span class="toc-number">1.2.3.</span> <span class="toc-text">多面板和分割面板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E9%A1%B9%E7%AA%97%E5%8F%A3"><span class="toc-number">1.2.4.</span> <span class="toc-text">选项窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98"><span class="toc-number">1.2.5.</span> <span class="toc-text">自定义主题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98"><span class="toc-number">1.3.</span> <span class="toc-text">项目实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Intellij-IDEA-Extreme"><span class="toc-number">1.3.1.</span> <span class="toc-text">Intellij IDEA Extreme</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/02/02/deepseek%E9%83%A8%E7%BD%B2/" title="DeepSeek 本地化部署"><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2025%2F0130%2F73f8f691j00sqvy7o001bd000sd00iwg.jpg&amp;thumbnail=660x2147483647&amp;quality=80&amp;type=jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DeepSeek 本地化部署"/></a><div class="content"><a class="title" href="/2025/02/02/deepseek%E9%83%A8%E7%BD%B2/" title="DeepSeek 本地化部署">DeepSeek 本地化部署</a><time datetime="2025-02-02T00:30:00.000Z" title="发表于 2025-02-02 08:30:00">2025-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/06/linux%E5%91%BD%E4%BB%A4/" title="linux常用命令"><img src="https://img1.baidu.com/it/u=2235406156,2735822811&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux常用命令"/></a><div class="content"><a class="title" href="/2024/09/06/linux%E5%91%BD%E4%BB%A4/" title="linux常用命令">linux常用命令</a><time datetime="2024-09-06T07:20:27.000Z" title="发表于 2024-09-06 15:20:27">2024-09-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/18/%E5%85%AC%E5%85%B1%E8%B5%84%E6%BA%90CDN/" title="前端公共资源库CDN"><img src="https://www.layuicdn.com/jie/2023-04-11/2796026/1681202457-1777895225.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端公共资源库CDN"/></a><div class="content"><a class="title" href="/2024/08/18/%E5%85%AC%E5%85%B1%E8%B5%84%E6%BA%90CDN/" title="前端公共资源库CDN">前端公共资源库CDN</a><time datetime="2024-08-18T07:20:27.000Z" title="发表于 2024-08-18 15:20:27">2024-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/27/git/" title="GIt"><img src="https://5b0988e595225.cdn.sohucs.com/images/20190801/ab8b77dbe3914e70a3101eee95c52683.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GIt"/></a><div class="content"><a class="title" href="/2024/06/27/git/" title="GIt">GIt</a><time datetime="2024-06-27T02:20:27.000Z" title="发表于 2024-06-27 10:20:27">2024-06-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/30/ruanjianxiazai/" title="实用软件下载"><img src="http://img2.baidu.com/it/u=628404148,4087608110&amp;fm=253&amp;app=138&amp;f=JPEG?w=800&amp;h=1069" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="实用软件下载"/></a><div class="content"><a class="title" href="/2024/05/30/ruanjianxiazai/" title="实用软件下载">实用软件下载</a><time datetime="2024-05-30T02:20:27.000Z" title="发表于 2024-05-30 10:20:27">2024-05-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Hoveco</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://beian.miit.gov.cn/" target="_blank">备案号:</a> <a href="https://beian.miit.gov.cn/" target="_blank">晋ICP备2023023040号-2</a><br> <a target="_blank" rel="noopener" href="https://beian.mps.gov.cn/#/query/webSearch?code=14082202000223"><img class="icp-icon" src="/img/gongan.png"><span>晋公网安备14082202000223号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://tell.hoveco.top/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script>window.newestComments = {
  changeContent: content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<code>.*?<\/code>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g, "") // remove html tag

    if (content.length > 150) {
      content = content.substring(0, 150) + '...'
    }
    return content
  },

  generateHtml: (array, ele) => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class="aside-list-item">'

        if (true && array[i].avatar) {
          const imgAttr = 'src'
          const lazyloadNative = ''
          result += `<a href="${array[i].url}" class="thumbnail"><img ${imgAttr}="${array[i].avatar}" alt="${array[i].nick}" ${lazyloadNative}></a>`
        }

        result += `<div class="content">
        <a class="comment" href="${array[i].url}" title="${array[i].content}">${array[i].content}</a>
        <div class="name"><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '暂无评论'
    }

    ele.innerHTML = result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh(ele)
  },

  newestCommentInit: (name, getComment) => {
    const $dom = document.querySelector('#card-newest-comments .aside-list')
    if ($dom) {
      const data = btf.saveToLocal.get(name)
      if (data) {
        newestComments.generateHtml(JSON.parse(data), $dom)
      } else {
        getComment($dom)
      }
    }
  },

  run: (name, getComment) => {
    newestComments.newestCommentInit(name, getComment)
    btf.addGlobalFn('pjaxComplete', () => newestComments.newestCommentInit(name, getComment), name)
  }
}</script><script>window.addEventListener('load', () => {
  const keyName = 'waline-newest-comments'
  const { changeContent, generateHtml, run } = window.newestComments

  const getComment = async (ele) => {
    try {
      const res = await fetch('https://tell.hoveco.top/api/comment?type=recent&count=6')
      const result = await res.json()
      const walineArray = result.data.map(e => {
        return {
          'content': changeContent(e.comment),
          'avatar': e.avatar,
          'nick': e.nick,
          'url': e.url + '#' + e.objectId,
          'date': e.time || e.insertedAt
        }
      })
      btf.saveToLocal.set(keyName, JSON.stringify(walineArray), 10/(60*24))
      generateHtml(walineArray, ele)
    } catch (err) {
      console.error(err)
      ele.textContent= "无法获取评论，请确认相关配置是否正确"
    }
  }

  run(keyName, getComment)
})</script><script type="text/javascript" src="/js/FunnyTitle.js"></script><script type="text/javascript" src="https://lib.sinaapp.com/js/jquery/1.9.1/jquery-1.9.1.min.js"></script><div class="aplayer no-destroy" data-id="10095424109" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="150" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.staticfile.net/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>