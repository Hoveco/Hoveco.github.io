<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hoveco Blog</title>
  
  <subtitle>Hの自留地</subtitle>
  <link href="https://www.hoveco.top/atom.xml" rel="self"/>
  
  <link href="https://www.hoveco.top/"/>
  <updated>2025-02-03T11:45:31.402Z</updated>
  <id>https://www.hoveco.top/</id>
  
  <author>
    <name>Hoveco</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DeepSeek 本地化部署</title>
    <link href="https://www.hoveco.top/2025/02/02/deepseek%E9%83%A8%E7%BD%B2/"/>
    <id>https://www.hoveco.top/2025/02/02/deepseek%E9%83%A8%E7%BD%B2/</id>
    <published>2025-02-02T00:30:00.000Z</published>
    <updated>2025-02-03T11:45:31.402Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Ollama部署DeepSeek全攻略"><a href="#Ollama部署DeepSeek全攻略" class="headerlink" title="Ollama部署DeepSeek全攻略"></a>Ollama部署DeepSeek全攻略</h3><p><strong>一、DeepSeek - R1模型简介</strong></p><p>DeepSeek - R1是一个高性能的AI推理模型，在数学、代码和自然语言推理任务方面表现出色。它具有以下特点：</p><ul><li><strong>专注多任务处理</strong>：能够同时应对数学计算、代码分析以及自然语言的逻辑推理等多种任务，例如在处理复杂数学公式推导、代码漏洞检测以及文章语义理解等任务时都有不错的表现。</li><li><strong>高效推理能力</strong>：相比于一些同类型模型，DeepSeek - R1在处理各种推理任务时，能够以较快的速度得出结果，减少用户等待时间。</li></ul><p>在应用场景方面，它可广泛应用于学术研究、软件开发以及内容创作等领域。与其他模型相比，DeepSeek - R1在推理任务上可能更具优势，例如在处理特定领域的复杂逻辑问题时准确性更高。</p><p><strong>二、Ollama简介</strong></p><p>Ollama是一个开源的本地化大模型部署工具，其优势显著。</p><ul><li><strong>简化部署管理</strong>：旨在简化大型语言模型（LLM）的安装、运行和管理，无论是对于经验丰富的开发者还是初学者来说，都能轻松上手。</li><li><strong>支持多种架构</strong>：支持多种模型架构，这意味着它可以适应不同类型的大型语言模型的部署需求。</li><li><strong>提供兼容API</strong>：提供与OpenAI兼容的API接口，方便开发者将其集成到自己的应用中，快速搭建私有化AI服务。</li></ul><p><strong>三、部署前的准备工作</strong></p><ol><li><p>系统要求</p><ul><li><strong>硬件资源</strong>：电脑或服务器需要具备足够的硬件资源，特别是显卡显存，因为大型语言模型对显存有较高的要求。例如，如果要运行较大模型如DeepSeek - R1的70b版本，可能需要较高显存的显卡。</li><li><strong>操作系统</strong>：安装好适用的操作系统，如macOS、Linux或Windows。</li></ul></li><li><p>Ollama安装</p><ul><li><p>macOS安装步骤</p><p>：</p><ul><li>访问Ollama官网（<a href="https://ollama.com/">ollama.com</a>）。</li><li>下载适用于macOS的Ollama版本。</li><li>下载完成后，按照安装向导进行安装，安装过程中可能需要输入管理员密码等操作。安装完成后，在顶部菜单栏中看到小羊驼的图标即表示安装成功。</li></ul></li><li><p>Linux安装步骤</p><p>：</p><ul><li>同样先访问Ollama官网下载适用于Linux的版本。</li><li>在终端中进入下载目录，使用命令行进行安装（例如，如果是deb包，可能使用<code>sudo dpkg -i ollama.deb</code>命令，具体根据实际下载的包类型而定）。</li><li>安装过程中可能需要安装一些依赖库，如果提示缺少依赖，根据提示进行安装即可。</li></ul></li><li><p>Windows安装步骤</p><p>：</p><ul><li>在Ollama官网下载Windows版本的安装程序（exe文件）。</li><li>双击启动安装程序，全程选择默认设置，点击“Install”后一直确认到底。安装完成后，程序会自动启动，在电脑右下角的托盘区域会看到Ollama的应用图标。</li></ul></li><li><p>验证Ollama安装成功的方法</p><p>：</p><ul><li>在macOS或Linux中，可以打开终端，输入<code>ollama version</code>，如果显示出Ollama的版本信息，如<code>ollama version is 0.5.7</code>，则表明安装成功。</li><li>在Windows中，可以打开命令行窗口（CMD），输入相同的<code>ollama version</code>命令查看版本信息来验证安装成功。</li></ul></li></ul></li></ol><p><strong>四、根据硬件配置选择DeepSeek - R1模型大小</strong></p><p>DeepSeek - R1有多种模型大小可供选择，如1.5b、7b、8b、14b、32b、70b或671b等。不同模型大小所需的硬件资源不同：</p><ul><li><strong>1.5b版本</strong>：比较轻量，资源占用较少，大概占用1GB多点显存，适用于硬件资源相对有限的情况，例如一些显存较小的笔记本电脑，可用于简单的文本处理和基础的推理任务。</li><li><strong>7b版本</strong>：所需空间大约4.7G，性能与OpenAI - o1相当，适合中等配置的电脑，能够处理较为复杂的任务，如代码分析和一般性的自然语言处理任务。</li><li><strong>8b版本</strong>：所需空间大约4.9G，可根据实际硬件情况，在与7b版本类似的配置下选择。</li><li><strong>14b版本</strong>：所需空间大约9G，需要较好的硬件支持，能够处理更复杂的数学和逻辑推理任务。</li><li><strong>32b版本</strong>：所需空间大约20G，对硬件要求较高，适用于需要高精度推理结果的场景，如专业的学术研究和高级软件开发中的一些任务。</li><li><strong>70b版本</strong>：所需空间大约43G，需要强大的硬件支持，包括大容量显存的显卡和较多的内存，可用于处理超复杂的多任务推理场景。</li><li><strong>671b版本</strong>：所需空间大约404G，对硬件要求极高，一般用于大规模数据处理和超高难度的推理任务。</li></ul><p><strong>五、下载DeepSeek - R1模型</strong></p><p>在部署之前，需要确保已经下载了DeepSeek - R1模型。可以从模型的官方仓库或其他可靠途径获取模型文件，通常模型文件是一个<code>.pt</code>或<code>.bin</code>文件。</p><p><strong>六、配置Ollama</strong></p><p>配置Ollama来使用DeepSeek - R1模型，这通常通过创建一个配置文件来完成。以下是一个配置文件的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yaml复制model: </span><br><span class="line">  name: deepseek</span><br><span class="line">  path: /path/to/your/deepseek_model.pt</span><br><span class="line">  type: pytorch</span><br></pre></td></tr></table></figure><p>请确保将<code>path</code>替换为实际下载并存放DeepSeek - R1模型文件的路径。</p><p><strong>七、启动Ollama服务</strong></p><p>使用配置好的文件启动Ollama服务。在终端或命令提示符中，运行相应的命令来启动服务。例如，如果使用的是默认的配置文件，可以运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line">复制</span><br><span class="line">ollama serve</span><br></pre></td></tr></table></figure><p><strong>八、验证部署</strong></p><p>可以通过发送请求来验证模型是否成功部署。使用curl或其他HTTP客户端工具发送一个POST请求到Ollama提供的API接口，并包含想要推理的文本作为输入。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line">复制</span><br><span class="line">curl -X POST -d &#x27;&#123;&#123; &quot;input&quot;: &quot;你的推理文本&quot; &#125;&#125;&#x27; http://localhost:你的端口号/api/v1/inference</span><br></pre></td></tr></table></figure><p>如果一切正常，会收到来自DeepSeek - R1模型的推理结果。</p><p><strong>九、使用API</strong></p><p>一旦模型成功部署，可以通过API来使用它。Ollama通常会提供一个REST API接口，可以通过HTTP请求来与模型交互。</p><ul><li><strong>API调用返回结果解释</strong>：API调用返回的结果通常是JSON格式的数据。例如，可能包含模型的推理结果、一些状态信息等。如果是处理自然语言任务，可能返回一段生成的文本内容；如果是数学计算任务，可能返回计算结果等。</li><li><strong>处理常见错误码</strong>：如果返回的状态码为400，可能表示请求格式错误，需要检查发送的请求内容是否符合API要求；如果是500，可能表示服务器内部错误，可能需要检查Ollama服务是否正常运行，模型是否正确加载等。</li></ul><p><strong>十、监控和优化</strong></p><p>部署完成后，可以使用Ollama提供的监控工具来监控模型的性能和资源使用情况。根据监控数据，可以对系统进行优化，比如调整模型参数、增加资源分配等。</p><p><strong>十一、故障处理</strong></p><ol><li>启动失败案例<ul><li><strong>问题描述</strong>：在启动Ollama服务时，提示找不到模型文件。</li><li><strong>日志信息示例</strong>：可能在日志中显示“Model file not found at specified path”。</li><li><strong>排查步骤</strong>：首先检查配置文件中的模型文件路径是否正确，确保模型文件确实存在于指定路径下。如果路径正确，检查文件权限是否正确，是否有读取权限等。</li></ul></li><li>性能不佳案例<ul><li><strong>问题描述</strong>：模型推理速度很慢。</li><li><strong>日志信息示例</strong>：可能在性能监控日志中看到CPU或GPU使用率过高，或者内存不足的提示。</li><li><strong>排查步骤</strong>：检查硬件资源使用情况，如果是CPU使用率过高，可能是同时运行了其他大量占用CPU的程序，可以关闭一些不必要的程序；如果是GPU显存不足，可以考虑降低模型大小或者增加硬件资源（如升级显卡）；如果是内存不足，可以关闭一些占用内存大的程序或者增加内存容量。</li></ul></li></ol><p>通过以上步骤，就能够成功使用Ollama部署DeepSeek - R1模型，并能顺利进行各种推理任务，同时在遇到问题时也能进行有效的处理。</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="人工智能" scheme="https://www.hoveco.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="AI" scheme="https://www.hoveco.top/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令</title>
    <link href="https://www.hoveco.top/2024/09/06/linux%E5%91%BD%E4%BB%A4/"/>
    <id>https://www.hoveco.top/2024/09/06/linux%E5%91%BD%E4%BB%A4/</id>
    <published>2024-09-06T07:20:27.000Z</published>
    <updated>2024-09-11T14:15:15.584Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础操作命令"><a href="#基础操作命令" class="headerlink" title="基础操作命令"></a>基础操作命令</h3><h4 id="关机和重启系统"><a href="#关机和重启系统" class="headerlink" title="关机和重启系统"></a>关机和重启系统</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now 或者 poweroff   关闭系统(1)</span><br><span class="line">init 0 关闭系统(2)</span><br><span class="line">telinit 0 关闭系统(3)</span><br><span class="line">shutdown -h hours:minutes    按预定时间关闭系统</span><br><span class="line">shutdown -c 取消按预定时间关闭系统</span><br><span class="line">shutdown -r now 重启(1)</span><br><span class="line">shutdown -r 2 两分钟后重启</span><br><span class="line">reboot 重启(2)</span><br><span class="line"><span class="built_in">logout</span> 注销</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="帮助命令（help）"><a href="#帮助命令（help）" class="headerlink" title="帮助命令（help）"></a>帮助命令（help）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig  --<span class="built_in">help</span>     //查看 ifconfig 命令的用法</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="命令说明书（man）"><a href="#命令说明书（man）" class="headerlink" title="命令说明书（man）"></a>命令说明书（man）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man shutdown         //打开命令说明后，可按<span class="string">&quot;q&quot;</span>键退出</span><br></pre></td></tr></table></figure><h4 id="切换用户（su）"><a href="#切换用户（su）" class="headerlink" title="切换用户（su）"></a>切换用户（su）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su yao               //切换为用户<span class="string">&quot;yao&quot;</span>,输入后回车需要输入该用户的密码</span><br><span class="line"><span class="built_in">exit</span>                 //退出当前用户</span><br></pre></td></tr></table></figure><h3 id="目录操作命令"><a href="#目录操作命令" class="headerlink" title="目录操作命令"></a>目录操作命令</h3><h4 id="切换目录（cd）"><a href="#切换目录（cd）" class="headerlink" title="切换目录（cd）"></a>切换目录（cd）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /                 //切换到根目录</span><br><span class="line"><span class="built_in">cd</span> /bin              //切换到根目录下的bin目录</span><br><span class="line"><span class="built_in">cd</span> ../               //切换到上一级目录 或者使用命令：<span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> ~                 //切换到home目录</span><br><span class="line"><span class="built_in">cd</span> -                 //切换到上次访问的目录</span><br><span class="line"><span class="built_in">cd</span> xx(文件夹名)       //切换到本目录下的名为xx的文件目录，如果目录不存在报错</span><br><span class="line"><span class="built_in">cd</span> /xxx/xx/x         //可以输入完整的路径，直接切换到目标目录，输入过程中可以使用tab键快速补全</span><br></pre></td></tr></table></figure><h4 id="查看目录（ls）"><a href="#查看目录（ls）" class="headerlink" title="查看目录（ls）"></a>查看目录（ls）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span>                   //查看当前目录下的所有目录和文件</span><br><span class="line"><span class="built_in">ls</span> -a                //查看当前目录下的所有目录和文件（包括隐藏的文件）</span><br><span class="line"><span class="built_in">ls</span> -l                //列表查看当前目录下的所有目录和文件（列表查看，显示更多信息），与命令<span class="string">&quot;ll&quot;</span>效果一样</span><br><span class="line"><span class="built_in">ls</span> /bin              //查看指定目录下的所有目录和文件 </span><br><span class="line"><span class="built_in">ls</span> -F  //查看目录中的文件</span><br><span class="line"><span class="built_in">ls</span> *[0-9]* //显示包含数字的文件名和目录名</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="创建目录（mkdir）"><a href="#创建目录（mkdir）" class="headerlink" title="创建目录（mkdir）"></a>创建目录（mkdir）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> tools          //在当前目录下创建一个名为tools的目录</span><br><span class="line"><span class="built_in">mkdir</span> /bin/tools     //在指定目录下创建一个名为tools的目录</span><br><span class="line"><span class="built_in">mkdir</span> tool1 tool2    //同时创建两个目录</span><br><span class="line"><span class="built_in">mkdir</span> -p /tmp/dir1/dir2 //创建一个目录树</span><br></pre></td></tr></table></figure><h4 id="修改目录（mv）"><a href="#修改目录（mv）" class="headerlink" title="修改目录（mv）"></a>修改目录（mv）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> 当前目录名 新目录名        //修改目录名，同样适用与文件操作</span><br><span class="line"><span class="built_in">mv</span> /usr/tmp/tool /opt       //将/usr/tmp目录下的tool目录剪切到 /opt目录下面</span><br><span class="line"><span class="built_in">mv</span> -r /usr/tmp/tool /opt    //递归剪切目录中所有文件和文件夹</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="拷贝目录（cp）"><a href="#拷贝目录（cp）" class="headerlink" title="拷贝目录（cp）"></a>拷贝目录（cp）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/tmp/tool /opt       //将/usr/tmp目录下的tool目录复制到 /opt目录下面</span><br><span class="line"><span class="built_in">cp</span> -r /usr/tmp/tool /opt    //递归剪复制目录中所有文件和文件夹</span><br><span class="line"><span class="built_in">cp</span> <span class="built_in">dir</span>/* .    //复制一个目录下的所有文件到当前工作目录</span><br></pre></td></tr></table></figure><h4 id="搜索目录（find）"><a href="#搜索目录（find）" class="headerlink" title="搜索目录（find）"></a>搜索目录（find）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">find /bin -name <span class="string">&#x27;a*&#x27;</span> //查找/bin目录下的所有以a开头的文件或者目录</span><br><span class="line">find / -name file1 //从 <span class="string">&#x27;/&#x27;</span> 开始进入根文件系统搜索文件和目录</span><br><span class="line">find / -user user1 //搜索属于用户 <span class="string">&#x27;user1&#x27;</span> 的文件和目录</span><br><span class="line">find /home/user1 -name \*.bin//在目录 <span class="string">&#x27;/ home/user1&#x27;</span> 中搜索带有<span class="string">&#x27;.bin&#x27;</span> 结尾的文件</span><br><span class="line">find /usr/bin -<span class="built_in">type</span> f -atime +100 //搜索在过去100天内未被使用过的执行文件</span><br><span class="line">find /usr/bin -<span class="built_in">type</span> f -mtime -10 //搜索在10天内被创建或者修改过的文件</span><br><span class="line">find / -name \*.rpm -<span class="built_in">exec</span> <span class="built_in">chmod</span> 755 <span class="string">&#x27;&#123;&#125;&#x27;</span> \;//搜索以 <span class="string">&#x27;.rpm&#x27;</span> 结尾的文件并定义其权限</span><br><span class="line">find / -xdev -name \*.rpm //搜索以 <span class="string">&#x27;.rpm&#x27;</span> 结尾的文件，忽略光驱、捷盘等可移动设备</span><br><span class="line">locate \*.ps //寻找以 <span class="string">&#x27;.ps&#x27;</span> 结尾的文件 - 先运行 <span class="string">&#x27;updatedb&#x27;</span> 命令</span><br><span class="line">whereis halt//显示一个二进制文件、源码或man的位置</span><br><span class="line"><span class="built_in">which</span> halt //显示一个二进制文件或可执行文件的完整路径</span><br></pre></td></tr></table></figure><h4 id="查看当前目录（pwd）"><a href="#查看当前目录（pwd）" class="headerlink" title="查看当前目录（pwd）"></a>查看当前目录（pwd）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span>                       //显示当前位置路径</span><br><span class="line">tree       //显示文件和目录由根目录开始的树形结构(1)</span><br><span class="line">lstree       //显示文件和目录由根目录开始的树形结构(2)</span><br></pre></td></tr></table></figure><h4 id="删除目录与文件（rm）"><a href="#删除目录与文件（rm）" class="headerlink" title="删除目录与文件（rm）"></a>删除目录与文件（rm）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> 文件名              //删除当前目录下的文件</span><br><span class="line"><span class="built_in">rm</span> -f 文件名           //删除当前目录的的文件（不询问）</span><br><span class="line"><span class="built_in">rm</span> -r 文件夹名         //递归删除当前目录下此名的目录</span><br><span class="line"><span class="built_in">rm</span> -rf 文件夹名        //递归删除当前目录下此名的目录（不询问）</span><br><span class="line"><span class="built_in">rm</span> -rf *              //将当前目录下的所有目录和文件全部删除</span><br><span class="line"><span class="built_in">rm</span> -rf /*             //将根目录下的所有文件全部删除【慎用！相当于格式化系统】</span><br><span class="line"><span class="built_in">rm</span> -rf dir1 dir2      //同时删除两个目录及它们的内容</span><br></pre></td></tr></table></figure><h3 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h3><h4 id="新增文件（touch）"><a href="#新增文件（touch）" class="headerlink" title="新增文件（touch）"></a>新增文件（touch）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span>  a.txt         //在当前目录下创建名为a的txt文件（文件不存在），如果文件存在，将文件时间属性修改为当前系统时间</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="删除文件（rm）"><a href="#删除文件（rm）" class="headerlink" title="删除文件（rm）"></a>删除文件（rm）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> 文件名              //删除当前目录下的文件</span><br><span class="line"><span class="built_in">rm</span> -f 文件名           //删除当前目录的的文件（不询问）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="编辑文件（vi、vim）"><a href="#编辑文件（vi、vim）" class="headerlink" title="编辑文件（vi、vim）"></a>编辑文件（vi、vim）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vi 文件名              //打开需要编辑的文件</span><br><span class="line">--进入后，操作界面有三种模式：命令模式（<span class="built_in">command</span> mode）、插入模式（Insert mode）和底行模式（last line mode）</span><br><span class="line">命令模式</span><br><span class="line">-刚进入文件就是命令模式，通过方向键控制光标位置，</span><br><span class="line">-使用命令<span class="string">&quot;dd&quot;</span>删除当前整行</span><br><span class="line">-使用命令<span class="string">&quot;/字段&quot;</span>进行查找</span><br><span class="line">-按<span class="string">&quot;i&quot;</span>在光标所在字符前开始插入</span><br><span class="line">-按<span class="string">&quot;a&quot;</span>在光标所在字符后开始插入</span><br><span class="line">-按<span class="string">&quot;o&quot;</span>在光标所在行的下面另起一新行插入</span><br><span class="line">-按<span class="string">&quot;：&quot;</span>进入底行模式</span><br><span class="line">插入模式</span><br><span class="line">-此时可以对文件内容进行编辑，左下角会显示 <span class="string">&quot;-- 插入 --&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">-按&quot;</span>ESC<span class="string">&quot;进入底行模式</span></span><br><span class="line"><span class="string">底行模式</span></span><br><span class="line"><span class="string">-退出编辑：      :q</span></span><br><span class="line"><span class="string">-强制退出：      :q!</span></span><br><span class="line"><span class="string">-保存并退出：    :wq</span></span><br><span class="line"><span class="string">## 操作步骤示例 ##</span></span><br><span class="line"><span class="string">1.保存文件：按&quot;</span>ESC<span class="string">&quot; -&gt; 输入&quot;</span>:<span class="string">&quot; -&gt; 输入&quot;</span>wq<span class="string">&quot;,回车     //保存并退出编辑</span></span><br><span class="line"><span class="string">2.取消操作：按&quot;</span>ESC<span class="string">&quot; -&gt; 输入&quot;</span>:<span class="string">&quot; -&gt; 输入&quot;</span>q!<span class="string">&quot;,回车     //撤销本次修改并退出编辑</span></span><br><span class="line"><span class="string">## 补充 ##</span></span><br><span class="line"><span class="string">vim +10 filename.txt                   //打开文件并跳到第10行</span></span><br><span class="line"><span class="string">vim -R /etc/passwd                     //以只读模式打开文件</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h4 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> a.txt          //查看文件最后一屏内容</span><br><span class="line">less a.txt         //PgUp向上翻页，PgDn向下翻页，<span class="string">&quot;q&quot;</span>退出查看</span><br><span class="line">more a.txt         //显示百分比，回车查看下一行，空格查看下一页，<span class="string">&quot;q&quot;</span>退出查看</span><br><span class="line"><span class="built_in">tail</span> -100 a.txt    //查看文件的后100行，<span class="string">&quot;Ctrl+C&quot;</span>退出查看</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文件权限命令"><a href="#文件权限命令" class="headerlink" title="文件权限命令"></a>文件权限命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  文件权限简介：<span class="string">&#x27;r&#x27;</span> 代表可读（4），<span class="string">&#x27;w&#x27;</span> 代表可写（2），<span class="string">&#x27;x&#x27;</span> 代表执行权限（1），括号内代表<span class="string">&quot;8421法&quot;</span></span><br><span class="line">  <span class="comment">##文件权限信息示例：-rwxrw-r--</span></span><br><span class="line">  -第一位：<span class="string">&#x27;-&#x27;</span>就代表是文件，<span class="string">&#x27;d&#x27;</span>代表是文件夹</span><br><span class="line">  -第一组三位：拥有者的权限</span><br><span class="line">  -第二组三位：拥有者所在的组，组员的权限</span><br><span class="line">  -第三组三位：代表的是其他用户的权限</span><br><span class="line">  普通授权    <span class="built_in">chmod</span> +x a.txt    </span><br><span class="line">  8421法     <span class="built_in">chmod</span> 777 a.txt     //1+2+4=7，<span class="string">&quot;7&quot;</span>说明授予所有权限</span><br><span class="line"></span><br><span class="line"><span class="built_in">ls</span> -lh 显示权限</span><br><span class="line"><span class="built_in">ls</span> /tmp | <span class="built_in">pr</span> -T5 -W<span class="variable">$COLUMNS</span> 将终端划分成5栏显示</span><br><span class="line"><span class="built_in">chmod</span> ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限</span><br><span class="line"><span class="built_in">chmod</span> go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限</span><br><span class="line"><span class="built_in">chown</span> user1 file1 改变一个文件的所有人属性</span><br><span class="line"><span class="built_in">chown</span> -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性</span><br><span class="line"><span class="built_in">chgrp</span> group1 file1 改变文件的群组</span><br><span class="line"><span class="built_in">chown</span> user1:group1 file1 改变一个文件的所有人和群组属性</span><br><span class="line">find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件</span><br><span class="line"><span class="built_in">chmod</span> u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限</span><br><span class="line"><span class="built_in">chmod</span> u-s /bin/file1 禁用一个二进制文件的 SUID位</span><br><span class="line"><span class="built_in">chmod</span> g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的</span><br><span class="line"><span class="built_in">chmod</span> g-s /home/public 禁用一个目录的 SGID 位</span><br><span class="line"><span class="built_in">chmod</span> o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件</span><br><span class="line"><span class="built_in">chmod</span> o-t /home/public 禁用一个目录的 STIKY 位</span><br><span class="line"><span class="built_in">chmod</span> +x 文件路径 为所有者、所属组和其他用户添加执行的权限</span><br><span class="line"><span class="built_in">chmod</span> -x 文件路径 为所有者、所属组和其他用户删除执行的权限</span><br><span class="line"><span class="built_in">chmod</span> u+x 文件路径 为所有者添加执行的权限</span><br><span class="line"><span class="built_in">chmod</span> g+x 文件路径 为所属组添加执行的权限</span><br><span class="line"><span class="built_in">chmod</span> o+x 文件路径 为其他用户添加执行的权限</span><br><span class="line"><span class="built_in">chmod</span> ug+x 文件路径 为所有者、所属组添加执行的权限</span><br><span class="line"><span class="built_in">chmod</span> =wx 文件路径 为所有者、所属组和其他用户添加写、执行的权限，取消读权限</span><br><span class="line"><span class="built_in">chmod</span> ug=wx 文件路径 为所有者、所属组添加写、执行的权限，取消读权限</span><br></pre></td></tr></table></figure><h3 id="打包和压缩命令"><a href="#打包和压缩命令" class="headerlink" title="打包和压缩命令"></a>打包和压缩命令</h3><h4 id="后缀命名"><a href="#后缀命名" class="headerlink" title="后缀命名"></a>后缀命名</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.zip、.rar        //windows系统中压缩文件的扩展名</span><br><span class="line">.tar              //Linux中打包文件的扩展名</span><br><span class="line">.gz               //Linux中压缩文件的扩展名</span><br><span class="line">.tar.gz           //Linux中打包并压缩文件的扩展名</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="打包文件"><a href="#打包文件" class="headerlink" title="打包文件"></a>打包文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf 打包压缩后的文件名 要打包的文件</span><br><span class="line">参数说明：z：调用gzip压缩命令进行压缩; c：打包文件; v：显示运行过程; f：指定文件名;</span><br><span class="line">示例：</span><br><span class="line">tar -zcvf a.tar file1 file2,...      //多个文件压缩打包</span><br><span class="line">bunzip2 file1.bz2 解压一个叫做 <span class="string">&#x27;file1.bz2&#x27;</span>的文件</span><br><span class="line">bzip2 file1 压缩一个叫做 <span class="string">&#x27;file1&#x27;</span> 的文件</span><br><span class="line">gunzip file1.gz 解压一个叫做 <span class="string">&#x27;file1.gz&#x27;</span>的文件</span><br><span class="line">gzip file1 压缩一个叫做 <span class="string">&#x27;file1&#x27;</span>的文件</span><br><span class="line">gzip -9 file1 最大程度压缩</span><br></pre></td></tr></table></figure><h4 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf a.tar                      //解包至当前目录</span><br><span class="line">tar -zxvf a.tar -C /usr------        //指定解压的位置</span><br><span class="line">unzip test.zip             //解压*.zip文件 </span><br><span class="line">unzip -l test.zip          //查看*.zip文件的内容 </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="系统文件结构说明"><a href="#系统文件结构说明" class="headerlink" title="系统文件结构说明"></a>系统文件结构说明</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/bin        二进制文件，系统常规命令</span><br><span class="line">/boot       这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</span><br><span class="line">/dev        设备文件，类似win的设备管理器，将所有的硬件用文件的形式存储</span><br><span class="line">/etc        大多数配置文件，软件的配置文件</span><br><span class="line">/home       普通用户的家目录</span><br><span class="line">/lib        32位函数库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</span><br><span class="line">/lib64      64位库</span><br><span class="line">/lost+found 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</span><br><span class="line">/media      手动临时挂载点，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</span><br><span class="line">/mnt        手动临时挂载点，光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了</span><br><span class="line">/opt        第三方软件安装位置</span><br><span class="line">/proc       进程信息及硬件信息</span><br><span class="line">/root       系统管理员，超级权限者的用户主目录</span><br><span class="line">/sbin       系统管理命令</span><br><span class="line">/srv        数据</span><br><span class="line">/var        存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件</span><br><span class="line">/sys        内核相关信息</span><br><span class="line">/tmp        临时文件</span><br><span class="line">/usr        用户相关设定，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录</span><br><span class="line">/usr/bin    系统用户使用的应用程序。</span><br><span class="line">/usr/sbin   超级用户使用的比较高级的管理程序和系统守护程序</span><br><span class="line">/usr/src    内核源代码默认的放置目录</span><br></pre></td></tr></table></figure><h3 id="日常系统命令"><a href="#日常系统命令" class="headerlink" title="日常系统命令"></a>日常系统命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -m 显示机器的处理器架构</span><br><span class="line"><span class="built_in">uname</span> -r 显示正在使用的内核版本</span><br><span class="line">dmidecode -q 显示硬件系统部件</span><br><span class="line">(SMBIOS / DMI) hdparm -i /dev/hda 罗列一个磁盘的架构特性</span><br><span class="line">hdparm -tT /dev/sda 在磁盘上执行测试性读取操作系统信息</span><br><span class="line"><span class="built_in">arch</span> 显示机器的处理器架构</span><br><span class="line"><span class="built_in">uname</span> -m 显示机器的处理器架构</span><br><span class="line"><span class="built_in">uname</span> -r 显示正在使用的内核版本</span><br><span class="line">dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)</span><br><span class="line">hdparm -i /dev/hda 罗列一个磁盘的架构特性</span><br><span class="line">hdparm -tT /dev/sda 在磁盘上执行测试性读取操作</span><br><span class="line"><span class="built_in">cat</span> /proc/cpuinfo 显示CPU info的信息</span><br><span class="line"><span class="built_in">cat</span> /proc/interrupts 显示中断</span><br><span class="line"><span class="built_in">cat</span> /proc/meminfo 校验内存使用</span><br><span class="line"><span class="built_in">cat</span> /proc/swaps 显示哪些swap被使用</span><br><span class="line"><span class="built_in">cat</span> /proc/version 显示内核的版本</span><br><span class="line"><span class="built_in">cat</span> /proc/net/dev 显示网络适配器及统计</span><br><span class="line"><span class="built_in">cat</span> /proc/mounts 显示已加载的文件系统</span><br><span class="line">lspci -tv 罗列 PCI 设备</span><br><span class="line">lsusb -tv 显示 USB 设备</span><br><span class="line"><span class="built_in">date</span> 显示系统日期</span><br><span class="line">cal 2007 显示2007年的日历表</span><br><span class="line"><span class="built_in">date</span> 041217002007.00 设置日期和时间 - 月日时分年.秒</span><br><span class="line">clock -w 将时间修改保存到 BIOS</span><br></pre></td></tr></table></figure><p>未完待续……</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="前端" scheme="https://www.hoveco.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="linux" scheme="https://www.hoveco.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>前端公共资源库CDN</title>
    <link href="https://www.hoveco.top/2024/08/18/%E5%85%AC%E5%85%B1%E8%B5%84%E6%BA%90CDN/"/>
    <id>https://www.hoveco.top/2024/08/18/%E5%85%AC%E5%85%B1%E8%B5%84%E6%BA%90CDN/</id>
    <published>2024-08-18T07:20:27.000Z</published>
    <updated>2024-09-05T04:04:58.306Z</updated>
    
    <content type="html"><![CDATA[<p>　　近日，登录网站时候看到网站部分图标加载不出来，以为是最近修改了网页代码导致的问题，查看问题后。原来是网站引用的一个公共静态库访问异常导致的问题，具体地址是：<a href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.5.2/css/all.min.css">https://cdn.bootcdn.net/ajax/libs/font-awesome/6.5.2/css/all.min.css</a><br>　　这样之后，就打算换一个相关的静态公共库，查询许久后。换成了七牛云的免费静态库，地址是：<a href="https://cdn.staticfile.net/font-awesome/6.5.1/css/all.min.css">https://cdn.staticfile.net/font-awesome/6.5.1/css/all.min.css</a><br>　　就这样解决了燃眉之急。经过这件事情之后，也顺带了解了一下目前常用的一些公共资源库。整理如下：</p><p><a href="http://cdn.bytedance.com/">字节跳动静态资源公共库</a> </p><p><a href="http://staticfile.org/">七牛免费CDN前端公开库</a></p><p><a href="https://unpkg.com/">unpkg</a></p><p><a href="https://www.jsdelivr.com/">jsdelivr</a></p><p><a href="https://www.bootcdn.cn/">BootCDN加速服务</a></p><p><a href="http://jscdn.upai.com/">又拍云JavaScript库CDN服务</a></p><p><a href="http://lib.sinaapp.com/">新浪云计算公共库</a> （很久没更新）</p><p><a href="https://jshub.com/">JSHub</a></p><p><a href="https://docs.microsoft.com/zh-cn/aspnet/ajax/cdn/overview">微软</a></p><p>另外还有一些其他推荐的CDN，比如Cloudflare 等等的，就不推荐罗列了，有兴趣的可以直接研究看看。</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="前端" scheme="https://www.hoveco.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="个人" scheme="https://www.hoveco.top/tags/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>GIt</title>
    <link href="https://www.hoveco.top/2024/06/27/git/"/>
    <id>https://www.hoveco.top/2024/06/27/git/</id>
    <published>2024-06-27T02:20:27.000Z</published>
    <updated>2024-06-27T22:31:23.022Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GIT博客常用命令"><a href="#GIT博客常用命令" class="headerlink" title="GIT博客常用命令"></a>GIT博客常用命令</h3><h4 id="配置用户名、密码、邮箱"><a href="#配置用户名、密码、邮箱" class="headerlink" title="配置用户名、密码、邮箱"></a>配置用户名、密码、邮箱</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.查看git配置信息</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --list</span></span><br><span class="line"> </span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.查看git用户名、密码、邮箱的配置</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config user.name</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config user.password</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config user.email</span></span><br><span class="line"> </span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.设置git用户名、密码、邮箱的配置</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config user.name <span class="string">&quot;hoveco&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config user.password <span class="string">&quot;123456&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config user.email <span class="string">&quot;123456789@qq.com&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.设置git用户名、密码、邮箱的配置（全局配置）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name 用户名</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name hoveco</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.password 密码</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.password 11223344</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.password 邮箱</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.email <span class="string">&quot;123456789@qq.com&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.修改git用户名、密码、邮箱的配置（跟设置语法一样，没有用户名就添加，有了用户名就修改）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config user.name <span class="string">&quot;hoveco&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.修改git用户名、密码、邮箱的配置（全局配置）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;hoveco&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5.删除git用户名、密码、邮箱的配置</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除用户、邮箱信息</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --<span class="built_in">unset</span> user.name</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --<span class="built_in">unset</span> user.email</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除用户、邮箱信息（全局配置）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global --<span class="built_in">unset</span> user.name</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global --<span class="built_in">unset</span> user.email</span></span><br></pre></td></tr></table></figure><h4 id="git配置ssh生成密钥对"><a href="#git配置ssh生成密钥对" class="headerlink" title="git配置ssh生成密钥对"></a>git配置ssh生成密钥对</h4><h5 id="SSH密匙是什么？"><a href="#SSH密匙是什么？" class="headerlink" title="SSH密匙是什么？"></a>SSH密匙是什么？</h5><p>　　SSH (Secure Shell) 密钥是用于身份验证和加密通信的一对加密密钥。它由两个部分组成：<strong>私钥（private key）和公钥（public key）</strong>。这对密钥是通过非对称加密算法生成的，其中<strong>私钥用于加密数据，而公钥用于解密数据</strong>。</p><div class="note orange no-icon flat"><p><strong>配置方法</strong></p></div><h5 id="打开git命令行"><a href="#打开git命令行" class="headerlink" title="打开git命令行"></a>打开git命令行</h5><p>新建一个文件夹作为代码仓库。在文件夹里面右键，点击 git bash here</p><h5 id="生成SSH-Key"><a href="#生成SSH-Key" class="headerlink" title="生成SSH Key"></a>生成SSH Key</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">你的Github绑定的邮箱</span></span><br><span class="line">ssh-keygen -t rsa -C &quot;***@gmail.com&quot;</span><br></pre></td></tr></table></figure><p>　　<strong>PS:</strong>  -C后面是个注释信息，并不一定要和你Git账户的邮箱或者Git账户名保持一致，只是常常是<br>和你账户邮箱保持一致，这样设置，就能知道这个公钥被绑定在哪个Git账户上了</p><p>　　按3次“回车”后，生成<code>ssh-rsa</code>的字符串（包括<code>ssh-rsa</code>)</p><h5 id="查看密匙文件"><a href="#查看密匙文件" class="headerlink" title="查看密匙文件"></a>查看密匙文件</h5><p>在下图位置找到相对应的文件，并用记事本打开文件<strong>id_rsa.pub</strong>（地址位置：C:\Users\你的账户名字\ .ssh）</p><p><img src="https://s2.loli.net/2024/06/27/DHldXKqZpc6mJWj.png" alt="image-20240627102036246"></p><h5 id="github里面添加SSH-Key"><a href="#github里面添加SSH-Key" class="headerlink" title="github里面添加SSH Key"></a>github里面添加SSH Key</h5><p>　　位置：github头像—-Settings—-SSH and GPG Keys</p><p>　　新增一个密匙，名称随便写，值选择上面<strong>id_rsa.pub</strong>里面的内容</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="git" scheme="https://www.hoveco.top/categories/git/"/>
    
    
    <category term="git" scheme="https://www.hoveco.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>实用软件下载</title>
    <link href="https://www.hoveco.top/2024/05/30/ruanjianxiazai/"/>
    <id>https://www.hoveco.top/2024/05/30/ruanjianxiazai/</id>
    <published>2024-05-30T02:20:27.000Z</published>
    <updated>2024-05-30T11:56:17.234Z</updated>
    
    <content type="html"><![CDATA[<p><strong>常见的电脑软件推荐</strong></p><p>　　之前写过一篇电脑软件推荐的推文，之后看了几眼，不满意，不满意的点在于写了很多软件的介绍，过于繁琐，也不方便下载，现在重新写了一篇。</p><p>　　这篇文章思路是：</p><p>​    １、功能＋软件＋链接下载。这个软件是什么，能做什么，在哪里下载，多说无益。</p><p>​    ２、软件类别分类可能不是很清晰明细，有改动意见的可以在下面留言。</p><p>​    ３、展示软件均为网络所得，非盈利，有不合适的留言删除。</p><p>​    ４、如果没有你需求的软件，也可以留言，待到之后更新写上。</p><div class="note blue no-icon flat"><h3 id="微信多开"><a href="#微信多开" class="headerlink" title="微信多开"></a>微信多开</h3></div><p><strong>简单版</strong>  链接：<a href="https://wwm.lanzoul.com/iudds203v5wj">https://wwm.lanzoul.com/iudds203v5wj</a>    密码：cnuo</p><p><strong>配置版</strong>  链接：<a href="https://wwmy.lanzouq.com/iKtq71coivli">https://wwmy.lanzouq.com/iKtq71coivli</a>    密码：coco</p><p><strong>bat版</strong>    方法：自建一个txt文件，里面这样写（路径根据自己微信位置自己修改），需要多开几个写几个，最后改拓展名  txt为bat  即可</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">start</span> &quot;&quot; &quot;D:\app\WeChat\WeChat.exe&quot;</span><br><span class="line"></span><br><span class="line"><span class="built_in">start</span> &quot;&quot; &quot;D:\app\WeChat\WeChat.exe&quot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><div class="note blue no-icon flat"><h3 id="office安装和激活"><a href="#office安装和激活" class="headerlink" title="office安装和激活"></a>office安装和激活</h3></div><p><strong>安装</strong>　链接：<a href="https://wwm.lanzoul.com/i3QdM1uotnxg">https://wwm.lanzoul.com/i3QdM1uotnxg</a>     </p><p>　　　官网：<a href="https://otp.landian.vip/zh-cn/download.html">Office Tool Plus 官方网站 </a>　</p><p><strong>激活</strong>　链接：<a href="https://wwm.lanzoul.com/imrVH1uqb9ve">https://wwm.lanzoul.com/imrVH1uqb9ve</a>　　</p><div class="note blue no-icon flat"><h3 id="图片本地压缩"><a href="#图片本地压缩" class="headerlink" title="图片本地压缩"></a>图片本地压缩</h3></div><p><strong>Imagine</strong>　链接：<a href="https://wwm.lanzoul.com/ijR1B1vaqdli">https://wwm.lanzoul.com/ijR1B1vaqdli</a>    密码:65w2</p><p><strong>VIKY</strong>　链接：<a href="https://wwm.lanzoul.com/iqKxv1uosejc">https://wwm.lanzoul.com/iqKxv1uosejc</a></p><div class="note blue no-icon flat"><h3 id="win-下载工具"><a href="#win-下载工具" class="headerlink" title="win 下载工具"></a>win 下载工具</h3></div><p><strong>NDM</strong>　链接：<a href="https://wwm.lanzoul.com/ieMIe1uoyood">https://wwm.lanzoul.com/ieMIe1uoyood</a></p><p><strong>IDM</strong>　　链接：<a href="https://wwm.lanzoul.com/iZqmf1uos8xa">https://wwm.lanzoul.com/iZqmf1uos8xa</a>    密码:h2rs</p><p><strong>迅雷</strong>　　链接：<a href="https://wwm.lanzoul.com/idk1C1uou3va">https://wwm.lanzoul.com/idk1C1uou3va</a>    密码:8wjn</p><div class="note blue no-icon flat"><h3 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h3></div><p><strong>搜狗精简优化版</strong>　链接：<a href="https://wwm.lanzoul.com/iVkAc1uoyokj">https://wwm.lanzoul.com/iVkAc1uoyokj</a>    密码:1dj7</p><div class="note blue no-icon flat"><h3 id="完全卸载工具"><a href="#完全卸载工具" class="headerlink" title="完全卸载工具"></a>完全卸载工具</h3></div><p><strong>geek</strong>　链接：<a href="https://wwm.lanzoul.com/i4tt01uowj9g">https://wwm.lanzoul.com/i4tt01uowj9g</a>    密码:7tcy</p><p>　　　 官网：<a href="https://geekuninstaller.com/">Geek Uninstaller - the best FREE uninstaller</a></p><div class="note blue no-icon flat"><h3 id="解压软件"><a href="#解压软件" class="headerlink" title="解压软件"></a>解压软件</h3></div><p><strong>Bandzip（6.25）</strong>　链接：<a href="https://wwm.lanzoul.com/iSWxM201bhyb">https://wwm.lanzoul.com/iSWxM201bhyb</a>    密码:1bin</p><p><strong>7Z</strong>　链接：<a href="https://www.7-zip.org/">7-Zip</a></p><div class="note blue no-icon flat"><h3 id="播放器"><a href="#播放器" class="headerlink" title="播放器"></a>播放器</h3></div><p><strong>PotPlayer</strong>　链接：<a href="https://wwm.lanzoul.com/iBMXM1ur6v1c">https://wwm.lanzoul.com/iBMXM1ur6v1c</a>    密码:6cuf</p><p>　　　　　   官网：<a href="https://potplayer.tv/">Global Potplayer</a></p><p><strong>VLC播放器</strong>　链接：<a href="https://wwm.lanzoul.com/iTpIj1ur73cb">https://wwm.lanzoul.com/iTpIj1ur73cb</a>    密码:hq7h</p><p>　　　　　　官网：<a href="https://www.videolan.org/">VLC：官方网站</a></p><p><strong>安卓手机播放器</strong>　链接：<a href="https://wwm.lanzoul.com/ifZLQ2041ffi">https://wwm.lanzoul.com/ifZLQ2041ffi</a></p><div class="note blue no-icon flat"><h3 id="光盘刻录"><a href="#光盘刻录" class="headerlink" title="光盘刻录"></a>光盘刻录</h3></div><p><strong>链接</strong>：<a href="https://wwm.lanzoul.com/iNHWP1uosipc">https://wwm.lanzoul.com/iNHWP1uosipc</a></p><div class="note blue no-icon flat"><h3 id="FTP服务器"><a href="#FTP服务器" class="headerlink" title="FTP服务器"></a>FTP服务器</h3></div><p><strong>xlight</strong>　链接：<a href="https://wwm.lanzoul.com/ijFwb1zwyief">https://wwm.lanzoul.com/ijFwb1zwyief</a></p><div class="note blue no-icon flat"><h3 id="数据库管理软件"><a href="#数据库管理软件" class="headerlink" title="数据库管理软件"></a>数据库管理软件</h3></div><p><strong>Navicat</strong>    链接：<a href="https://wwm.lanzoul.com/iLg4V1uotqwd">https://wwm.lanzoul.com/iLg4V1uotqwd</a></p><p><strong>mdb数据库文件查看</strong>    链接：<a href="https://wwm.lanzoul.com/iXg1c1uots8b">https://wwm.lanzoul.com/iXg1c1uots8b</a></p><p><strong>sqllite数据库</strong>    链接 ：<a href="https://wwm.lanzoul.com/iBa6u1uotiyh">https://wwm.lanzoul.com/iBa6u1uotiyh</a></p><div class="note blue no-icon flat"><h3 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h3></div><p><strong>Typora</strong>　链接：<a href="https://wwm.lanzoul.com/ipMeW1uotitc">https://wwm.lanzoul.com/ipMeW1uotitc</a>    密码:1fie</p><div class="note blue no-icon flat"><h3 id="语音合成"><a href="#语音合成" class="headerlink" title="语音合成"></a>语音合成</h3></div><p><strong>一点红</strong>    链接：<a href="https://wwm.lanzoul.com/i836z1vkuved">https://wwm.lanzoul.com/i836z1vkuved</a></p><div class="note blue no-icon flat"><h3 id="实用小工具"><a href="#实用小工具" class="headerlink" title="实用小工具"></a>实用小工具</h3></div><p><strong>PDF批量转换文字</strong>：<a href="https://wwm.lanzoul.com/iRdlb1uotkza">https://wwm.lanzoul.com/iRdlb1uotkza</a></p><p><strong>窗口置顶</strong>：<a href="https://wwm.lanzoul.com/ijjN61w10y7g">https://wwm.lanzoul.com/ijjN61w10y7g</a></p><p><strong>报纸下载器pdf格式</strong>：<a href="https://wwm.lanzoul.com/iIsm61vkv51a">https://wwm.lanzoul.com/iIsm61vkv51a</a></p><p><strong>印章制作</strong>：<a href="https://wwm.lanzoul.com/i0yO41vk0b8h">https://wwm.lanzoul.com/i0yO41vk0b8h</a></p><p><strong>语音转文本</strong>：<a href="https://wwm.lanzoul.com/iOYY91usk1of">https://wwm.lanzoul.com/iOYY91usk1of</a>    密码:4zr9</p><p><strong>卸载系统软件</strong>：<a href="https://wwm.lanzoul.com/iIeJ11usf5af">https://wwm.lanzoul.com/iIeJ11usf5af</a></p><p><strong>桌面倒计时</strong>：<a href="https://wwm.lanzoul.com/iCuSD1usdv4d">https://wwm.lanzoul.com/iCuSD1usdv4d</a></p><p><strong>截图</strong>：<a href="https://wwm.lanzoul.com/iujNK1usaioh">https://wwm.lanzoul.com/iujNK1usaioh</a></p><p><strong>电脑操作记录查看器</strong>：<a href="https://wwm.lanzoul.com/ihmMd1urr1if">https://wwm.lanzoul.com/ihmMd1urr1if</a>    密码:e1n8</p><p><strong>热搜榜更新</strong>：<a href="https://wwm.lanzoul.com/irnDf1uou3yd">https://wwm.lanzoul.com/irnDf1uou3yd</a></p><p><strong>文件批量命名</strong>：<a href="https://wwm.lanzoul.com/i0wbn1zkenmb">https://wwm.lanzoul.com/i0wbn1zkenmb</a></p><p><strong>文件时间修改</strong>：<a href="https://wwm.lanzoul.com/iLQtq1uosf6f">https://wwm.lanzoul.com/iLQtq1uosf6f</a></p><p><strong>文件检索（Everything）</strong>：<a href="https://wwm.lanzoul.com/ig9T51uottyd">https://wwm.lanzoul.com/ig9T51uottyd</a></p><p><strong>硬盘恢复（R-Studio）</strong>：<a href="https://wwm.lanzoul.com/i36G21uotjmb">https://wwm.lanzoul.com/i36G21uotjmb</a></p><p><strong>硬盘分区占用查看（windirstat）</strong>：<a href="https://wwm.lanzoul.com/i51ZY1uosiqd">https://wwm.lanzoul.com/i51ZY1uosiqd</a></p><p><strong>照片批量处理（格式转化，修改）</strong>：<a href="https://wwm.lanzoul.com/ikzKB1zvawqb">https://wwm.lanzoul.com/ikzKB1zvawqb</a></p><p><strong>微信视频号下载</strong>：<a href="https://wwm.lanzoul.com/iBWgL1uoskxc">https://wwm.lanzoul.com/iBWgL1uoskxc</a>    密码:f8p6</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="软件" scheme="https://www.hoveco.top/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="软件下载" scheme="https://www.hoveco.top/tags/%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>电脑实用软件推荐</title>
    <link href="https://www.hoveco.top/2024/04/09/ruanjian/"/>
    <id>https://www.hoveco.top/2024/04/09/ruanjian/</id>
    <published>2024-04-09T02:20:27.000Z</published>
    <updated>2024-04-19T11:06:38.614Z</updated>
    
    <content type="html"><![CDATA[<p><strong>常见的电脑软件推荐</strong></p><div class="note orange no-icon flat"><h3 id="油猴脚本"><a href="#油猴脚本" class="headerlink" title="油猴脚本"></a>油猴脚本</h3></div><ol><li><h4 id="篡改猴插件（又称：油猴）"><a href="#篡改猴插件（又称：油猴）" class="headerlink" title="篡改猴插件（又称：油猴）"></a><strong>篡改猴插件（又称：油猴）</strong></h4><p><strong>篡改猴 (Tampermonkey)</strong> 是拥有 <strong>超过 1000 万用户</strong> 的最流行的浏览器扩展之一。 它适用于 <a href="https://www.tampermonkey.net/index.php?browser=chrome&locale=zh_CN"><strong>Chrome</strong></a>、<a href="https://www.tampermonkey.net/index.php?browser=edge&locale=zh_CN"><strong>Microsoft Edge</strong></a>、<a href="https://www.tampermonkey.net/index.php?browser=safari&locale=zh_CN"><strong>Safari</strong></a>、<a href="https://www.tampermonkey.net/index.php?browser=opera&locale=zh_CN"><strong>Opera Next</strong></a> 和 <a href="https://www.tampermonkey.net/index.php?browser=firefox&locale=zh_CN"><strong>Firefox</strong></a>。</p><p>有些人也会把篡改猴(Tampermonkey)称作油猴(Greasemonkey)，尽管后者只是一款仅适用于 Firefox 浏览器的浏览器扩展程序。</p><p>它允许用户自定义并<strong>增强您最喜爱的网页的功能</strong>。用户脚本是小型 JavaScript 程序，可用于向网页添加新功能或修改现有功能。使用 篡改猴，您可以轻松在任何网站上创建、管理和运行这些用户脚本。</p><p>例如，使用 篡改猴，您可以向网页添加一个新按钮，可以快速在社交媒体上分享链接，或自动填写带有个人信息的表格。在数字化时代，这特别有用，因为网页常常被用作访问广泛的服务和应用程序的用户界面。</p><p>此外，篡改猴 <strong>使您轻松找到并安装其他用户创建的用户脚本</strong>。这意味着您可以快速轻松地访问为您喜爱的网页定制的广泛库，而无需花费数小时编写自己的代码。</p><p>无论您是希望为您的站点添加新功能的 <strong>Web 开发人员</strong>，还是只是希望 <strong>改善在线体验的普通用户</strong>，篡改猴 都是您的工具箱中的一个很好的工具。</p></li><li><h4 id="浏览器加载程序安装步骤"><a href="#浏览器加载程序安装步骤" class="headerlink" title="浏览器加载程序安装步骤"></a><strong>浏览器加载程序安装步骤</strong></h4><p>油猴的安装步骤其实相当简单，在各大浏览器的应用商店搜索 “篡改猴”。这里以Edge浏览器为例，点击安装后就可以进行安装操作（设置–拓展–打开 Microsoft Edge 加载项）</p><p><img src="https://s2.loli.net/2023/10/09/Gn6x98iNdtPhbuz.png" alt="image-20231009135547926"></p></li><li><h4 id="插件脚本导入"><a href="#插件脚本导入" class="headerlink" title="插件脚本导入"></a><strong>插件脚本导入</strong></h4><p>刚才安装的只是浏览器的脚本程序，需要程序的运行，还需要导入相应的脚本代码，我们可以到指定的脚本网站上下载已经写好的脚本导入。常见的脚本网站有greasyfork，地址是：<a href="https://greasyfork.org/zh-CN/">Greasy Fork - 安全、实用的用户脚本大全</a></p><p><img src="https://s2.loli.net/2023/10/09/mtxf6YKHbcLh9TZ.png" alt="image-20231009140641411"></p><p>可以根据自己的需求查找并安装下载相关的脚本代码（常见的脚本有全网视频解析脚本、各大音乐网站付费音乐下载脚本、网盘直链接下载脚本）等等</p><p><img src="https://s2.loli.net/2023/10/09/RubcE7ean1WC2vk.png" alt="image-20231009141053914"></p><p>也可以在油猴管理界面对已经下载的脚本进行管理操作（脚本程序的添加和删除，开启和关闭）</p><p><img src="https://s2.loli.net/2023/10/09/PyYhQnVeUsGxu3Z.png" alt="image-20231009141805151"></p></li></ol><div class="note orange no-icon flat"><h3 id="本地视频播放器：PotPlayer"><a href="#本地视频播放器：PotPlayer" class="headerlink" title="本地视频播放器：PotPlayer"></a>本地视频播放器：PotPlayer</h3></div><ol><li><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h4><p>PotPlayer是KMPlayer原作者姜勇囍进入新公司Daum之后推出的，继承了 KMPlayer 所有的优点，拥有异常强大的内置音视频解码器，可以支持几乎全部音乐、视频文件格式的播放。采用 VC++ 进行了全面重构，并且原生支持64位操作系统，使得 PotPlayer 在 Windows 10 等新系统上，无论性能、兼容性和稳定性上的表现均比 KMP 要好不少；硬件加速、流畅优秀的全高清视频播放效果、强大的选项、滤镜、外挂式管理、DXVA等硬件解码；以及非常丰富且强大的设置选项，被誉为Win平台上最优秀的免费影音全能格式播放器。</p><p><img src="https://s2.loli.net/2023/10/09/HJpzhFd271vXTU4.jpg"></p></li><li><h4 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a><strong>下载地址</strong></h4><p>网络上的盗版地址有很多，都不是真正的官网，真正的下载地址是这个：<a href="http://potplayer.tv/?lang=zh_CN">Global Potplayer</a></p></li><li><h4 id="推荐理由"><a href="#推荐理由" class="headerlink" title="推荐理由"></a><strong>推荐理由</strong></h4><p>之所以推荐这个播放器呢，还是因为它强大的视频、音频解码能力，也可以播放网络上的一些流媒体，甚至直播流也是可以的，也可以对视频进行简单的截取，截图等等。更有甚者设置无边框小窗口模式后放置桌面右下角播放，妥妥的”摸鱼神器”</p></li></ol><div class="note orange no-icon flat"><h3 id="解压工具：7-zip-和-Bandzip"><a href="#解压工具：7-zip-和-Bandzip" class="headerlink" title="解压工具：7-zip 和 Bandzip"></a>解压工具：7-zip 和 Bandzip</h3></div><p><img src="https://7-zip.org/7ziplogo.png" style="zoom:150%;" />   <img src="http://www.bandisoft.com/bandizip/screenshots/imgs.cn/01.png" style="zoom:50%;" /></p><ol><li><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a><strong>介绍</strong></h4><p>如果说你想找一个轻量化的解压缩工具，那么7z绝对是你的首要之选，它的安装包虽小，大小仅有1MB，但是可以轻松解压常见的压缩格式（7z、XZ、BZIP2、GZIP、TAR、ZIP 以及 WIM）。而且是开源免费的，绝对比世面上的什么360压缩，2345好压靠谱多了，也没有什么广告，弹窗什么的，值得推荐</p><p>另外还有一款就是bandzip，为第二推荐的，至于为什么推荐这个呢？就是因为7z太精简了，以至于窗口界面都比较简单，也不美观。要解压一个文件还需要右键浏览好几步骤才可以，所以推荐这个，另外需要注意的是，下载时候请下载7.0之前的版本，因为7.0版本软件内部有广告植入，当然购买激活后就没有了。有能力的可以购买或者自己找相关的破解版或者注册机</p></li><li><h4 id="下载地址-1"><a href="#下载地址-1" class="headerlink" title="下载地址"></a><strong>下载地址</strong></h4><p>7-zip：<a href="https://7-zip.org/">7-Zip</a></p><p>Bandzip：<a href="https://www.bandisoft.com/bandizip/">Windows 版本的 Bandizip</a></p></li></ol><div class="note orange no-icon flat"><h3 id="文件搜索工具：Everything"><a href="#文件搜索工具：Everything" class="headerlink" title="文件搜索工具：Everything"></a>文件搜索工具：Everything</h3></div><img src="https://www.voidtools.com/zh-cn/support/everything/Everything.Search.Window.png" style="zoom:80%;" /><ol><li><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a><strong>介绍</strong></h4><p>当你有一天想要在电脑上快速查找某个文件，但是有苦于win电脑缓慢的搜索速度，那么它绝对是那你的首要选择。</p><p>“Everything” 是 Windows 上一款搜索引擎，它能够基于文件名快速定文件和文件夹位置。</p><p>也可以通过搜索函数 content: 来搜索文件内容。</p><p>免费、轻量、不包含任何恶意、间谍软件或广告。</p><p>不像 Windows 内置搜索，”Everything” 默认显示电脑上每个文件和文件夹 (就如其名 “Everything”)。</p><p>您在搜索框输入的关键词将会筛选显示的文件和文件夹。</p><p>“Everything” 仅索引文件和文件夹名，一般仅需几秒便可建立其数据库。</p><p>全新安装的 Windows 10 (大约 120,000 个文件) 仅需 1 秒即可索引完成。</p><p>索引 1,000,000 个文件将需要大约 1 分钟。</p></li><li><h4 id="下载地址-2"><a href="#下载地址-2" class="headerlink" title="下载地址"></a><strong>下载地址</strong></h4><p>Everything：<a href="https://www.voidtools.com/zh-cn/downloads/">下载 - Everything</a></p></li></ol><div class="note orange no-icon flat"><h3 id="下载工具：Internet-Download-Manager-（简称：IDM）"><a href="#下载工具：Internet-Download-Manager-（简称：IDM）" class="headerlink" title="下载工具：Internet Download Manager （简称：IDM）"></a>下载工具：Internet Download Manager （简称：IDM）</h3></div><img src="https://www.internetdownloadmanager.com/images/idm_screenshot_6_35.png" style="zoom: 67%;" /><ol><li><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a><strong>介绍</strong></h4><p>这个软件可以让你的下载速度提升很多，也可以在线抓包网页上的文件（视频、音频等等）</p><p>IDM全称Internet Download Manager，是一款Windows平台的老牌而功能强大的下载加速器。它专注于互联网数据下载，通过多线程技术实现高速下载。除此之外，IDM还支持多媒体下载、自动捕获链接、自动识别文件名、静默下载、批量下载、计划下载任务、站点抓取等功能。</p><p>IDM支持HTTP、FTP、HTTPS和MMs协议，但不支持P2P下载软件，无法用于下载通过bt和eMule发布的内容。它还支持下载队列、防火墙和映射服务器、重新导向、cookies、需要验证的目录，以及各种不同的服务器平台。</p><p>IDM的下载速度通常能提高多达5倍，远超过其他下载工具。用户可以通过idm下载器进行下载任务的添加与管理，同时也能进行下载参数的设置，包括同时进行的最大连接数等。</p><p>总的来说，IDM以其强大的功能和高速的下载效率，成为了许多用户首选的下载工具。</p></li><li><h4 id="下载地址-3"><a href="#下载地址-3" class="headerlink" title="下载地址"></a><strong>下载地址</strong></h4><p>IDM：<a href="https://www.internetdownloadmanager.com/">互联网下载管理器：最快的下载加速器</a></p></li></ol><div class="note orange no-icon flat"><h3 id="完全卸载软件：geek"><a href="#完全卸载软件：geek" class="headerlink" title="完全卸载软件：geek"></a>完全卸载软件：geek</h3></div><ol><li><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a><strong>介绍</strong></h4><img src="https://geekuninstaller.com/assets/images/boxshot.png" style="zoom: 70%;" /><img src="https://geekuninstaller.com/assets/images/screen_1.png" style="zoom:70%;" /><p>这是一个非常好用的电脑软件卸载程序，我们在平时使用电脑的过程中，总会有软件安装和被卸载，处理不好软件的卸载的话，有可能会占用过多硬盘空间。更有甚者这些残留的文件也会影响下一次软件的正常安装。所以这个软件的作用就体现出来了，用它卸载软件，可以清除软件安装目录以及多余的注册表信息。</p></li><li><h4 id="下载地址-4"><a href="#下载地址-4" class="headerlink" title="下载地址"></a><strong>下载地址</strong></h4></li></ol><p>geek：<a href="https://geekuninstaller.com/download">https://geekuninstaller.com/download</a></p><div class="note orange no-icon flat"><h3 id="正版office部署工具：Office-Tool-Plus"><a href="#正版office部署工具：Office-Tool-Plus" class="headerlink" title="正版office部署工具：Office Tool Plus"></a>正版office部署工具：Office Tool Plus</h3></div><ol><li><h4 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a><strong>介绍</strong></h4><img src="https://otp.landian.vip/static/images/logo.webp" style="zoom:80%;" /><p>Office Tool Plus 是一个强大且实用的 Office 部署工具。</p><p>Office Tool Plus 基于 Office 部署工具制作，可以很方便的部署 Office，其内置迅雷云加速开放平台和 Downloader 引擎可帮助您更快地下载 Office。你也可以使用 Office Tool Plus 的其他功能、小工具快捷、方便地激活和管理 Office 哦！</p><p>支持下列产品：</p><p>Microsoft 365<br>Office 2016, 2019, 2021, 2024<br>Visio 2016, 2019, 2021, 2024 &amp; Visio Online Plan 2<br>Project 2016, 2019, 2021, 2024 &amp; Project Online Desktop Client</p></li><li><h4 id="下载地址-5"><a href="#下载地址-5" class="headerlink" title="下载地址"></a><strong>下载地址</strong></h4></li></ol><p>Office Tool Plus 下载地址：<a href="https://otp.landian.vip/zh-cn/download.html">下载 | Office Tool Plus 官方网站 (landian.vip)</a></p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="软件" scheme="https://www.hoveco.top/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="实用软件" scheme="https://www.hoveco.top/tags/%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>PotPlayer使用指南</title>
    <link href="https://www.hoveco.top/2024/01/20/PotPlayer/"/>
    <id>https://www.hoveco.top/2024/01/20/PotPlayer/</id>
    <published>2024-01-20T10:30:00.000Z</published>
    <updated>2024-01-20T10:25:08.795Z</updated>
    
    <content type="html"><![CDATA[<p> PotPlayer使用指南</p><p>首先，PotPlayer界面<strong>非常地简洁，软件体积小，占用内存极低</strong>，拥有异常强大的内置音视频解码器，<strong>可以支持几乎全部音乐、视频文件格式的播放</strong>。而且软件本身没有任何广告和流氓插件。但是很多人把他当做普通的播放器来使用，完全没有发挥出它的作用。</p><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a><strong>下载地址</strong></h3><p>链接：<a href="https://potplayer.tv/?lang=zh_CN">Global Potplayer</a></p><p>也许是由于它的功能强大，使得自己被很多软件进行恶意修改，增加广告之后又放到各大浏览器上面，更有甚者还要“付费”才能解锁使用，简直不忍直视。</p><p><img src="https://s2.loli.net/2024/01/19/2eqcUbtwxGT71VN.png" alt="image-20240119105008891"></p><p>正如官方说明的，我们使用它，而不是将它们作为赚钱的工具。所以说，如果你在网上下载到了付费或者有广告的的版本，请立即卸载了吧，</p><p>那么接下来我们就简单介绍下它的功能吧</p><p><strong>1.无边框和美化</strong></p><img src="https://s2.loli.net/2024/01/20/WIS8gAQZ3dF1Nyl.png" alt="image-20240120180140713" style="zoom:67%;" /><p>就可以无边框播放本地视频，缩放最小化播放后，你根本分辨出来了右下角的究竟是“广告弹窗”还是“电影”，也可以下载一些网上的第三方皮肤来自定义DIY你的播放器</p><p><strong>2.直播功能</strong></p><p>如果你以为它只是一播放器的话，就大错特错了，它还可以播放卫星直播</p><p>特别是搭配网上的流媒体直播源后，就可以看实时直播了</p><p><strong>3.补帧功能</strong></p><p>可以在：选项–视频–图像处理中，启用倍帧功能，增加视频的播放流畅度</p><p><strong>4.视频录屏裁剪</strong></p><p>它同样是一个可以裁剪录屏视频的一个方便工具，可以对喜欢的视频进行简单的剪辑操作</p><p><strong>5.在线字幕实时翻译</strong></p><p>它还可以调用必应翻译和谷歌翻译接口，实时翻译所看的视频</p><p><strong>6.超分辨率功能</strong></p><p>视频超分辨率是将低分辨率低码率的视频画质增强，体验感拉满</p><p><strong>7.在线字幕下载</strong></p><p>通过集成的字幕搜索功能，不用手动到字幕网站找字幕了</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="软件" scheme="https://www.hoveco.top/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="软件" scheme="https://www.hoveco.top/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>音乐CD制作</title>
    <link href="https://www.hoveco.top/2023/12/24/music_cd/"/>
    <id>https://www.hoveco.top/2023/12/24/music_cd/</id>
    <published>2023-12-24T00:30:00.000Z</published>
    <updated>2023-12-24T02:55:52.105Z</updated>
    
    <content type="html"><![CDATA[<p> 前段时间突然萌生出了一个制作音乐CD的想法，首先需要了解一点有关这方法的知识。正常我们生活中常见的光盘一共分为两种，一种是cd光盘，一种是DVD光盘。如果购买的CD机是纯CD机，那么DVD格式的光盘是不能播放的，cd的光盘大小一般为700M大小。可以用来保存小文件，音乐等。DVD格式的光盘一般的空间比较大，可以存放视频等文件。不管是CD还是DVD光盘，都有两种，即为可擦写的（例：CD-RW、DVD-RW）以及不可擦写的（CD-R、DVD-R）格式的。鉴于制作CD光盘就是一次制作的，可以用CD-R格式的，如果同一个光盘后续还有修改的需求，可以选CD-RW格式的。两种光盘价格不一样，依照个人需求选择，都可以使用。</p><p>光盘选择好后，就需要选择相关的刻录软件以及有刻录功能的光驱，刻录软件这边推荐的就是 Nero刻录软件</p><img src="https://s2.loli.net/2023/12/24/N4j7IicGudpmSPa.png" alt="image-20231224102854459" style="zoom:67%;" /><p>选择好软件和光盘后，就可以进行刻录了，打开nero软件，在里面选择音乐选项，选择音乐光盘</p><img src="https://s2.loli.net/2023/12/24/sb5KeWIjpVQGFqR.png" alt="image-20231224103238697" style="zoom: 80%;" /><p>然后添加我们想要刻录的音乐，这边要注意的。这种刻录格式是按照音轨进行刻录，所以选择的音乐总时长不能超过80分钟，超过的话，就会刻录不上的问题。</p><img src="https://s2.loli.net/2023/12/24/WI5MeCwQuYoNhDU.png" alt="image-20231224103703756" style="zoom: 80%;" /><p>在之后就按照提示下一步操作就可以刻录一张属于自己的音乐CD光盘。</p><p>这时候就有人会说，为什么别人的光盘上都几百首歌，我这个不行？</p><p>这个就是一个选择问题了，我们也可以选择那样的格式进行刻录，比如在上面选择刻录类型的时候选择Jukebox音频CD的格式，这样刻录可以放更多的音乐，大概一百多首吧。但是刻录完毕后不一定兼容你的CD机，就会出现CD机不识别的现象，感兴趣的朋友可以试一试，或者可以刻录DVD光盘，那样数量就更多了。但一定要根据自己手头的播放器选择相关的刻录格式光盘。</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="音乐" scheme="https://www.hoveco.top/categories/%E9%9F%B3%E4%B9%90/"/>
    
    
    <category term="音乐" scheme="https://www.hoveco.top/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>Butterfly常用标签</title>
    <link href="https://www.hoveco.top/2023/10/27/biaoqian/"/>
    <id>https://www.hoveco.top/2023/10/27/biaoqian/</id>
    <published>2023-10-27T00:30:00.000Z</published>
    <updated>2023-11-01T13:15:33.653Z</updated>
    
    <content type="html"><![CDATA[<p> 一篇优秀的博客，除了有精彩内容可以品鉴，一些简单精美的图标样式同样可以为我们的博客增色几分。</p><div class="note blue no-icon flat"><h3 id="引用-node"><a href="#引用-node" class="headerlink" title="引用 node"></a>引用 node</h3></div><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">通用设置</button><button type="button" class="tab">常见用法</button><button type="button" class="tab">自定义用法</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>修改 主题配置文件</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># Note tag style values:</span></span><br><span class="line">  <span class="comment">#  - simple    bs-callout old alert style. Default.</span></span><br><span class="line">  <span class="comment">#  - modern    bs-callout new (v2-v3) alert style.</span></span><br><span class="line">  <span class="comment">#  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span></span><br><span class="line">  <span class="comment">#  - disabled  disable all CSS styles import of note tag.</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">simple</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">border_radius:</span> <span class="number">3</span></span><br><span class="line">  <span class="comment"># Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line">  <span class="comment"># Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line">  <span class="attr">light_bg_offset:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>icons和light_bg_offset只对方法一生效</p><p>Note 标签外挂有两种用法</p></div><div class="tab-item-content"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>用法</th></tr></thead><tbody><tr><td>class</td><td>【可选】标识，不同的标识有不同的配色<br/>（ default / primary / success / info / warning / danger ）</td></tr><tr><td>no-icon</td><td>【可选】不显示 icon</td></tr><tr><td>style</td><td>【可选】可以覆盖配置中的 style<br/>（simple/modern/flat/disabled）</td></tr></tbody></table></div><div class="tab-item-content"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>用法</th></tr></thead><tbody><tr><td>color</td><td>【可选】颜色<br/>(default / blue / pink / red / purple / orange / green)</td></tr><tr><td>icon</td><td>【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td>【可选】可以覆盖配置中的 style<br/> （simple/modern/flat/disabled）</td></tr></tbody></table><p><strong>例：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;</span><br><span class="line">2021年快到了....</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;</span><br><span class="line">小心开车 安全至上</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;</span><br><span class="line">这是三片呢？还是四片？</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;</span><br><span class="line">你是刷 Visa 还是 UnionPay</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;</span><br><span class="line">剪刀石头布</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;</span><br><span class="line">前端最讨厌的浏览器</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;&#123;% endnote %&#125;</span><br><span class="line">&#123;% note blue no-icon %&#125;&#123;% endnote %&#125;</span><br><span class="line">&#123;% note pink no-icon %&#125;&#123;% endnote %&#125;</span><br><span class="line">&#123;% note red no-icon %&#125;&#123;% endnote %&#125;</span><br><span class="line">&#123;% note orange no-icon %&#125;&#123;% endnote %&#125;</span><br><span class="line">&#123;% note purple no-icon %&#125;&#123;% endnote %&#125;</span><br><span class="line">&#123;% note green no-icon %&#125;&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>例：</p><div class="note pink no-icon flat"><p>这是Hoveco的博客</p></div><div class="note purple no-icon flat"><p>这是Hoveco的博客</p></div><div class="note blue no-icon flat"><h3 id="时间轴-Timeline"><a href="#时间轴-Timeline" class="headerlink" title="时间轴 Timeline"></a>时间轴 Timeline</h3></div><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">MARKDOWN</span><br><span class="line">&#123;% timeline 2016,pink %&#125;</span><br><span class="line">&lt;!-- timeline 09-01 --&gt;</span><br><span class="line">步入大学生涯</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% timeline 2019,purple %&#125;</span><br><span class="line">&lt;!-- timeline 06-01 --&gt;</span><br><span class="line">进入社会</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% timeline 2023,green %&#125;</span><br><span class="line">&lt;!-- timeline 08-01 --&gt;</span><br><span class="line">博客搭建成功</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><div class="timeline pink"><div class='timeline-item headline'>        <div class='timeline-item-title'>          <div class='item-circle'><p>2016</p></div>        </div>      </div><div class='timeline-item'>        <div class='timeline-item-title'>          <div class='item-circle'><p>09-01</p></div>        </div>        <div class='timeline-item-content'><p>步入大学生涯</p></div>      </div></div><div class="timeline purple"><div class='timeline-item headline'>        <div class='timeline-item-title'>          <div class='item-circle'><p>2019</p></div>        </div>      </div><div class='timeline-item'>        <div class='timeline-item-title'>          <div class='item-circle'><p>06-01</p></div>        </div>        <div class='timeline-item-content'><p>进入社会</p></div>      </div></div><div class="timeline green"><div class='timeline-item headline'>        <div class='timeline-item-title'>          <div class='item-circle'><p>2023</p></div>        </div>      </div><div class='timeline-item'>        <div class='timeline-item-title'>          <div class='item-circle'><p>08-01</p></div>        </div>        <div class='timeline-item-content'><p>博客搭建成功</p></div>      </div></div><div class="note blue no-icon flat"><h3 id="文字隐藏-tag-hide"><a href="#文字隐藏-tag-hide" class="headerlink" title="文字隐藏 tag-hide"></a>文字隐藏 tag-hide</h3></div><p>如果你想把一些文字、内容隐藏起来，并提供按钮让用户点击显示。可以使用这个标签外挂。</p><p>( display 不能包含英文逗号，可用&sbquo;</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">Inline</button><button type="button" class="tab">Block</button><button type="button" class="tab">Toggle</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>Inline标签（行内标签）</strong></p><p>inline 在文本里面添加按钮隐藏内容，只限文字</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>content</td><td>文本内容</td></tr><tr><td>display</td><td>按钮显示的文字(可选)</td></tr><tr><td>bg</td><td>按钮的背景颜色(可选)</td></tr><tr><td>color</td><td>按钮文字的颜色(可选)</td></tr></tbody></table><p><strong>例：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">800壮士为什么只剩下300人了? &#123;% hideInline 因为伍佰去唱歌了,查看答案,#FF7242,#fff %&#125;</span><br><span class="line"></span><br><span class="line">冬瓜、黄瓜、西瓜、南瓜都能吃，什么瓜不能吃？ &#123;% hideInline 傻瓜 %&#125;</span><br></pre></td></tr></table></figure><p>800壮士为什么只剩下300人了? <span class="hide-inline"><button type="button" class="hide-button" style="background-color: #FF7242;color: #fff">查看答案</button><span class="hide-content">因为伍佰去唱歌了</span></span></p><p>冬瓜、黄瓜、西瓜、南瓜都能吃，什么瓜不能吃？ <span class="hide-inline"><button type="button" class="hide-button" style="">Click</button><span class="hide-content">傻瓜</span></span></p></div><div class="tab-item-content"><p><strong>Block标签（块标签）</strong></p><p>block独立的block隐藏内容，可以隐藏很多内容，包括图片，代码块等等</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>content</td><td>文本内容</td></tr><tr><td>display</td><td>按钮显示的文字(可选)</td></tr><tr><td>bg</td><td>按钮的背景颜色(可选)</td></tr><tr><td>color</td><td>按钮文字的颜色(可选)</td></tr></tbody></table><p><strong>例：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">今天你快乐吗？</span><br><span class="line">&#123;% hideBlock 查看答案 %&#125;</span><br><span class="line">反正我快乐</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><p>今天你快乐吗？</p><div class="hide-block"><button type="button" class="hide-button" style="">查看答案</button><div class="hide-content"><p>反正我快乐</p></div></div></div><div class="tab-item-content"><p><strong>Toggle标签 （折叠隐藏标签）</strong> </p><p>如果你需要展示的内容太多，可以把它隐藏在收缩框里，需要时再把它展开。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideToggle display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideToggle %&#125;</span><br></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideToggle 标题文字 %&#125;</span><br><span class="line">请输入文章内容</span><br><span class="line"></span><br><span class="line">&#123;% endhideToggle %&#125;</span><br></pre></td></tr></table></figure><details class="toggle" ><summary class="toggle-button" style="">你知道《滕王阁序》原文吗？</summary><div class="toggle-content"><p>豫章故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰。台隍枕夷夏之交，宾主尽东南之美。都督阎公之雅望，棨戟遥临；宇文新州之懿范，襜帷暂驻。十旬休假，胜友如云；千里逢迎，高朋满座。腾蛟起凤，孟学士之词宗；紫电青霜，王将军之武库。家君作宰，路出名区；童子何知，躬逢胜饯。</p><p>时维九月，序属三秋。潦水尽而寒潭清，烟光凝而暮山紫。俨骖騑于上路，访风景于崇阿；临帝子之长洲，得天人之旧馆。层峦耸翠，上出重霄；飞阁流丹，下临无地。鹤汀凫渚，穷岛屿之萦回；桂殿兰宫，即冈峦之体势。</p><p>披绣闼，俯雕甍，山原旷其盈视，川泽纡其骇瞩。闾阎扑地，钟鸣鼎食之家；舸舰弥津，青雀黄龙之舳。云销雨霁，彩彻区明。落霞与孤鹜齐飞，秋水共长天一色。渔舟唱晚，响穷彭蠡之滨；雁阵惊寒，声断衡阳之浦。</p><p>遥襟甫畅，逸兴遄飞。爽籁发而清风生，纤歌凝而白云遏。睢园绿竹，气凌彭泽之樽；邺水朱华，光照临川之笔。四美具，二难并。穷睇眄于中天，极娱游于暇日。天高地迥，觉宇宙之无穷；兴尽悲来，识盈虚之有数。望长安于日下，目吴会于云间。地势极而南溟深，天柱高而北辰远。关山难越，谁悲失路之人？萍水相逢，尽是他乡之客。怀帝阍而不见，奉宣室以何年？</p><p>嗟乎！时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！</p><p>勃，三尺微命，一介书生。无路请缨，等终军之弱冠；有怀投笔，慕宗悫之长风。舍簪笏于百龄，奉晨昏于万里。非谢家之宝树，接孟氏之芳邻。他日趋庭，叨陪鲤对；今兹捧袂，喜托龙门。杨意不逢，抚凌云而自惜；钟期既遇，奏流水以何惭？</p><p>呜乎！胜地不常，盛筵难再；兰亭已矣，梓泽丘墟。临别赠言，幸承恩于伟饯；登高作赋，是所望于群公。敢竭鄙怀，恭疏短引；一言均赋，四韵俱成。请洒潘江，各倾陆海云尔：</p><p>滕王高阁临江渚，佩玉鸣鸾罢歌舞。</p><p>画栋朝飞南浦云，珠帘暮卷西山雨。</p><p>闲云潭影日悠悠，物换星移几度秋。</p><p>阁中帝子今何在？槛外长江空自流。</p></div></details></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note blue no-icon flat"><h3 id="分栏-Tabs"><a href="#分栏-Tabs" class="headerlink" title="分栏  Tabs"></a>分栏  Tabs</h3></div><p>可以对自己的文章进行分栏查看</p><p><strong>例：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs tests %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**第一个分栏**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**第二个分栏**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**第三个分栏**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">tests 1</button><button type="button" class="tab">tests 2</button><button type="button" class="tab">tests 3</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>第一个分栏</strong></p></div><div class="tab-item-content"><p><strong>第二个分栏</strong></p></div><div class="tab-item-content"><p><strong>第三个分栏</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p><strong>例：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs tests %&#125;</span><br><span class="line">&lt;!-- tab 李白 --&gt;</span><br><span class="line"><span class="strong">**第一个分栏内容**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 杜甫 --&gt;</span><br><span class="line"><span class="strong">**第二个分栏内容**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 王维 --&gt;</span><br><span class="line"><span class="strong">**第三个分栏内容**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">李白</button><button type="button" class="tab">杜甫</button><button type="button" class="tab">王维</button></div><div class="tab-contents"><div class="tab-item-content active"><p>李白（701年2月28日—762年12月）， 字太白，号青莲居士， 祖籍陇西成纪（今甘肃省秦安县），出生于蜀郡绵州昌隆县（一说出生于西域碎叶）。 唐朝伟大的浪漫主义诗人，凉武昭王李暠九世孙。<br>为人爽朗大方，乐于交友，爱好饮酒作诗，名列“酒中八仙” 。曾经得到唐玄宗李隆基赏识，担任翰林供奉， 赐金放还，游历全国，先后迎娶宰相许圉师、宗楚客的孙女。唐肃宗即位后，卷入永王之乱，流放夜郎，辗转到达当涂县令李阳冰家。上元二年，去世，时年六十二。<br>著有《李太白集》 ，代表作有《望庐山瀑布》《行路难》《蜀道难》《将进酒》《早发白帝城》等。 李白所作词赋，就其开创意义及艺术成就而言，享有极为崇高的地位，后世誉为“诗仙”，与诗圣杜甫并称“李杜”。</p></div><div class="tab-item-content"><p>杜甫（712年2月12日 —770年），字子美，自号少陵野老，唐代伟大的现实主义诗人，祖籍襄阳（今属湖北），自其曾祖时迁居巩县（今河南巩义西南）。 与李白合称“李杜”。为了与另两位诗人李商隐与杜牧即“小李杜”区分，杜甫与李白又合称“大李杜”，杜甫也常被称为“老杜”。后世称其杜拾遗、杜工部，也称他杜少陵、杜草堂。<br>杜甫少年时代曾先后游历吴越和齐赵，其间曾赴洛阳应举不第。三十五岁以后，先在长安应试，落第；后来向皇帝献赋，向贵人投赠。官场不得志，目睹了唐朝上层社会的奢靡与社会危机。天宝十四载（755年），安史之乱爆发，潼关失守，杜甫先后辗转多地。乾元二年（759年）杜甫弃官入川，虽然躲避了战乱，生活相对安定，但仍然心系苍生，胸怀国事。杜甫创作了《登高》《春望》《北征》以及“三吏”、“三别”等名作。虽然杜甫是个现实主义诗人，但他也有狂放不羁的一面，从其名作《饮中八仙歌》不难看出杜甫的豪气干云。大历五年（770年）冬，病逝，享年五十九岁。<br>杜甫在中国古典诗歌中的影响非常深远，被后世尊称为“诗圣”，他的诗被称为“诗史”。杜甫的思想核心是仁政思想，他有“致君尧舜上，再使风俗淳”的宏伟抱负。杜甫虽然在世时名声并不显赫，但后来声名远播，对中国文学和日本文学都产生了深远的影响。杜甫共有约1500首诗歌被保留了下来，大多集于《杜工部集》。</p></div><div class="tab-item-content"><p>王维（693年或694年或701年－761年）， 字摩诘，号摩诘居士，河东蒲州（今山西运城）人，祖籍山西祁县。唐朝诗人、画家。<br>王维出身河东王氏，于开元十九年（731年）状元及第，历官右拾遗、监察御史、河西节度使判官。唐玄宗天宝年间，王维拜吏部郎中、给事中。安禄山攻陷长安时，被迫受伪职。长安收复后，王维被责授太子中允，后官至尚书右丞。 王维于上元二年（761年）七月去世，享年六十一岁。<br>王维不仅参禅悟理，学庄信道，还精通诗、书、画、音乐等，以诗名盛于开元、天宝年间，尤长五言，多咏山水田园，与孟浩然合称“王孟”，有“诗佛”之称。其书画特臻其妙，后人推其为“南宗山水画之祖”。苏轼评价其曰：“味摩诘之诗，诗中有画；观摩诘之画，画中有诗。”其亦存诗400余首，代表作有《相思》《山居秋暝》等，还著有《王右丞集》《画学秘诀》等作品。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note blue no-icon flat"><h3 id="文字高亮颜色-label"><a href="#文字高亮颜色-label" class="headerlink" title="文字高亮颜色 label"></a>文字高亮颜色 label</h3></div><p>高亮所需的文字,方便标记重要内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label text color %&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>text</td><td>文字</td></tr><tr><td>color</td><td>【可选】背景颜色，默认为 default<br/>颜色有：<mark class="hl-label default">default</mark>/<mark class="hl-label blue">blue</mark>/<mark class="hl-label pink">pink</mark>/<mark class="hl-label red">red</mark>/<mark class="hl-label purple">purple</mark>/<mark class="hl-label orange">orange</mark>/<mark class="hl-label green">green</mark></td></tr></tbody></table><p><strong>例：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">臣亮言：&#123;% label 先帝 %&#125;创业未半，而&#123;% label 中道崩殂 blue %&#125;。今天下三分，&#123;% label 益州疲敝 pink %&#125;，此诚&#123;% label 危急存亡之秋 red %&#125;也！然侍衞之臣，不懈于内；&#123;% label 忠志之士 purple %&#125;，忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气；不宜妄自菲薄，引喻失义，以塞忠谏之路也。</span><br><span class="line">宫中、府中，俱为一体；陟罚臧否，不宜异同。若有&#123;% label 作奸 orange %&#125;、&#123;% label 犯科 green %&#125;，及为忠善者，宜付有司，论其刑赏，以昭陛下平明之治；不宜偏私，使内外异法也。</span><br></pre></td></tr></table></figure><p>臣亮言：<mark class="hl-label default">先帝</mark>创业未半，而<mark class="hl-label blue">中道崩殂</mark>。今天下三分，<mark class="hl-label pink">益州疲敝</mark>，此诚<mark class="hl-label red">危急存亡之秋</mark>也！然侍衞之臣，不懈于内；<mark class="hl-label purple">忠志之士</mark>，忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气；不宜妄自菲薄，引喻失义，以塞忠谏之路也。<br>宫中、府中，俱为一体；陟罚臧否，不宜异同。若有<mark class="hl-label orange">作奸</mark>、<mark class="hl-label green">犯科</mark>，及为忠善者，宜付有司，论其刑赏，以昭陛下平明之治；不宜偏私，使内外异法也。<br>；不宜偏私，使内外异法也。</p><div class="note blue no-icon flat"><h3 id="图标库-Icon"><a href="#图标库-Icon" class="headerlink" title="图标库 Icon"></a>图标库 Icon</h3></div><p>Butterfly支持 font-awesome v6 图标. </p><p>相关地址是：<a href="https://fontawesome.com/icons?from=io">图标库网站</a></p><p>可以使用预置图标网站里面的图标进行网站图标的更新和替换，也可以使用第三方的图标网站上面的图标进行个性化图标的替换和使用，自定义图标。</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="博客" scheme="https://www.hoveco.top/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客" scheme="https://www.hoveco.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>博客加密</title>
    <link href="https://www.hoveco.top/2023/10/25/blogjiami/"/>
    <id>https://www.hoveco.top/2023/10/25/blogjiami/</id>
    <published>2023-10-25T00:30:00.000Z</published>
    <updated>2023-11-02T14:09:12.574Z</updated>
    
    <content type="html"><![CDATA[<div class="note green no-icon flat"><h2 id="这是个啥"><a href="#这是个啥" class="headerlink" title="这是个啥"></a>这是个啥</h2></div><ul><li><del>这可能是 Hexo 生态圈中 <strong>最好用的</strong> 博客加密插件</del></li><li>有时候需要写一些私密的博客, 通过密码验证的方式让人不能随意浏览，比如一些个人的文档，博客，或者日记等等</li><li>这在 wordpress, emlog 或是其他博客系统中都很容易实现, 然而 hexo 除外 :(</li><li>所以今天就推荐了这个hexo-blog-encrypt，可以实现这个需求</li><li>github地址如下：<a href="https://github.com/D0n9X1n/hexo-blog-encrypt/tree/master">https://github.com/D0n9X1n/hexo-blog-encrypt/tree/master</a></li></ul><div class="note green no-icon flat"><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2></div><p>安装的步骤很简单，在hexo目录下执行npm进行相关插件的安装</p><ul><li><code>npm install --save hexo-blog-encrypt</code></li><li>或 <code>yarn add hexo-blog-encrypt</code> (需要) <a href="https://yarnpkg.com/en/">Yarn</a>)</li></ul><div class="note green no-icon flat"><h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2></div><p>安装后快速使用步骤就是在相关的博客编辑文章的信息头部分加上password参数，编辑上密码就可以了</p><ul><li>将 “password” 字段添加到您文章信息头就像这样.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2016-03-30 21:18:02</span><br><span class="line">password: hello</span><br><span class="line">---</span><br></pre></td></tr></table></figure><ul><li>再使用 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code> 在本地预览加密的文章.</li></ul><div class="note green no-icon flat"><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2></div><p>插件支持文章信息头加密还有标签加密，两种设置的优先级如下</p><p>文章信息头 &gt; 按标签加密</p><div class="note green no-icon flat"><h2 id="高级设置"><a href="#高级设置" class="headerlink" title="高级设置"></a>高级设置</h2></div><h3 id="文章信息头加密"><a href="#文章信息头加密" class="headerlink" title="文章信息头加密"></a>文章信息头加密</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">tags:</span><br><span class="line">- 作为日记加密</span><br><span class="line">date: 2016-03-30 21:12:21</span><br><span class="line">password: mikemessi</span><br><span class="line">abstract: 有东西被加密了, 请输入密码查看.</span><br><span class="line">message: 您好, 这里需要密码.</span><br><span class="line">wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.</span><br><span class="line">wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="标签加密"><a href="#标签加密" class="headerlink" title="标签加密"></a>标签加密</h3><p>在hexo博客的的_config.yml文件中添加如下指定参数内容</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Security</span><br><span class="line">encrypt: # hexo-blog-encrypt</span><br><span class="line">  abstract: 有东西被加密了, 请输入密码查看.</span><br><span class="line">  message: 您好, 这里需要密码.</span><br><span class="line">  tags:</span><br><span class="line">  - &#123;name: 标签名字, password: 密码A&#125;</span><br><span class="line">  - &#123;name: 标签名字, password: 密码B&#125;</span><br><span class="line">  wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.</span><br><span class="line">  wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.</span><br></pre></td></tr></table></figure><h4 id="对博文禁用-Tag-加密"><a href="#对博文禁用-Tag-加密" class="headerlink" title="对博文禁用 Tag 加密"></a>对博文禁用 Tag 加密</h4><p>只需要将博文头部的 <code>password</code> 设置为 <code>&quot;&quot;</code> 即可取消 Tag 加密.</p><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Callback Test</span><br><span class="line">date: 2019-12-21 11:54:07</span><br><span class="line">tags:</span><br><span class="line">    - A Tag should be encrypted</span><br><span class="line">password: &quot;&quot;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">Use a &quot;&quot; to diable tag encryption.</span><br></pre></td></tr></table></figure><h3 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h3><p>文章信息头 &gt; <code>_config.yml</code> (站点根目录下的) &gt; 默认配置</p><h3 id="关于-Callback-函数"><a href="#关于-Callback-函数" class="headerlink" title="关于 Callback 函数"></a><a href="https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md#%E5%85%B3%E4%BA%8E-callback-%E5%87%BD%E6%95%B0">关于 Callback 函数</a></h3><p>在部分博客中, 解密后部分元素可能无法正常显示或者表现, 这属于已知问题. 目前的解决办法是通过自行查阅自己的博客中的代码, 了解到在 onload 事件发生时调用了哪些函数, 并将这些函数挑选后写入到博客内容中. 如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Callback Test</span><br><span class="line">date: 2019-12-21 11:54:07</span><br><span class="line">tags:</span><br><span class="line">    - Encrypted</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">This is a blog to test Callback functions. You just need to add code at the last of your post like following:</span><br><span class="line"></span><br><span class="line">It will be called after the blog decrypted.</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 添加一个 script tag 与代码在文章末尾.</span><br><span class="line">    alert(&quot;Hello World&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>例子在: <a href="https://mhexo.github.io/2020/12/06/Callback-Test/">Callback 例子</a>.</p><h3 id="解密后的触发事件"><a href="#解密后的触发事件" class="headerlink" title="解密后的触发事件"></a><a href="https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md#%E8%A7%A3%E5%AF%86%E5%90%8E%E7%9A%84%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6">解密后的触发事件</a></h3><p>感谢 @<a href="https://github.com/f-dong">f-dong</a>, 我们现在会在解密完成后触发一个 <code>hexo-blog-decrypt</code> 事件, 你们可以编写 callback 来监听该事件.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// trigger event</span><br><span class="line">var event = new Event(&#x27;hexo-blog-decrypt&#x27;);</span><br><span class="line">window.dispatchEvent(event);</span><br></pre></td></tr></table></figure><h3 id="对-TOC-进行加密"><a href="#对-TOC-进行加密" class="headerlink" title="对 TOC 进行加密"></a><a href="https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md#%E5%AF%B9-toc-%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86">对 TOC 进行加密</a></h3><p>如果你有一篇文章使用了 TOC，你需要修改模板的部分代码。这里用 landscape 作为例子：</p><ul><li>你可以在 hexo/themes/landscape/layout/_partial/article.ejs 找到 article.ejs。</li><li>然后找到 &lt;% post.content %&gt; 这段代码，通常在30行左右。</li><li>使用如下的代码来替代它:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if(post.toc == true)&#123; %&gt;</span><br><span class="line">  &lt;div id=&quot;toc-div&quot; class=&quot;toc-article&quot; &lt;% if (post.encrypt == true) &#123; %&gt;style=&quot;display:none&quot; &lt;% &#125; %&gt;&gt;</span><br><span class="line">    &lt;strong class=&quot;toc-title&quot;&gt;Index&lt;/strong&gt;</span><br><span class="line">      &lt;% if (post.encrypt == true) &#123; %&gt;</span><br><span class="line">        &lt;%- toc(post.origin, &#123;list_number: true&#125;) %&gt;</span><br><span class="line">      &lt;% &#125; else &#123; %&gt;</span><br><span class="line">        &lt;%- toc(post.content, &#123;list_number: true&#125;) %&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">&lt;%- post.content %&gt;</span><br></pre></td></tr></table></figure><h3 id="禁用-Log"><a href="#禁用-Log" class="headerlink" title="禁用 Log"></a>禁用 Log</h3><p>If you want to disable the logging, you can add a silent property in <code>_config.yml</code> and set it to true. 如果你想要禁止使用 Log, 你可以在 <code>_config.yml</code> 中增加一个 silent 属性, 并将其设置为 true.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Security</span><br><span class="line">encrypt: # hexo-blog-encrypt</span><br><span class="line">  silent: true</span><br></pre></td></tr></table></figure><p>这样就会禁止如 <code>INFO  hexo-blog-encrypt: encrypting &quot;&#123;Blog Name&#125;&quot; based on Tag: &quot;EncryptedTag&quot;.</code> 的日志.</p><h3 id="加密主题"><a href="#加密主题" class="headerlink" title="加密主题"></a>加密主题</h3><p>之前, 我们尝试使用 <code>template</code> 关键字来让用户能修改自己的主题. 后来发现真不是一个好主意. 所以我们现在引入了主题: <code>theme</code> 关键字.</p><p>你可以简单的使用 <code>theme</code> 在 <code>_config.yml</code> 里或者文章头, 如下:</p><h3 id="文章信息头"><a href="#文章信息头" class="headerlink" title="文章信息头"></a>文章信息头</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">tags:</span><br><span class="line">- 作为日记加密</span><br><span class="line">date: 2016-03-30 21:12:21</span><br><span class="line">password: mikemessi</span><br><span class="line">abstract: 有东西被加密了, 请输入密码查看.</span><br><span class="line">message: 您好, 这里需要密码.</span><br><span class="line">theme: xray</span><br><span class="line">wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.</span><br><span class="line">wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="在-config-yml"><a href="#在-config-yml" class="headerlink" title="在 _config.yml"></a>在 <code>_config.yml</code></h3><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Security</span><br><span class="line">encrypt: # hexo-blog-encrypt</span><br><span class="line">  abstract: 有东西被加密了, 请输入密码查看.</span><br><span class="line">  message: 您好, 这里需要密码.</span><br><span class="line">  tags:</span><br><span class="line">  - &#123;name: tagName, password: 密码A&#125;</span><br><span class="line">  - &#123;name: tagName, password: 密码B&#125;</span><br><span class="line">  theme: xray</span><br><span class="line">  wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.</span><br><span class="line">  wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.</span><br></pre></td></tr></table></figure><p>这里只列举了集中基本配置方法，其他详细配置方法请进入原github项目学习配置</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="网站建设" scheme="https://www.hoveco.top/categories/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"/>
    
    
    <category term="Hexo建站" scheme="https://www.hoveco.top/tags/Hexo%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-学习笔记-新手入门（一）</title>
    <link href="https://www.hoveco.top/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    <id>https://www.hoveco.top/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</id>
    <published>2023-10-12T00:30:00.000Z</published>
    <updated>2023-10-12T14:49:21.478Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/09/16/XZGlpWmeO7T8ft2.png" alt="image-20220916142151904"></p><h1 id="新手入门篇"><a href="#新手入门篇" class="headerlink" title="新手入门篇"></a>新手入门篇</h1><p><strong>注意：</strong>开始学习JavaSE之前建议学习的前置课程《C语言程序设计》《数据结构》《操作系统》《计算机组成原理》</p><p>欢迎各位小伙伴来到JavaSE视频教程，期待与各位小伙伴共度这一旅程！视频中所有的文档、资料，都可以直接在视频下方简介中找到，视频非培训机构出品，纯个人录制，不需要加任何公众号、小程序，直接自取即可。</p><p>教程开始之前，提醒各位小伙伴：</p><ul><li>如果你对某样东西不熟悉，请务必保证跟视频中使用一模一样的环境、一模一样的操作方式去使用，不要自作主张，否则出现某些奇怪的问题又不知道怎么办，就会浪费很多时间。</li><li>视频依然是基于Java 8进行讲解，不要自己去安装一个其他的版本，想要了解新版本特性可以在另一个视频里面观看。</li><li>在学习过程中，尽可能避免出现中文文件夹，包括后面的环境安装、项目创建，都尽量不要放在中文路径下（因为使用中文常常出现奇奇怪怪的问题）建议使用对应的英文单词代替，或者是用拼音都可以，最好只出现英文字母和数字。</li><li>本系列教程使用 IDEA社区版（免费）即可，不需要申请终极版。</li></ul><p>如果觉得本视频对你有帮助，请一键三连支持一下UP主！</p><h2 id="计算机思维导论"><a href="#计算机思维导论" class="headerlink" title="计算机思维导论"></a>计算机思维导论</h2><p>计算机自1946年问世以来，几乎改变了整个世界。</p><p>现在我们可以通过电脑来做很多事情，比如我们常常听到的什么人工智能、电子竞技、大数据等等，都和计算机息息相关，包括我们现在的手机、平板等智能设备，也是计算机转变而来的。各位可以看看最顶上的这张图片，如果你在小时候接触过计算机，那么一定对这张图片（照片拍摄于1996年，在美国加利福尼亚州加利福尼亚州的锁诺玛县）印象深刻，这张壁纸作为WindowsXP系统的默认壁纸，曾经展示在千家万户的电脑屏幕上。</p><p>也许你没有接触过计算机，也许你唯一接触计算机就是用来打游戏，也有可能你曾经捣鼓过计算机，在学习C语言之前，先让我们来了解一下计算机的世界。</p><h3 id="计算机的世界"><a href="#计算机的世界" class="headerlink" title="计算机的世界"></a>计算机的世界</h3><p><strong>注意：</strong>如果你已经完成了《C语言程序设计》视频教程的学习，可以直接跳过此部分。</p><p>计算机虽然名字听着很高级，不过它也是由一个个简单电路组成的。</p><p>我们在初中就学习过的电路图，不过这种电路太过简单，只能完成一些很基础的的操作，比如点亮小灯泡等。</p><p>很明显想要实现计算机怎么高级的运算机器，肯定是做不到的，这时我们就需要引入更加强大的数字电路了。</p><blockquote><p>用数字信号完成对数字量进行<a href="https://baike.baidu.com/item/%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97/3118202">算术运算</a>和<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/7224729">逻辑运算</a>的电路称为数字电路，或数字系统。由于它具有逻辑运算和逻辑处理功能，所以又称数字逻辑电路。现代的数字电路由半导体工艺制成的若干数字集成器件构造而成。逻辑门是数字逻辑电路的<a href="https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83/5246264">基本单元</a>。</p></blockquote><p>计算机专业一般会在大一开放《数字电路》这门课程，会对计算机底层的数字电路实现原理进行详细介绍。</p><p>数字电路引入了逻辑判断，简单的数字电路用电压的高低来区分出两种信号，低电压表示0，高电压表示1，由于只能通过这种方式表示出两种类型的信号，所以计算机采用的是二进制。</p><blockquote><p><a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6/361457">二进制</a>是计算技术中广泛采用的一种<a href="https://baike.baidu.com/item/%E6%95%B0%E5%88%B6/217113">数制</a>。二进制数据是用0和1两个数码来表示的数。它的<a href="https://baike.baidu.com/item/%E5%9F%BA%E6%95%B0/4260">基数</a>为2，进位规则是“逢二进一”，借位规则是“借一当二”。</p><p>比如我们一般采用的都是十进制表示，比如9再继续加1的话，就需要进位了，变成10，在二进制中，因为只有0和1，所以当1继续加1时，就需要进位了，就变成10了（注意这不是十，读成一零就行了）</p></blockquote><p>当然，仅仅有两种信号还不够，我们还需要逻辑门来辅助我们完成更多的计算，最基本的逻辑关系是与、或、非，而逻辑门就有相应的是<a href="https://baike.baidu.com/item/%E4%B8%8E%E9%97%A8">与门</a>、<a href="https://baike.baidu.com/item/%E6%88%96%E9%97%A8">或门</a>和<a href="https://baike.baidu.com/item/%E9%9D%9E%E9%97%A8">非门</a>，可以用电阻、电容、二极管、三极管等分立原件构成（具体咋构成的咱这里就不说了）</p><p>比如与操作，因为只有两种类型，我们一般将1表示为真，0表示为假，与操作（用&amp;表示）要求两个数参与进来，比如：</p><ul><li><p>1 &amp; 1 = 1   必须两边都是真，结果才为真。</p></li><li><p>1 &amp; 0 = 0   两边任意一个或者都不是真，结果为假。</p></li></ul><p>或运算（用 | 表示）：</p><ul><li><p>1 | 0 = 1   两边只要有一个为真，结果就为真</p></li><li><p>0 | 0 = 0   两边同时为假，结果才是假</p></li></ul><p>非运算实际上就是取反操作（可以是 ! 表示）</p><ul><li><p>!1 = 0</p></li><li><p>!0 = 1   非运算会将真变成假，假变成真</p></li></ul><p>有了这些运算之后，我们的电路不仅仅可以实现计算，也可以实现各种各样的逻辑判断，最终才能发展成我们的计算机。</p><p>前面我们大概介绍一下计算机的底层操作原理，接着我们来了解下计算机的基本组成。</p><p>各位熟知的计算机都是一个屏幕+一个主机的形式，然后配上我们的键盘鼠标，就可以开始使用了，但是实际上标准的计算机结构并没有这么简单，我们电脑最核心的部件，当属CPU，因为几乎所有的运算都是依靠CPU进行（各种各样的计算电路已经在CPU中安排好了，我们只需要发送对应的指令就可以进行对应的运算），它就像我们人的大脑一样，有了大脑才能进行思考。不过光有大脑还不行，还要有一些其他的部分来辅助工作，比如我们想向电脑里面打字，那么就需要连接一个键盘才能输入，我们想要点击桌面上的图标，那么就需要一个鼠标来操作光标，这些都是输入设备。我们的电脑开机之后显示器上会显示出画面，实际上显示器就是输出设备。</p><p>当然除了这些内容之外，我们的电脑还需要内存来保存运行时的一些数据，以及外存来保存文件（比如硬盘）等。我们常说的iPhone13 512G，这个512G并不是指的内存，而是指的外存，准确的说是用于存放文件硬盘大小，而真正的内存是我们常说的4G/6G/8G运行内存，内存的速度远高于外存的速度，所以1G内存的价格远超1G硬盘的价格。</p><p>计算机包括五大部件：运算器、控制器、存储器、输入和输出设备。有了这一套完整的硬件环境，我们的电脑才算是有了一个完整的身体。</p><h3 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h3><p><strong>注意：</strong>如果你已经完成了《C语言程序设计》视频教程的学习，可以直接跳过此部分。</p><p>前面我们了解了一下计算机的大致原理和组成结构，但是光有这一套硬件可不行，如何让这一套硬件按照我们想要的方式运作起来，也是非常重要的，这时我们就需要介绍操作系统了。</p><blockquote><p>操作系统（operating system，简称OS）是管理<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/5459592">计算机硬件</a>与<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6/12053">软件</a>资源的<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F/3220205">计算机程序</a>。操作系统需要处理如管理与<a href="https://baike.baidu.com/item/%E9%85%8D%E7%BD%AE/2394679">配置</a><a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98/103614">内存</a>、决定<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90/974435">系统资源</a>供需的优先次序、控制<a href="https://baike.baidu.com/item/%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87/10823368">输入设备</a>与<a href="https://baike.baidu.com/item/%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/10823333">输出设备</a>、操作网络与管理<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/4827215">文件系统</a>等基本事务。操作系统也提供一个让用户与系统<a href="https://baike.baidu.com/item/%E4%BA%A4%E4%BA%92/6964417">交互</a>操作的界面。</p><p>一般在计算机专业大二，会开放《操作系统》课程，会详细讲解操作系统的底层运作机制和调度。</p></blockquote><p>一般我们电脑上都安装了Windows操作系统（苹果笔记本安装的是MacOS操作系统），现在主流的电脑都已经预装Windows11了：</p><p>有了操作系统，我们的电脑才能真正运行起来，我们就可以轻松地通过键盘和鼠标来操作电脑了。</p><p>不过操作系统最开始并不是图形化界面，它类似于Windows中的命令提示符：</p><p><img src="https://ss1.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/03087bf40ad162d9136713ae11dfa9ec8b13cdf3.jpg"></p><p>没有什么图标这些概念，只有一个简简单单的黑框让我们进行操作，通过输入命令来进行一些简单的使用，程序的运行结果也会在黑框框（命令行）中打印出来，不过虽然仅仅是一个黑框，但是能运行的程序可是非常非常多的，只需要运行我们编写好的程序，就能完成各种各样复杂的计算任务，并且计算机的计算速度远超我们的人脑。</p><blockquote><p> 中国超级计算机系统天河二号，计算速度达到每秒5.49亿亿次。</p></blockquote><p>当然，除了我们常见的Windows和MacOS系统之外，还有我们以后需要经常打交道的Linux操作系统，这种操作系统是开源的，意思是所有的人都可以拿到源代码进行修改，于是就出现了很多发行版。有带图形化界面的，也有不带图形化界面的，不带图形化界面的Linux将是我们以后学习的重点。</p><p>不同操作系统之间的软件并不是通用的，比如Windows下我们的软件一般是.exe后缀名称，而MacOS下则不是，并且也无法直接运行.exe文件，这是因为不同操作系统的具体实现会存在一些不同，程序编译（我们之后会介绍到）之后的格式也会不同，所以是无法做到软件通用的。</p><p>正是因为有了操作系统，才能够组织我们计算机的底层硬件（包括CPU、内存、输入输出设备等）进行有序工作，没有操作系统电脑就如同一堆废铁，只有躯壳没有灵魂。</p><h3 id="计算机编程语言"><a href="#计算机编程语言" class="headerlink" title="计算机编程语言"></a>计算机编程语言</h3><p><strong>注意：</strong>如果你已经完成了《C语言程序设计》视频教程的学习，可以直接跳过此部分。</p><p>现在我们大致了解了我们的电脑的运作原理，实际上是一套完整的硬件+一个成形的操作系统共同存在的。接着我们就可以开始了解一下计算机的编程语言了。我们前面介绍的操作系统也是由编程语言写出来的，操作系统本身也算是一个软件。</p><p>那么操作系统是如何让底层硬件进行工作的呢？实际上就是通过向CPU发送指令来完成的。</p><blockquote><p>计算机指令就是指挥机器工作的指示和命令，程序就是一系列按一定顺序排列的指令，执行程序的过程就是计算机的工作过程。指令集，就是CPU中用来计算和控制计算机系统的一套指令的集合，而每一种新型的CPU在设计时就规定了一系列与其他硬件电路相配合的指令系统。而指令集的先进与否，也关系到CPU的性能发挥，它也是CPU性能体现的一个重要标志。</p></blockquote><p>我们电脑中的CPU有多种多样的，不同的CPU之间可能也会存在不同的架构，比如现在最常用的是x86架构，还有我们手机平板这样的移动设备使用的arm架构，不同的架构指令集也会有不同。</p><p>我们知道，计算机底层硬件都是采用的0和1这样的二进制表示，所以指令也是一样的，比如（这里随便写的）：</p><ul><li><p>000001  -  代表开机</p></li><li><p>000010  -  代表关机</p></li><li><p>000011  -  代表进行加法运算</p></li></ul><p>当我们通过电路发送给CPU这样的二进制指令，CPU就能够根据我们的指令执行对应的任务，而我们编写的程序保存在硬盘中也是这样的二进制形式，我们只需要将这些指令组织好，按照我们的思路一条一条执行对应的命令，就能够让计算机计算任何我们需要的内容了，这其实就是机器语言。</p><p>不过随着时代的进步，指令集越来越大，CPU支持的运算类型也越来越多，这样的纯二进制编写实在是太累了，并且越来越多的命令我们根本记不住，于是就有了汇编语言。汇编语言将这些二进制的操作码通过助记符来替换：</p><ul><li><p>MOV  传送字或字节。</p></li><li><p>MOVSX  先符号扩展,再传送。</p></li><li><p>MOVZX  先零扩展,再传送。</p></li><li><p>PUSH  把字压入堆栈。</p></li></ul><p>把这些原有的二进制命令通过一个单词来代替，这样是不是就好记多了，在程序编写完成后，我们只需要最后将这些单词转换回二进制指令就可以了，这也是早期出现的低级编程语言。</p><p>不过虽然通过这些助记符就能够很轻松地记住命令，但是还是不够方便，因为可能我们的程序需要完成一个很庞大的任务，但是如果还是这样一条一条指令进行编写，是不是太慢了点，有时候可能做一个简单的计算，都需要好几条指令来完成。于是，高级编程语言——C语言，终于诞生了。</p><blockquote><p>C语言诞生于美国的<a href="https://baike.baidu.com/item/%E8%B4%9D%E5%B0%94%E5%AE%9E%E9%AA%8C%E5%AE%A4/686816">贝尔实验室</a>，由<a href="https://baike.baidu.com/item/%E4%B8%B9%E5%B0%BC%E6%96%AF%C2%B7%E9%87%8C%E5%A5%87/7267171">丹尼斯·里奇</a>（Dennis MacAlistair Ritchie）以肯尼斯·蓝·汤普森（Kenneth Lane Thompson）设计的<a href="https://baike.baidu.com/item/B%E8%AF%AD%E8%A8%80/1845842">B语言</a>为基础发展而来，在它的主体设计完成后，汤普森和里奇用它完全重写了UNIX操作系统，且随着UNIX操作系统的发展，C语言也得到了不断的完善。</p></blockquote><p>高级语言不同于低级语言，低级语言的主要操作对象是指令本身，而高级语言却更加符合我们人脑的认知，更像是通过我们人的思维，去告诉计算机你需要做什么，包括语法也会更加的简单易懂。下面是一段简单的C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;   <span class="comment">//定义一个a等于10</span></span><br><span class="line">  <span class="type">int</span> b = <span class="number">10</span>;   <span class="comment">//定义一个b等于10</span></span><br><span class="line">  <span class="type">int</span> c = a + b;   <span class="comment">//语义非常明确，c就是a加上b计算出来的结果。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过现在看不懂没关系，我们后面慢慢学。</p><p>C语言虽然支持按照我们更容易理解的方式去进行编程，但是最后还是会编译成汇编指令最后变成计算机可以直接执行的指令，不过具体的编译过程，我们不需要再关心了，我们只需要去写就可以了，而对我们代码进行编译的东西，称为编译器。</p><p>当然，除了C语言之外，还有很多其他的高级语言，比如Java、Python、C#、PHP等等，相比其他编程语言，C算是比较古老的一种了，但是时隔多年直至今日，其他编程语言也依然无法撼动它的王者地位：</p><p>可以看到在2021年9月，依然排在编程语言排行榜的<strong>第一名</strong>（Python和Java紧随其后），可见这门语言是多么的不可撼动，很多操作系统、高级编程语言底层实现，几乎都是依靠C语言去编写的（包括Java的底层也是C/C++实现的）所以学习这一门语言，对于理工科尤其是计算机专业极为重要，学好C语言你甚至可以融汇贯通到其他语言，学起来也会轻松很多。</p><h3 id="走进Java语言"><a href="#走进Java语言" class="headerlink" title="走进Java语言"></a>走进Java语言</h3><p>前面我们介绍了C语言，它实际上就是通过编译，将我们可以看懂的代码，翻译为计算机能够直接执行的指令，这样计算机就可以按照我们想要的方式去进行计算了。当然，除了C语言之外，也有其他的语言，比如近几年也很火的Python，它跟C语言不同，它并不会先进行编译，而是直接交给解释器解释执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/16/xAe9TspMDtlz8SE.png" alt="image-20220916150119407"></p><p>可见，这种方式也可以让计算机按照我们的想法去进行工作。</p><p>一般来说，编程语言就分为两大类：</p><ul><li><strong>编译型语言：</strong>需要先编译为计算机可以直接执行的命令才可以运行。优点是计算机直接运行，性能高；缺点是与平台密切相关，在一种操作系统上编译的程序，无法在其他非同类操作系统上运行，比如Windows下的exe程序在Mac上就无法运行。</li><li><strong>解释型语言：</strong>只需要通过解释器代为执行即可，不需要进行编译。优点是可以跨平台，因为解释是解释器的事情，只需要在各个平台上安装对应的解释器，代码不需要任何修改就可以直接运行；缺点是需要依靠解释器解释执行，效率肯定没直接编译成机器指令运行的快，并且会产生额外的资源占用。</li></ul><p><img src="https://s2.loli.net/2022/09/16/phfUjyuXLIbR3gJ.png" alt="image-20220916151925672"></p><p>那么我们来看看我们今天要介绍的主角，Java语言（Java之父：James Gosling，詹姆斯·高斯林）</p><blockquote><p>Write Once, Run Anywhere.</p></blockquote><p>这是Java语言的标语，它的目标很明确：一次编写，到处运行，它旨在打破平台的限制，让Java语言可以运行在任何平台上，并且不需要重新编译，实现跨平台运行。</p><p>Java自1995年正式推出以来，已经度过了快28个春秋，而基于Java语言，我们的生活中也有了各种各样的应用：</p><p><img src="https://s2.loli.net/2022/09/16/8SWeCjp6M4ufBk2.png" alt="image-20220916151604563"></p><ul><li>诺基亚手机上的很多游戏都是使用Java编写的。</li><li>安卓系统中的各种应用程序也是使用Java编写的。</li><li>著名沙盒游戏《Minecraft》也有对应的Java版本，得益于Java跨平台特性，无论在什么操作系统上都可以玩到这款游戏。</li><li>…</li></ul><p>（有关Java的详细发展历程，可以参考《Java核心技术·卷I》第一章）</p><p>可见，Java实际上早已在我们生活中的各个地方扎根。那么，Java语言是什么样的一个运行机制呢？</p><p>实际上我们的Java程序也是需要进行编译才可以运行的，这一点与C语言是一样的，Java程序编译之后会变成<code>.class</code>结尾的二进制文件：</p><p><img src="https://s2.loli.net/2022/09/16/5z2OWQb3B9AhwSZ.png" alt="image-20220916153102763"></p><p>不过不同的是，这种二进制文件计算机并不能直接运行，而是需要交给JVM（Java虚拟机）执行。</p><p><img src="https://s2.loli.net/2022/09/16/6HnkcSIfPdVZEpM.png" alt="image-20220916152514450"></p><p>JVM是个什么东西呢？简单来说，它就像我们前面介绍的解释器一样，我们可以将编译完成的<code>.class</code>文件直接交给JVM去运行，而程序中要做的事情，也都是由它来告诉计算机该如何去执行。</p><p>在不同的操作系统下，都有着对应的JVM实现，我们只需要安装好就可以了，而我们程序员只需要将Java程序编译为<code>.class</code>文件就可以直接交给JVM运行，无论是什么操作系统，JVM都采用的同一套标准读取和执行<code>.class</code>文件，所以说我们编译之后，在任何平台都可以运行，实现跨平台。</p><p>由于Java又需要编译同时还需要依靠JVM解释执行，所以说Java<strong>既是编译型语言，也是解释型语言。</strong></p><p>Java分为很多个版本：</p><ul><li><strong>JavaSE：</strong>是我们本教程的主要学习目标，它是标准版的Java，也是整个Java的最核心内容，在开始后续课程之前，这是我们不得不越过的一道坎，这个阶段一定要认真扎实地将Java学好，不然到了后面的高级部分，会很头疼。</li><li><strong>JavaME：</strong>微缩版Java，已经基本没人用了。</li><li><strong>JavaEE：</strong>企业级Java，比如网站开发，它是JavaSE阶段之后的主要学习方向。</li></ul><p>从下节课开始，我们就正式地进行Java环境的安装和IDE的使用学习。</p><hr><h2 id="环境安装与IDE使用"><a href="#环境安装与IDE使用" class="headerlink" title="环境安装与IDE使用"></a>环境安装与IDE使用</h2><p>前面我们介绍了Java语言，以及其本身的一些性质，这一部分我们就开始进行学习环境安装（这一部分请务必跟着操作，不要自作主张地去操作，一开始就出问题其实是最劝退新手的）</p><h3 id="JDK下载与安装"><a href="#JDK下载与安装" class="headerlink" title="JDK下载与安装"></a>JDK下载与安装</h3><p>首先我们来介绍一下JDK和JRE，各位小伙伴一定要能够区分这两者才可以。</p><ul><li><strong>JRE（Java Runtime Environment）</strong>：Java的运行环境，安装了运行环境之后，Java程序才可以运行，一般不做开发，只是需要运行Java程序直接按照JRE即可。</li><li><strong>JDK（Java Development Kit）</strong>：包含JRE，并且还附带了大量开发者工具，我们学习Java程序开发就使用JDK即可。</li></ul><p>它们的关系如下：</p><p><img src="https://s2.loli.net/2022/09/16/MpGWrh5xZdI3bCJ.png" alt="image-20220916154906732"></p><p>那么现在我们就去下载JDK吧，这里推荐安装免费的ZuluJDK：<a href="https://www.azul.com/downloads/?version=java-8-lts&amp;package=jdk">https://www.azul.com/downloads/?version=java-8-lts&amp;package=jdk</a></p><p>在这里选择自己的操作系统对应的安装包：</p><p><img src="https://s2.loli.net/2022/09/16/thaGoKI8pXA7Vl6.png" alt="image-20220916155142546"></p><p>比如Windows下，我们就选择<code>.msi</code>的安装包即可（MacOS、Linux下同样选择对应的即可）</p><p><img src="https://s2.loli.net/2022/09/16/vjc62OFaqmAegCh.png" alt="image-20220916155242814"></p><p>下载完成后，我们直接双击安装：</p><p><img src="https://s2.loli.net/2022/09/16/Loi3Ru7FAWHP6vN.png" alt="image-20220916160027645"></p><p><strong>注意，这里不建议各位小伙伴去修改安装的位置！</strong>新手只建议安装到默认位置（不要总担心C盘不够，该装的还是要装，尤其是这种环境，实在装不下就去将其他磁盘的空间分到C盘一部分）如果是因为没有安装到默认位置出现了任何问题，你要是找不到大佬问的话，又得重新来一遍，就很麻烦。</p><p>剩下的我们只需要一路点击Next即可，安装完成之后，我们打开CMD命令窗口（MacOS下直接打开“终端”）来验证一下（要打开CMD命令窗口，Windows11可以直接在下面的搜索框搜索cmd即可，或者直接在文件资源管理器路径栏输入cmd也可以）</p><p>我们直接输入java命令即可：</p><p><img src="https://s2.loli.net/2022/09/16/ROD3vkzwT8yFqrc.png" alt="image-20220916160756046"></p><p>如果能够直接输出内容，说明环境已经安装成功了，正常情况下已经配置好了，我们不需要手动去配置什么环境变量，所以说安装好就别管了。</p><p>输入<code>java -version</code>可以查看当前安装的JDK版本：</p><p><img src="https://s2.loli.net/2022/09/16/cPpCTOf9zZsWSw8.png" alt="image-20220916161050161"></p><p>只要是1.8.0就没问题了，后面的小版本号可能你们会比我的还要新。</p><p>这样我们就完成了Java环境的安装，我们可以来体验一下编写并且编译运行一个简单的Java程序，我们新建一个文本文档，命名为<code>Main.txt</code>（如果没有显示后缀名，需要在文件资源管理器中开启一下）然后用记事本打开，输入以下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在看不懂没关系，直接用就行，我们后面会一点一点讲解的。</p><p>编辑好之后，保存退出，接着我们将文件的后缀名称修改为<code>.java</code>这是Java源程序文件的后缀名称：</p><p><img src="https://s2.loli.net/2022/09/16/MAPh4aLSwHuRNlU.png" alt="image-20220916161607822"></p><p>此时我们打开CMD，注意要先进入到对应的路径下，比如我们现在的路径：</p><p><img src="https://s2.loli.net/2022/09/16/8A4oq7XdeLthpmg.png" alt="image-20220916161720722"></p><p>我们使用<code>cd</code>命令先进入到这个目录下：</p><p><img src="https://s2.loli.net/2022/09/16/HifR7pVSmqbP4Kh.png" alt="image-20220916161802753"></p><p>要编译一个Java程序，我们需要使用<code>javac</code>命令来进行：</p><p><img src="https://s2.loli.net/2022/09/16/IPofZRshyuwgciU.png" alt="image-20220916161857278"></p><p>执行后，可以看到目录下多出来了一个<code>.class</code>文件：</p><p><img src="https://s2.loli.net/2022/09/16/UdEJQL6WvIBFXf1.png" alt="image-20220916161923814"></p><p>这样我们就成功编译了一个Java程序，然后我们就可以将其交给JVM运行了，我们直接使用<code>java</code>命令即可：</p><p><img src="https://s2.loli.net/2022/09/16/esLwPFcOj87MrWo.png" alt="image-20220916162048405"></p><p>注意不要加上后缀名称，直接输入文件名字即可，可以看到打印了一个 Hello World! 字样，我们的第一个Java程序就可以运行了。</p><h3 id="IDEA安装与使用"><a href="#IDEA安装与使用" class="headerlink" title="IDEA安装与使用"></a>IDEA安装与使用</h3><p>前面我们介绍了JDK开发环境的安装以及成功编译运行了我们的第一个Java程序。</p><p>但是我们发现，如果我们以后都使用记事本来进行Java程序开发的话，是不是效率太低了点？我们还要先编辑，然后要改后缀，还要敲命令来编译，有没有更加方便一点的写代码的工具呢？这里我们要介绍的是：<strong>IntelliJ IDEA</strong>（这里不推荐各位小伙伴使用Eclipse，因为操作上没有IDEA这么友好）</p><p>IDEA准确来说是一个集成开发环境（IDE），它集成了大量的开发工具，编写代码的错误检测、代码提示、一键完成编译运行等，非常方便。</p><p>下载地址：<a href="https://www.jetbrains.com.cn/idea/">IntelliJ IDEA：JetBrains 功能强大、符合人体工程学的 Java IDE</a>（如果你之前学习C语言程序设计篇使用过CLion，你会发现界面一模一样，这样就能方便你快速上手）</p><p><img src="https://s2.loli.net/2022/09/16/UfIQzAXBS7TePm9.png" alt="image-20220916162544360"></p><p>我们直接点击下载即可：</p><p><img src="https://s2.loli.net/2022/09/16/sifjSGwLxYhHgKR.png" alt="image-20220916162830260"></p><p>这个软件本身是付费的，比较贵，而且最近还涨价了，不过这里我们直接下载面的社区版本就行了（JavaSE学习阶段不需要终极版，但是建议有条件的还是申请一个，因为后面JavaWeb开始就需要终极版了，学生和教师可以直接免费申请一年的使用许可，并且每个学期都可以续一年）</p><p>下载好之后，直接按照即可，这个不强制要求安装到C盘，自己随意，但是注意路径中不要出现中文！</p><p><img src="https://s2.loli.net/2022/09/16/jd64AxEfmQXWTNl.png" alt="image-20220916163329410"></p><p>这里勾选一下创建桌面快捷方式就行：</p><p><img src="https://s2.loli.net/2022/09/16/buv9QmapGCENcXn.png" alt="image-20220916163401880"></p><p>安装完成后，我们直接打开就可以了：</p><p><img src="https://s2.loli.net/2022/09/16/rihpxBbQz9jlZWU.png" alt="image-20220916163726690"></p><p>此时界面是全英文，如果各位小伙伴看得惯，可以直接使用全英文的界面（使用英文界面可以认识更多的专业术语词汇，但是可能看起来没中文那么直观，而且IDEA本身功能就比较多，英语不好的小伙伴就很头疼）这里还是建议英语不好的小伙伴使用中文界面，要使用中文只需要安装中文插件即可：</p><p><img src="https://s2.loli.net/2022/09/16/tW4UPnpaFsfDB9r.png" alt="image-20220916164025426"></p><p>我们打开Plugins插件这一栏，然后直接在插件市场里面搜索Chinese，可以找到一个中文语言包的插件，我们直接Install安装即可，安装完成后点击重启，现在就是中文页面了：</p><p><img src="https://s2.loli.net/2022/09/16/UFka83Se97COoJK.png" alt="image-20220916164235648"></p><p>如果各位小伙伴不喜欢黑色主题，也可以修改为白色主题，只需要在自定义中进行修改即可，一共四种主题。</p><p>如果你之前使用过其他IDE编写代码，这里还支持按键映射（采用其他IDE的快捷键方案）有需要的可以自己修改一下：</p><p><img src="https://s2.loli.net/2022/09/16/3wbt7QhZmq9EKgY.png" alt="image-20220916164415447"></p><p>接下来，我们来看看如何使用IDEA编写Java程序，IDEA是以项目的形式对一个Java程序进行管理的，所以说我们直接创建一个新的项目，点击新建项目：</p><p><img src="https://s2.loli.net/2022/09/16/4qvjxmozBaJgOuH.png" alt="image-20220916164906998"></p><p>此时来到创建页面：</p><p><img src="https://s2.loli.net/2022/09/16/ldzGSmYBkr7uO3c.png" alt="image-20220916164941663"></p><ul><li><strong>名称：</strong>你的Java项目的名称，随便起就行，尽量只带英文字母和数字，不要出现特殊字符和中文。</li><li><strong>位置：</strong>项目的存放位置，可以自己根据情况修改，同样的，路径中不要出现中文。</li><li><strong>语言：</strong>IDEA支持编写其他语言的项目，但是这里我们直接选择Java就行了。</li><li><strong>构建系统：</strong>在JavaSE阶段一律选择IntelliJ就行了，Maven我们会在JavaWeb之后进行讲解，Gradle会在安卓开发教程中介绍。</li><li><strong>JDK：</strong>就是我们之前安装好的JDK，如果是默认路径安装，这里会自动识别（所以说不要随便去改，不然这些地方就很麻烦）</li></ul><p>当然，如果JDK这里没有自动识别到，那么就手动添加一下：</p><p><img src="https://s2.loli.net/2022/09/16/fDJKB6M3TlWizoQ.png" alt="image-20220916165351016"></p><p>没问题之后，我们直接创建项目：</p><p><img src="https://s2.loli.net/2022/09/16/aQDnYVx6cZhlRUv.png" alt="image-20220916165926205"></p><p>进入之后，可以看到已经自动帮助我们创建好了一个<code>java</code>源文件，跟我们之前的例子是一样的。要编译运行我们的Java程序，只需要直接点击左边的三角形（启动按钮）即可：</p><p><img src="https://s2.loli.net/2022/09/16/nyWCev6SNkH9oMm.png" alt="image-20220916170119203"></p><p>点击之后，会在下方自动开始构建：</p><p><img src="https://s2.loli.net/2022/09/16/3791Nedvu8RQxSc.png" alt="image-20220916170201943"></p><p>完成之后，就可以在控制台看到输出的内容了：</p><p><img src="https://s2.loli.net/2022/09/16/l8G5MwfLJHq3eQD.png" alt="image-20220916170231090"></p><p>我们可以看到新增加了一个<code>out</code>目录，这里面就是刚刚编译好的<code>.class</code>文件：</p><p><img src="https://s2.loli.net/2022/09/16/49ywZ8bEQtYdLBP.png" alt="image-20220916170358904"></p><p>IDEA非常强大，即使是编译之后的二进制文件，也可以反编译回原代码的样子：</p><p><img src="https://s2.loli.net/2022/09/16/DeaO9P8mLRA2uHb.png" alt="image-20220916170442922"></p><p>如果我们想写一个新的Java项目，可以退出当前项目重新创建：</p><p><img src="https://s2.loli.net/2022/09/16/sIw3ZcarNuA4TS8.png" alt="image-20220916170558720"></p><p>此时项目列表中就有我们刚刚创建的Java项目了：</p><p><img src="https://s2.loli.net/2022/09/16/urQkEzWw5JOAGLo.png" alt="image-20220916170654353"></p><p>如果你还想探索IDEA的其他功能，可以点击欢迎页最下方的学习：</p><p><img src="https://s2.loli.net/2022/09/16/MdGZgaBPyqfeIxX.png" alt="image-20220916164837599"></p><p>会有一个专门的引导教程项目，来教你如何使用各项功能：</p><p><img src="https://s2.loli.net/2022/09/16/I1PcHasEzyxw8eL.png" alt="image-20220916164703111"></p><h3 id="IDEA新UI介绍和外观设置"><a href="#IDEA新UI介绍和外观设置" class="headerlink" title="IDEA新UI介绍和外观设置"></a>IDEA新UI介绍和外观设置</h3><p>IDEA在2022年开启了界面新UI的测试，并将在年底前实装，所以说我们将老UI界面改为新的UI界面进行介绍（如果已经是新UI的样式，那么就不需要像下面一样开启了）</p><p>我们随便进入一个项目，然后双击Shift出现搜索框（这个搜索框很好用，什么都能搜）输入<code>registry</code></p><p><img src="https://s2.loli.net/2022/09/16/gXNG9fqzHJiWtlU.png" alt="image-20220916171015360"></p><p>找到<code>ide.experimental.ui</code>，将其勾选上，然后重启IDEA就变成新的UI样式了（你不说这是IDEA我还以为是VS呢）</p><p><img src="https://s2.loli.net/2022/09/16/4urncqfwQFG3pCT.png" alt="image-20220916171139281"></p><p>这里介绍一下新UI的各个功能，首先是运行项目，依然是点击左侧三角形：</p><p><img src="https://s2.loli.net/2022/09/16/MwEkSagiTDZIL3y.png" alt="image-20220916171251054"></p><p>在第一次运行后，会自动生成一个运行配置，我们也可以直接点击右上角的运行：</p><p><img src="https://s2.loli.net/2022/09/16/gtVmywzIBP5io1X.png" alt="image-20220916171324195"></p><p>效果是一样的，都可以编译运行Java项目。上面一排工具栏被丢到了一个菜单里面：</p><p><img src="https://s2.loli.net/2022/09/16/UvednOgYZ3MEhBH.png" alt="image-20220916171421975"></p><p>如果各位小伙伴觉得代码字体太小了，可以在设置中进行调整：</p><p><img src="https://s2.loli.net/2022/09/16/3zbAx94vJ5NihtY.png" alt="image-20220916171604891"></p><p>IDEA的所有通知都可以在通知中查看：</p><p><img src="https://s2.loli.net/2022/09/16/18aOSWXMhZnwPeq.png" alt="image-20220916171736462"></p><p>我们来看右下角，第一个三角形图标是运行的结果：</p><p><img src="https://s2.loli.net/2022/09/16/4IdVS8mrxnezkqE.png" alt="image-20220916171806992"></p><p>第二栏是终端（其实就是内嵌的一个CMD命令窗口）可以自由敲命令，默认是位于项目根目录下：</p><p><img src="https://s2.loli.net/2022/09/16/CN9YwJ4LyxWGOIE.png" alt="image-20220916171854171"></p><p>至此，学习前准备就完成了，从下节课开始，我们将正式进入到Java语言的学习中。</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="java" scheme="https://www.hoveco.top/categories/java/"/>
    
    
    <category term="JavaSE" scheme="https://www.hoveco.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-学习笔记-面向对象基础（三）</title>
    <link href="https://www.hoveco.top/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/"/>
    <id>https://www.hoveco.top/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89/</id>
    <published>2023-10-12T00:30:00.000Z</published>
    <updated>2023-10-12T14:49:21.865Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/09/18/UsqxV8ndNzYmGjy.png" alt="image-20220918121719900"></p><h1 id="面向对象基础篇"><a href="#面向对象基础篇" class="headerlink" title="面向对象基础篇"></a>面向对象基础篇</h1><p>我们在前面已经学习了面向过程编程，也可以自行编写出简单的程序了。我们接着就需要认识 面向对象程序设计（Object Oriented Programming）它是我们在Java语言中要学习的重要内容，面向对象也是高级语言的一大重要特性。</p><blockquote><p>面向对象是新手成长的一道分水岭，有的人秒懂，有的人直到最后都无法理解。</p></blockquote><p>这一章开始难度就上来了，所以说请各位小伙伴一定认真。</p><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>类的概念我们在生活中其实已经听说过很多了。</p><p>人类、鸟类、鱼类… 所谓类，就是对一类事物的描述，是抽象的、概念上的定义，比如鸟类，就泛指所有具有鸟类特征的动物。比如人类，不同的人，有着不同的性格、不同的爱好、不同的样貌等等，但是他们根本上都是人，所以说可以将他们抽象描述为人类。</p><p>对象是某一类事物实际存在的每个个体，因而也被称为实例（instance）我们每个人都是人类的一个实际存在的个体。</p><p><img src="https://s2.loli.net/2022/09/19/U2P7qWOtRz5bhFY.png" alt="image-20220919203119479"></p><p>所以说，类就是抽象概念的人，而对象，就是具体的某一个人。</p><ul><li>A：是谁拿走了我的手机？</li><li>B：是个人。（某一个类）</li><li>A：我还知道是个人呢，具体是谁呢？</li><li>B：是XXX。（具体某个对象）</li></ul><p>而我们在Java中，也可以像这样进行编程，我们可以定义一个类，然后进一步创建许多这个类的实例对象。像这种编程方式，我们称为<strong>面向对象编程</strong>。</p><h3 id="类的定义与对象创建"><a href="#类的定义与对象创建" class="headerlink" title="类的定义与对象创建"></a>类的定义与对象创建</h3><p>前面我们介绍了什么是类，什么是对象，首先我们就来看看如何去定义一个类。</p><p>比如现在我们想要定义一个人类，我们可以右键<code>src</code>目录，点击创建新的类：</p><p><img src="https://s2.loli.net/2022/09/19/alOtdE1JNcbpxM8.png" alt="image-20220919204004526"></p><p>我们在对类进行命名时，一般使用英文单词，并且首字母大写，跟变量命名一样，不能出现任何的特殊字符。</p><p><img src="https://s2.loli.net/2022/09/19/n1WuVYRiPeOfHqZ.png" alt="image-20220919204159248"></p><p>可以看到，现在我们的目录下有了两个<code>.java</code>源文件，其中一个是默认创建的Main.java，还有一个是我们刚刚创建的类。</p><p>我们来看看创建好之后，一个类写了哪些内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，这不是跟一开始创建的Main中写的格式一模一样吗？没错，Main也是一个类，只不过我们一直都将其当做主类在使用，也就是编写主方法的类，关于方法我们会在后面进行介绍。</p><p>现在我们就创建好了一个类，既然是人类，那么肯定有人相关的一些属性，比如名字、性别、年龄等等，那么怎么才能给这个类添加一些属性呢？</p><p>我们可以将这些属性直接作为类的成员变量（成员变量相当于是这个类所具有的属性，每个实例创建出来之后，这些属性都可能会各不相同）定义到类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;   <span class="comment">//这里定义的人类具有三个属性，名字、年龄、性别</span></span><br><span class="line">    String name;   <span class="comment">//直接在类中定义变量，表示类具有的属性</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能会有小伙伴疑问，这些变量啥时候被赋值呢？实际上这些变量只有在一个具体的对象中才可以使用。</p><p>那么现在人类的属性都规定好了，我们就可以尝试创建一个实例对象了，实例对应的应该是一个具体的人：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>();   <span class="comment">//我们可以使用new关键字来创建某个类的对象，注意new后面需要跟上 类名()</span></span><br><span class="line">  <span class="comment">//这里创建出来的，就是一个具体的人了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上整个流程为：</p><p><img src="https://s2.loli.net/2022/09/19/dSM4XDBV7qkIUlb.png" alt="image-20220919205550104"></p><p>只不过这里仅仅是创建出了这样的一个对象，我们目前没有办法去操作这个对象，比如想要修改或是获取这个人的名字等等。</p><h3 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h3><p>既然现在我们知道如何创建对象，那么我们怎么去访问这个对象呢，比如我现在想要去查看或是修改它的名字。</p><p>我们同样可以使用一个变量来指代某个对象，只不过引用类型的变量，存储的是对象的引用，而不是对象本身：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//这里的a存放的是具体的某个值</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">  <span class="comment">//创建一个变量指代我们刚刚创建好的对象，变量的类型就是对应的类名</span></span><br><span class="line">  <span class="comment">//这里的p存放的是对象的引用，而不是本体，我们可以通过对象的引用来间接操作对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么对象类型的变量存放的是对象的引用，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们将变量p2赋值为p1的值，那么实际上只是传递了对象的引用，而不是对象本身的复制，这跟我们前面的基本数据类型有些不同，p2和p1都指向的是同一个对象（如果你学习过C语言，它就类似于指针一样的存在）</p><p><img src="https://s2.loli.net/2022/09/19/GBPaNZsr2MSKvCq.png" alt="image-20220919211443657"></p><p>我们可以来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> p1;</span><br><span class="line">    System.out.println(p1 == p2);    <span class="comment">//使用 == 可以判断两个变量引用的是不是同一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果我们像这样去编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();   <span class="comment">//这两个变量分别引用的是不同的两个对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    System.out.println(p1 == p2);   <span class="comment">//如果两个变量存放的是不同对象的引用，那么肯定就是不一样的了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上我们之前使用的String类型，也是一个引用类型，我们会在下一章详细讨论。我们在上一章介绍的都是基本类型，而类使用的都是引用类型。</p><p>现在我们有了对象的引用之后，我们就可以进行操作了：</p><p><img src="https://s2.loli.net/2022/09/19/cEJ1CWshtQFbZzy.png" alt="image-20220919210058797"></p><p>我们可以直接访问对象的一些属性，也就是我们在类中定义好的那些，对于不同的对象，这些属性都具体存放值也会不同。</p><p>比如我们可以修改对象的名字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    p.name = <span class="string">&quot;小明&quot;</span>;   <span class="comment">//要访问对象的属性，我们需要使用 . 运算符</span></span><br><span class="line">    System.out.println(p.name);   <span class="comment">//直接打印对象的名字，就是我们刚刚修改好的结果了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，不同对象的属性是分开独立存放的，每个对象都有一个自己的空间，修改一个对象的属性并不会影响到其他对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    p1.name = <span class="string">&quot;小明&quot;</span>;   <span class="comment">//这个修改的是第一个对象的属性</span></span><br><span class="line">    p2.name = <span class="string">&quot;大明&quot;</span>;   <span class="comment">//这里修改的是第二个对象的属性</span></span><br><span class="line">    System.out.println(p1.name);  <span class="comment">//这里我们获取的是第一个对象的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于对象类型的变量，我们也可以不对任何对象进行引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">//null是一个特殊的值，它表示空，也就是不引用任何的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果不引用任何的对象，那肯定是不应该去通过这个变量去操作所引用的对象的（都没有引用对象，我操作谁啊我）</p><p>虽然这样可以编译通过，但是在运行时会出现问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="literal">null</span>;   <span class="comment">//此时变量没有引用任何对象</span></span><br><span class="line">    p.name = <span class="string">&quot;小红&quot;</span>;   <span class="comment">//我任性，就是要操作</span></span><br><span class="line">    System.out.println(p.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来尝试运行一下这段代码：</p><p><img src="https://s2.loli.net/2022/09/19/hkME1wf58aSdWGZ.png" alt="image-20220919213732810"></p><p>此时程序在运行的过程中，出现了异常，虽然我们还没有学习到异常，但是各位可以将异常理解为程序在运行过程中出现了问题，此时不得不终止程序退出。</p><p>这里出现的是空指针异常，很明显是因为我们去操作一个值为null的变量导致的。在我们以后的学习中，这个异常是出现频率最高的。</p><p>我们来看最后一个问题，对象创建成功之后，它的属性没有进行赋值，但是我们前面说了，变量使用之前需要先赋值，那么创建对象之后能否直接访问呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span>+p.name);</span><br><span class="line">    System.out.println(<span class="string">&quot;age = &quot;</span>+p.age);</span><br><span class="line">    System.out.println(<span class="string">&quot;sex = &quot;</span>+p.sex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看运行结果：</p><p><img src="https://s2.loli.net/2022/09/19/zDRdFwhm6nebSJU.png" alt="image-20220919214248053"></p><p>我们可以看到，如果直接创建对象，那么对象的属性都会存在初始值，如果是基本类型，那么默认是统一为<code>0</code>（如果是boolean的话，默认值为false）如果是引用类型，那么默认是<code>null</code>。</p><h3 id="方法创建与使用"><a href="#方法创建与使用" class="headerlink" title="方法创建与使用"></a>方法创建与使用</h3><p>前面我们介绍了类的定义以及对象的创建和使用。</p><p>现在我们的类有了属性，我们可以为创建的这些对象设定不同的属性值，比如每个人的名字都不一样，性别不一样，年龄不一样等等。只不过光有属性还不行，对象还需要具有一定的行为，就像我们人可以行走，可以跳跃，可以思考一样。</p><p>而对象也可以做出一些行为，我们可以通过定义方法来实现（在C语言中叫做函数）</p><p>方法是语句的集合，是为了完成某件事情而存在的。完成某件事情，可以有结果，也可以做了就做了，不返回结果。比如计算两个数字的和，我们需要得到计算后的结果，所以说方法需要有返回值；又比如，我们只想吧数字打印在控制台，只需要打印就行，不用给我结果，所以说方法不需要有返回值。</p><p>方法的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 方法名称() &#123;</span><br><span class="line">方法体...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是返回值类型，也就是说这个方法完成任务之后，得到的结果的数据类型（可以是基本类型，也可以是引用类型）当然，如果没有返回值，只是完成任务，那么可以使用<code>void</code>表示没有返回值，比如我们现在给人类编写一个自我介绍的行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//自我介绍只需要完成就行，没有返回值，所以说使用void</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//完成自我介绍需要执行的所有代码就在这个花括号中编写</span></span><br><span class="line">      <span class="comment">//这里编写代码跟我们之前在main中是一样的（实际上main就是一个函数）</span></span><br><span class="line">      <span class="comment">//自我介绍需要用到当前对象的名字和年龄，我们直接使用成员变量即可，变量的值就是当前对象的存放值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我叫 &quot;</span>+name+<span class="string">&quot; 今年 &quot;</span>+age+<span class="string">&quot; 岁了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，方法名称同样可以随便起，但是规则跟变量的命名差不多，也是尽量使用小写字母开头的单词，如果是多个单词，一般使用驼峰命名法最规范。</p><p><img src="https://s2.loli.net/2022/09/20/2vmhsCRXpPzojiD.png" alt="image-20220920101033325"></p><p>现在我们给人类定义好了一个方法（行为）那么怎么才能让对象执行这个行为呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    p.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    p.age = <span class="number">18</span>;</span><br><span class="line">    p.hello();    <span class="comment">//我们只需要使用 . 运算符，就可以执行定义好的方法了，只需要 .方法名称() 即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样执行定义好的方法，我们一般称为<strong>方法的调用</strong>，我们来看看效果：</p><p><img src="https://s2.loli.net/2022/09/19/bR2PAWoJ8qUzCfh.png" alt="image-20220919220837991"></p><p>比如现在我们要让人类学会加法运算，我们也可以通过定义一个方法的形式来完成，只不过，要完成加法运算，我们需要别人给人类提供两个参与加法运算的值才可以，所以我们这里就要用到参数了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们的方法需要别人提供参与运算的值才可以</span></span><br><span class="line"><span class="comment">//我们可以为方法设定参数，在调用方法时，需要外部传入参数才可以</span></span><br><span class="line"><span class="comment">//参数的定义需要在小括号内部编写，类似于变量定义，需要填写 类型和参数名称，多个参数用逗号隔开</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;   <span class="comment">//这里需要两个int类型的参数进行计算</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么现在参数从外部传入之后，我们怎么使用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;   <span class="comment">//这里的参数，相当于我们在函数中定义了两个局部变量，我们可以直接在方法中使用</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;   <span class="comment">//直接c = a + b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么现在计算完成了，我们该怎么将结果传递到外面呢？首先函数的返回值是int类型，我们只需要使用<code>return</code>关键字来返回一个int类型的结果就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">    <span class="keyword">return</span> c;   <span class="comment">//return后面紧跟需要返回的结果，这样就可以将计算结果丢出去了</span></span><br><span class="line">  <span class="comment">//带返回值的方法，是一定要有一个返回结果的！否则无法通过编译！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    p.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    p.age = <span class="number">18</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> p.sum(<span class="number">10</span>, <span class="number">20</span>);    <span class="comment">//现在我们要让这个对象帮我们计算10 + 20的结果</span></span><br><span class="line">    System.out.println(result);    <span class="comment">//成功得到30，实际上这里的println也是在调用方法进行打印操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>方法定义时编写的参数，我们一般称为形式参数，而调用方法实际传入的参数，我们成为实际参数。</p><p>是不是越来越感觉我们真的在跟一个对象进行交互？只要各位有了这样的体验，基本上就已经摸到面向对象的门路了。</p><p>关于<code>return</code>关键字，我们还需要进行进一步的介绍。</p><p>在我们使用<code>return</code>关键字之后，方法就会直接结束并返回结果，所以说在这之后编写的任何代码，都是不可到达的：</p><p><img src="https://s2.loli.net/2022/09/19/UCcAb9L8lfOzXMZ.png" alt="image-20220919222813469"></p><p>在<code>return</code>后编写代码，会导致编译不通过，因为存在不可达语句。</p><p>如果我们的程序中出现了分支语句，那么必须保证每一个分支都有返回值才可以：</p><p><img src="https://s2.loli.net/2022/09/19/WjUlRrPwA9EXThV.png" alt="image-20220919223037197"></p><p>只要有任何一个分支缺少了<code>return</code>语句，都无法正常通过编译，总之就是必须考虑到所有的情况，任何情况下都必须要有返回值。</p><p>当然，如果方法没有返回值，我们也可以使用<code>return</code>语句，不需要跟上任何内容，只不过这种情况下使用，仅仅是为了快速结束方法的执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">10</span>) <span class="keyword">return</span>;    <span class="comment">//当a等于10时直接结束方法，后面无论有没有代码都不会执行了</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!&quot;</span>);   <span class="comment">//不是的情况就正常执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们来讨论一下参数的传递问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span>&#123;   <span class="comment">//我们可以设置参数来让外部的数据传入到函数内部</span></span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上参数的传递，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身，我们来下面的这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;   <span class="comment">//这个函数的目的很明显，就是为了交换a和b的值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>, b = <span class="number">9</span>;   <span class="comment">//外面也叫a和b</span></span><br><span class="line">    p.swap(a, b);</span><br><span class="line">    System.out.println(<span class="string">&quot;a = &quot;</span>+a+<span class="string">&quot;, b = &quot;</span>+b);   <span class="comment">//最后的结果会变成什么样子呢？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看结果是什么：</p><p><img src="https://s2.loli.net/2022/09/19/wJrLaT7YBeQipNV.png" alt="image-20220919224219071"></p><p>我们发现a和b的值并没有发生交换，但是按照我们的方法逻辑来说，应该是会交换才对，这是为什么呢？实际上这里仅仅是将值复制给了函数里面的变量而已（相当于是变量的赋值）</p><p><img src="https://s2.loli.net/2022/09/19/WdiDToucsCvySNf.png" alt="image-20220919224623727"></p><p>所以说我们交换的仅仅是方法中的a和b，参数传递仅仅是值传递，我们是没有办法直接操作到外面的a和b的。</p><p>那么各位小伙伴看看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">modify</span><span class="params">(Person person)</span>&#123;</span><br><span class="line">    person.name = <span class="string">&quot;lbwnb&quot;</span>;   <span class="comment">//修改对象的名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    p.name = <span class="string">&quot;小明&quot;</span>;     <span class="comment">//先在外面修改一次</span></span><br><span class="line">    p.modify(p);        <span class="comment">//调用方法再修改一次</span></span><br><span class="line">    System.out.println(p.name);    <span class="comment">//请问最后name会是什么？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看结果：</p><p><img src="https://s2.loli.net/2022/09/19/sNLjlYP6g3yxpe1.png" alt="image-20220919224957971"></p><p>不对啊，前面不是说只是值传递吗，怎么这里又可以修改成功呢？</p><p>确实，这里同样是进行的值传递，只不过各位小伙伴别忘了，我们前面可是说的清清楚楚，引用类型的变量，仅仅存放的是对象的引用，而不是对象本身。那么这里进行了值传递，相当于将对象的引用复制到了方法内部的变量中，而这个内部的变量，依然是引用的同一个对象，所以说这里在方法内操作，相当于直接操作外面的定义对象。</p><p><img src="https://s2.loli.net/2022/09/19/aXf6AsdLneKxi9V.png" alt="image-20220919225455752"></p><h3 id="方法进阶使用"><a href="#方法进阶使用" class="headerlink" title="方法进阶使用"></a>方法进阶使用</h3><p>有时候我们的方法中可能会出现一些与成员变量重名的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们希望使用这个方法，来为当前对象设定名字</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时类中定义的变量名称也是<code>name</code>，那么我们是否可以这样编写呢：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    name = name;    <span class="comment">//出现重名时，优先使用作用域最接近的，这里实际上是将方法参数的局部变量name赋值为本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    p.setName(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    System.out.println(p.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，似乎这样做并没有任何的效果，name依然是没有修改的状态。那么当出现重名的时候，因为默认情况下会优先使用作用域最近的变量，我们怎么才能表示要使用的变量是类的成员变量呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.name = <span class="string">&quot;小明&quot;</span>;    <span class="comment">//我们之前在外面使用时，可以直接通过对象.属性的形式访问到</span></span><br></pre></td></tr></table></figure><p>同样的，我们如果想要在方法中访问到当前对象的属性，那么可以使用<code>this</code>关键字，来明确表示当前类的示例对象本身：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;   <span class="comment">//让当前对象的name变量值等于参数传入的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以修改成功了，当然，如果方法内没有变量出现重名的情况，那么默认情况下可以不使用<code>this</code>关键字来明确表示当前对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;    <span class="comment">//这里没有使用this，但是当前作用域下只有对象属性的name变量，所以说直接就使用了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接着来看方法的重载。</p><p>有些时候，参数类型可能会多种多样，我们的方法需要能够同时应对多种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    System.out.println(p.sum(<span class="number">10</span>, <span class="number">20</span>));    <span class="comment">//这里可以正常计算两个整数的和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是要是我们现在不仅要让人类会计算整数，还要会计算小数呢？</p><p><img src="https://s2.loli.net/2022/09/20/m7BvM1RctLznhrA.png" alt="image-20220920102347110"></p><p>当我们使用小数时，可以看到，参数要求的是int类型，那么肯定会出现错误，这个方法只能用于计算整数。此时，为了让这个方法支持使用小数进行计算，我们可以将这个方法进行重载。</p><p>一个类中可以包含多个同名的方法，但是需要的形式参数不一样，方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">sum</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span>&#123;    <span class="comment">//为了支持小数加法，我们可以进行一次重载</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以正常使用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">  <span class="comment">//当方法出现多个重载的情况，在调用时会自动进行匹配，选择合适的方法进行调用</span></span><br><span class="line">    System.out.println(p.sum(<span class="number">1.5</span>, <span class="number">2.2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包括我们之前一直在使用的<code>println</code>方法，其实也是重载了很多次的，因为要支持各种值的打印。</p><p>注意，如果仅仅是返回值的不同，是不支持重载的：</p><p><img src="https://s2.loli.net/2022/09/20/N2TRuqEnxrKbpc8.png" alt="image-20220920102933047"></p><p>当然，方法之间是可以相互调用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是test&quot;</span>);   <span class="comment">//实际上这里也是调用另一个方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">    test();   <span class="comment">//在一个方法内调用另一个方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们这样写的话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    say();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各位猜猜看会出现什么情况？</p><p><img src="https://s2.loli.net/2022/09/21/XPMVa3pdBcFICTE.png" alt="image-20220921001914601"></p><p>此时又出现了一个我们不认识的异常，实际上什么原因导致的我们自己都很清楚，方法之间一直在相互调用，没有一个出口。</p><p>方法自己也可以调用自己：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样自己调用自己的行为，我们称为递归调用，如果直接这样编写，会跟上面一样，出现栈溢出错误。但是如果我们给其合理地设置出口，就不会出现这种问题，比如我们想要计算从1加到n的和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> test(n - <span class="number">1</span>) + n;    <span class="comment">//返回的结果是下一层返回的结果+当前这一层的n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉很巧妙？实际上递归调用在很多情况下能够快速解决一些很麻烦的问题，我们会在后面继续了解。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>我们接着来看一种比较特殊的方法，构造方法。</p><p>我们前面创建对象，都是直接使用<code>new</code>关键字就能直接搞定了，但是我们发现，对象在创建之后，各种属性都是默认值，那么能否实现在对象创建时就为其指定名字、年龄、性别呢？要在对象创建时进行处理，我们可以使用构造方法（构造器）来完成。</p><p>实际上每个类都有一个默认的构造方法，我们可以来看看反编译的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;    <span class="comment">//反编译中，多出来了这样一个方法，这其实就是构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法不需要填写返回值，并且方法名称与类名相同，默认情况下每个类都会自带一个没有任何参数的无参构造方法（只是不用我们去写，编译出来就自带）当然，我们也可以手动声明，对其进行修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    Person()&#123;    <span class="comment">//构造方法不需要指定返回值，并且方法名称与类名相同</span></span><br><span class="line">        name = <span class="string">&quot;小明&quot;</span>;   <span class="comment">//构造方法会在对象创建时执行，我们可以将各种需要初始化的操作都在这里进行处理</span></span><br><span class="line">        age = <span class="number">18</span>;</span><br><span class="line">        sex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法会在new的时候自动执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();   <span class="comment">//这里的new Person()其实就是在调用无参构造方法</span></span><br><span class="line">    System.out.println(p.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们也可以为构造方法设定参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="type">int</span> age, String sex)&#123;   <span class="comment">//跟普通方法是一样的</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在我们自己定义一个构造方法之后，会覆盖掉默认的那一个无参构造方法，除非我们手动重载一个无参构造，否则要创建这个类的对象，必须调用我们自己定义的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);   <span class="comment">//调用自己定义的带三个参数的构造方法</span></span><br><span class="line">    System.out.println(p.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以去看看反编译的结果，会发现此时没有无参构造了，而是只剩下我们自己编写的。</p><p>当然，要给成员变量设定初始值，我们不仅可以通过构造方法，也可以直接在定义时赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;未知&quot;</span>;   <span class="comment">//直接赋值，那么对象构造好之后，属性默认就是这个值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> <span class="string">&quot;男&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要特别注意，成员变量的初始化，并不是在构造方法之前之后，而是在这之前就已经完成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person(String name, <span class="type">int</span> age, String sex)&#123;</span><br><span class="line">    System.out.println(age);    <span class="comment">//在赋值之前看看是否有初始值</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以在类中添加代码块，代码块同样会在对象构造之前进行，在成员变量初始化之后执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是代码块&quot;</span>);   <span class="comment">//代码块中的内容会在对象创建时仅执行一次</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="type">int</span> age, String sex)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我被构造了&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过一般情况下使用代码块的频率比较低，标准情况下还是通过构造方法进行进行对象初始化工作，所以说这里做了解就行了。</p><h3 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a>静态变量和静态方法</h3><p>前面我们已经了解了类的大部分特性，一个类可以具有多种属性、行为，包括对象该如何创建，我们可以通过构造方法进行设定，我们可以通过类创建对象，每个对象都会具有我们在类中设定好的属性，包括我们设定好的行为，所以说类就像是一个模板，我们可以通过这个模板快速捏造出一个又一个的对象。我们接着来看比较特殊的静态特性。</p><p>静态的内容，我们可以理解为是属于这个类的，也可以理解为是所有对象共享的内容。我们通过使用<code>static</code>关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line">    <span class="keyword">static</span> String info;    <span class="comment">//这里我们定义一个info静态变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    p1.info = <span class="string">&quot;杰哥你干嘛&quot;</span>;</span><br><span class="line">    System.out.println(p2.info);   <span class="comment">//可以看到，由于静态属性是属于类的，因此无论通过什么方式改变，都改变的是同一个目标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说一般情况下，我们并不会通过一个具体的对象去修改和使用静态属性，而是通过这个类去使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Person.info = <span class="string">&quot;让我看看&quot;</span>;</span><br><span class="line">    System.out.println(Person.info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，我们可以将方法标记为静态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是静态方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态方法同样是属于类的，而不是具体的某个对象，所以说，就像下面这样：</p><p><img src="https://s2.loli.net/2022/09/20/cWCrJgnkXFL63y2.png" alt="image-20220920234401275"></p><p>因为静态方法属于类的，所以说我们在静态方法中，无法获取成员变量的值：</p><p><img src="https://s2.loli.net/2022/09/20/XvPjtLm2wOMh4ZK.png" alt="image-20220920235418115"></p><p>成员变量是某个具体对象拥有的属性，就像小明这个具体的人的名字才叫小明，而静态方法是类具有的，并不是具体对象的，肯定是没办法访问到的。同样的，在静态方法中，无法使用<code>this</code>关键字，因为this关键字代表的是当前的对象本身。</p><p>但是静态方法是可以访问到静态变量的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String info;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;静态变量的值为：&quot;</span>+info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为他们都属于类，所以说肯定是可以访问到的。</p><p>我们也可以将代码块变成静态的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String info;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;   <span class="comment">//静态代码块可以用于初始化静态变量</span></span><br><span class="line">    info = <span class="string">&quot;测试&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，静态变量，是在什么时候进行初始化的呢？</p><p>我们在一开始介绍了，我们实际上是将<code>.class</code>文件丢给JVM去执行的，而每一个<code>.class</code>文件其实就是我们编写的一个类，我们在Java中使用一个类之前，JVM并不会在一开始就去加载它，而是在需要时才会去加载（优化）一般遇到以下情况时才会会加载类：</p><ul><li>访问类的静态变量，或者为静态变量赋值</li><li>new 创建类的实例（隐式加载）</li><li>调用类的静态方法</li><li>子类初始化时</li><li>其他的情况会在讲到反射时介绍</li></ul><p>所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。</p><p>我们可以来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> test();  <span class="comment">//这里我们用test方法的返回值作为变量的初始值，便于观察</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Person()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是成员变量初始化&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> init();   <span class="comment">//这里我们用init静态方法的返回值作为变量的初始值，便于观察</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是静态变量初始化&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们在主方法中创建一个对象，观察这几步是怎么在执行的：</p><p><img src="https://s2.loli.net/2022/09/21/JxTPk8SWtDmK6IX.png" alt="image-20220921000953525"></p><p>可以看到，确实是静态内容在对象构造之前的就完成了初始化，实际上就是类初始化时完成的。</p><p>当然，如果我们直接访问类的静态变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(Person.info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么此时同样会使得类初始化，进行加载：</p><p><img src="https://s2.loli.net/2022/09/21/auMJOvNfx9K3mzd.png" alt="image-20220921001222465"></p><p>可以看到，在使用时，确实是先将静态内容初始化之后，才得到值的。当然，如果我们压根就没有去使用这个类，那么也不会被初始化了。</p><p>有关类与对象的基本内容，我们就全部讲解完毕了。</p><hr><h2 id="包和访问控制"><a href="#包和访问控制" class="headerlink" title="包和访问控制"></a>包和访问控制</h2><p>通过前面的学习，我们知道该如何创建和使用类。</p><h3 id="包声明和导入"><a href="#包声明和导入" class="headerlink" title="包声明和导入"></a>包声明和导入</h3><p>包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类（类似于C++中的namespace）随着我们的程序不断变大，可能会创建各种各样的类，他们可能会做不同的事情，那么这些类如果都放在一起的话，有点混乱，我们可以通过包的形式将这些类进行分类存放。</p><p>包的命名规则同样是英文和数字的组合，最好是一个域名的格式，比如我们经常访问的<code>www.baidu.com</code>，后面的baidu.com就是域名，我们的包就可以命名为<code>com.baidu</code>，当然，各位小伙伴现在还没有自己的域名，所以说我们随便起一个名称就可以了。其中的<code>.</code>就是用于分割的，对应多个文件夹，比如<code>com.test</code>：</p><p><img src="https://s2.loli.net/2022/09/21/OZdDi1sGluyjbgr.png" alt="image-20220921120040350"></p><p>我们可以将类放入到包中：</p><p><img src="https://s2.loli.net/2022/09/21/e3GvFsHDhMAtBWR.png" alt="image-20220921115055000"></p><p>我们之前都是直接创建的类，所以说没有包这个概念，但是现在，我们将类放到包中，就需要注意了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;   <span class="comment">//在放入包中，需要在类的最上面添加package关键字来指明当前类所处的包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;   <span class="comment">//将Main类放到com.test这个包中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又是一个新的关键字<code>package</code>，这个是用于指定当前类所处的包的，注意，所处的包和对应的目录是一一对应的。</p><p>不同的类可以放在不同的包下：</p><p><img src="https://s2.loli.net/2022/09/21/stOGnxaPirZvjLF.png" alt="image-20220921120241184"></p><p>当我们使用同一个包中的类时，直接使用即可（之前就是直接使用的，因为都直接在一个缺省的包中）而当我们需要使用其他包中的类时，需要先进行导入才可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.test.entity.Person;   <span class="comment">//使用import关键字导入其他包中的类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();   <span class="comment">//只有导入之后才可以使用，否则编译器不知道这个类从哪来的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了<code>import</code>关键字导入我们需要使用的类，当然，只有在类不在同一个包下时才需要进行导入，如果一个包中有多个类，我们可以使用<code>*</code>表示导入这个包中全部的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.test.entity.*;</span><br></pre></td></tr></table></figure><p>实际上我们之前一直在使用的<code>System</code>类，也是在一个包中的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Executable;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.security.AccessControlContext;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.PropertyPermission;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.security.AccessController;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivilegedAction;</span><br><span class="line"><span class="keyword">import</span> java.security.AllPermission;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Channel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.spi.SelectorProvider;</span><br><span class="line"><span class="keyword">import</span> sun.nio.ch.Interruptible;</span><br><span class="line"><span class="keyword">import</span> sun.reflect.CallerSensitive;</span><br><span class="line"><span class="keyword">import</span> sun.reflect.Reflection;</span><br><span class="line"><span class="keyword">import</span> sun.security.util.SecurityConstants;</span><br><span class="line"><span class="keyword">import</span> sun.reflect.annotation.AnnotationType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jdk.internal.util.StaticProperty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &lt;code&gt;System&lt;/code&gt; class contains several useful class fields</span></span><br><span class="line"><span class="comment"> * and methods. It cannot be instantiated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Among the facilities provided by the &lt;code&gt;System&lt;/code&gt; class</span></span><br><span class="line"><span class="comment"> * are standard input, standard output, and error output streams;</span></span><br><span class="line"><span class="comment"> * access to externally defined properties and environment</span></span><br><span class="line"><span class="comment"> * variables; a means of loading files and libraries; and a utility</span></span><br><span class="line"><span class="comment"> * method for quickly copying a portion of an array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  unascribed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   JDK1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">System</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它是属于<code>java.lang</code>这个包下的类，并且这个类也导入了很多其他包中的类在进行使用。那么，为什么我们在使用这个类时，没有导入呢？实际上Java中会默认导入<code>java.lang</code>这个包下的所有类，因此我们不需要手动指定。</p><p>IDEA非常智能，我们在使用项目中定义的类时，会自动帮我们将导入补全，所以说代码写起来非常高效。</p><p>注意，在不同包下的类，即使类名相同，也是不同的两个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;    <span class="comment">//我们在自己的包中也建一个名为String的类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在使用时：</p><p>![image-20220921121404900](/Users/nagocoler/Library/Application Support/typora-user-images/image-20220921121404900.png)</p><p>由于默认导入了系统自带的String类，并且也导入了我们自己定义的String类，那么此时就出现了歧义，编译器不知道到底我们想用的是哪一个String类，所以说我们需要明确指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[] args)</span> &#123;   <span class="comment">//主方法的String参数是java.lang包下的，我们需要明确指定一下，只需要在类名前面添加包名就行了</span></span><br><span class="line">com.test.entity.<span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.test.entity.String();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要在类名前面把完整的包名也给写上，就可以表示这个是哪一个包里的类了，当然，如果没有出现歧义，默认情况下包名是可以省略的，可写可不写。</p><p>可能各位小伙伴会发现一个问题，为什么对象的属性访问不了了？</p><p><img src="https://s2.loli.net/2022/09/21/UaqMihmIQkzHFtG.png" alt="image-20220921122514457"></p><p>编译器说name属性在这个类中不是public，无法在外部进行访问，这是什么情况呢？这里我们就要介绍的到Java的访问权限控制了。</p><h3 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h3><p>实际上Java中是有访问权限控制的，就是我们个人的隐私的一样，我不允许别人随便来查看我们的隐私，只有我们自己同意的情况下，才能告诉别人我们的名字、年龄等隐私信息。</p><p>所以说Java中引入了访问权限控制（可见性），我们可以为成员变量、成员方法、静态变量、静态方法甚至是类指定访问权限，不同的访问权限，有着不同程度的访问限制：</p><ul><li><code>private</code>   -   私有，标记为私有的内容无法被除当前类以外的任何位置访问。</li><li><code>什么都不写</code>   -   默认，默认情况下，只能被类本身和同包中的其他类访问。</li><li><code>protected</code>   -   受保护，标记为受保护的内容可以能被类本身和同包中的其他类访问，也可以被子类访问（子类我们会在下一章介绍）</li><li><code>public</code>    -   公共，标记为公共的内容，允许在任何地方被访问。</li></ul><p>这四种访问权限，总结如下表：</p><table><thead><tr><th align="center"></th><th align="center">当前类</th><th align="center">同一个包下的类</th><th align="center">不同包下的子类</th><th align="center">不同包下的类</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td align="center">protected</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">❌</td></tr><tr><td align="center">默认</td><td align="center">✅</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">private</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr></tbody></table><p>比如我们刚刚出现的情况，就是因为是默认的访问权限，所以说在当前包以外的其他包中无法访问，但是我们可以提升它的访问权限，来使得外部也可以访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;   <span class="comment">//在name变量前添加public关键字，将其可见性提升为公共等级</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以在外部正常使用这个属性了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    System.out.println(person.name);   <span class="comment">//正常访问到成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上如果各位小伙伴观察仔细的话，会发现我们创建出来的类自带的访问等级就是<code>public</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;   <span class="comment">//class前面有public关键字</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说这个类实际上可以在任何地方使用，但是我们也可以将其修改为默认的访问等级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;    <span class="comment">//去掉public变成默认等级</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是默认等级的话，那么在外部同样是无法访问的：</p><p><img src="https://s2.loli.net/2022/09/21/ZTRAEItQY6UcqvP.png" alt="image-20220921142724239"></p><p>但是注意，我们创建的普通类不能是<code>protected</code>或是<code>private</code>权限，因为我们目前所使用的普通类要么就是只给当前的包内使用，要么就是给外面都用，如果是<code>private</code>谁都不能用，那这个类定义出来干嘛呢？</p><p>如果某个类中存在静态方法或是静态变量，那么我们可以通过静态导入的方式将其中的静态方法或是静态变量直接导入使用，但是同样需要有访问权限的情况下才可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是静态方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来尝试一下静态导入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.test.entity.Person.test;    <span class="comment">//静态导入test方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test();    <span class="comment">//直接使用就可以，就像在这个类定义的方法一样</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，有关包相关的内容，我们就讲解到这里。</p><hr><h2 id="封装、继承和多态"><a href="#封装、继承和多态" class="headerlink" title="封装、继承和多态"></a>封装、继承和多态</h2><p>封装、继承和多态是面向对象编程的三大特性。</p><blockquote><p>封装，把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。</p><p>继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展出新的行为。</p><p>多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的方法。</p></blockquote><p>正是这三大特性，让我们的Java程序更加生动形象。</p><h3 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h3><p>封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要使用Getter和Setter方法来查看和设置变量。</p><p>我们可以将之前的类进行改进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">//现在类的属性只能被自己直接访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;   <span class="comment">//构造方法也要声明为公共，否则对象都构造不了</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;    <span class="comment">//想要知道这个对象的名字，必须通过getName()方法来获取，并且得到的只是名字值，外部无法修改</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以来试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    System.out.println(person.getName());    <span class="comment">//只能通过调用getName()方法来获取名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，外部现在只能通过调用我定义的方法来获取成员属性，而我们可以在这个方法中进行一些额外的操作，比如小明可以修改名字，但是名字中不能包含”小”这个字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(name.contains(<span class="string">&quot;小&quot;</span>)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们甚至还可以将构造方法改成私有的，需要通过我们的内部的方式来构造对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">()</span>&#123;&#125;   <span class="comment">//不允许外部使用new关键字创建对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title function_">getInstance</span><span class="params">()</span> &#123;   <span class="comment">//而是需要使用我们的独特方法来生成对象并返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，我们可以实现单例模式：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单例模式就是全局只能使用这一个对象，不能创建更多的对象，我们就可以封装成这样，关于单例模式的详细介绍，还请各位小伙伴在《Java设计模式》视频教程中再进行学习。</p></blockquote><p>封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现，要用什么由类自己来做，不需要外面来操作类内部的东西去完成，封装就是通过访问权限控制来实现的。</p><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>前面我们介绍了类的封装，我们接着来看一个非常重要特性：继承。</p><p>在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中<strong>非私有</strong>的成员。</p><p>比如说我们一开始使用的人类，那么实际上人类根据职业划分，所掌握的技能也会不同，比如画家会画画，歌手会唱，舞者会跳，Rapper会rap，运动员会篮球，我们可以将人类这个大类根据职业进一步地细分出来：</p><p><img src="https://s2.loli.net/2022/09/21/zlZ9JXAjvxpawPF.png" alt="image-20220921150139125"></p><p>实际上这些划分出来的类，本质上还是人类，也就是说人类具有的属性，这些划分出来的类同样具有，但是，这些划分出来的类同时也会拥有他们自己独特的技能。在Java中，我们可以创建一个类的子类来实现上面的这种效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;   <span class="comment">//先定义一个父类</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们可以创建各种各样的子类，想要继承一个类，我们只需要使用<code>extends</code>关键字即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;    <span class="comment">//工人类</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;   <span class="comment">//学生类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的继承可以不断向下，但是同时只能继承一个类，同时，标记为<code>final</code>的类不允许被继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;  <span class="comment">//class前面添加final关键字表示这个类已经是最终形态，不能继承</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个类继承另一个类时，属性会被继承，可以直接访问父类中定义的属性，除非父类中将属性的访问权限修改为<code>private</code>，那么子类将无法访问（但是依然是继承了这个属性的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的名字是 &quot;</span>+name+<span class="string">&quot;，我在学习！&quot;</span>);   <span class="comment">//可以直接访问父类中定义的name属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，在父类中定义的方法同样会被子类继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我叫 &quot;</span>+name+<span class="string">&quot;，今年 &quot;</span>+age+<span class="string">&quot; 岁了!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类直接获得了此方法，当我们创建一个子类对象时就可以直接使用这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    student.study();    <span class="comment">//子类不仅有自己的独特技能</span></span><br><span class="line">    student.hello();    <span class="comment">//还继承了父类的全部技能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉非常人性化，子类继承了父类的全部能力，同时还可以扩展自己的独特能力，就像一句话说的： 龙生龙凤生凤，老鼠儿子会打洞。</p><p>如果父类存在一个有参构造方法，子类必须在构造方法中调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;   <span class="comment">//因为子类需要用这些属性，所以说我们就将这些变成protected，外部不允许访问</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">protected</span> String sex;</span><br><span class="line">    <span class="keyword">protected</span> String profession;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造方法也改成protected，只能子类用</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, String sex, String profession)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.profession = profession;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span>+profession+<span class="string">&quot;] 我叫 &quot;</span>+name+<span class="string">&quot;，今年 &quot;</span>+age+<span class="string">&quot; 岁了!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，此时两个子类都报错了：</p><p><img src="https://s2.loli.net/2022/09/21/SgPjRtUN64bmWrX.png" alt="image-20220921153512798"></p><p>因为子类在构造时，不仅要初始化子类的属性，还需要初始化父类的属性，所以说在默认情况下，子类其实是调用了父类的构造方法的，只是在无参的情况下可以省略，但是现在父类构造方法需要参数，那么我们就需要手动指定了：</p><p>既然现在父类需要三个参数才能构造，那么子类需要按照同样的方式调用父类的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;    <span class="comment">//因为学生职业已经确定，所以说学生直接填写就可以了</span></span><br><span class="line">        <span class="built_in">super</span>(name, age, sex, <span class="string">&quot;学生&quot;</span>);   <span class="comment">//使用super代表父类，父类的构造方法就是super()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的名字是 &quot;</span>+name+<span class="string">&quot;，我在学习！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age, sex, <span class="string">&quot;工人&quot;</span>);    <span class="comment">//父类构造调用必须在最前面</span></span><br><span class="line">        System.out.println(<span class="string">&quot;工人构造成功！&quot;</span>);    <span class="comment">//注意，在调用父类构造方法之前，不允许执行任何代码，只能在之后执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在使用子类时，可以将其当做父类来使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);    <span class="comment">//这里使用父类类型的变量，去引用一个子类对象（向上转型）</span></span><br><span class="line">    person.hello();    <span class="comment">//父类对象的引用相当于当做父类来使用，只能访问父类对象的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们这里使用的是父类类型引用的对象，但是这并不代表子类就彻底变成父类了，这里仅仅只是当做父类使用而已。</p><p>我们也可以使用强制类型转换，将一个被当做父类使用的子类对象，转换回子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) person;   <span class="comment">//使用强制类型转换（向下转型）</span></span><br><span class="line">    student.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是注意，这种方式只适用于这个对象本身就是对应的子类才可以，如果本身都不是这个子类，或者说就是父类，那么会出现问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);   <span class="comment">//实际创建的是Work类型的对象</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) person;</span><br><span class="line">    student.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/21/JdMLt19Yq6KQz4v.png" alt="image-20220921160309835"></p><p>此时直接出现了类型转换异常，因为本身不是这个类型，强转也没用。</p><p>那么如果我们想要判断一下某个变量所引用的对象到底是什么类，那么该怎么办呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(person <span class="keyword">instanceof</span> Student) &#123;   <span class="comment">//我们可以使用instanceof关键字来对类型进行判断</span></span><br><span class="line">        System.out.println(<span class="string">&quot;对象是 Student 类型的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(person <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象是 Person 类型的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果变量所引用的对象是对应类型或是对应类型的子类，那么<code>instanceof</code>都会返回<code>true</code>，否则返回<code>false</code>。</p><p>最后我们需要来特别说明一下，子类是可以定义和父类同名的属性的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;   <span class="comment">//子类中同样可以定义name属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age, sex, <span class="string">&quot;工人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时父类的name属性和子类的name属性是同时存在的，那么当我们在子类中直接使用时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是 &quot;</span>+name+<span class="string">&quot;，我在工作！&quot;</span>);   <span class="comment">//这里的name，依然是作用域最近的哪一个，也就是在当前子类中定义的name属性，而不是父类的name属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，我们在使用时，实际上这里得到的结果为<code>null</code>：</p><p><img src="https://s2.loli.net/2022/09/21/nKDaTJZ2LhEX3Hs.png" alt="image-20220921160742714"></p><p>那么，在子类存在同名变量的情况下，怎么去访问父类的呢？我们同样可以使用<code>super</code>关键字来表示父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是 &quot;</span>+<span class="built_in">super</span>.name+<span class="string">&quot;，我在工作！&quot;</span>);   <span class="comment">//这里使用super.name来表示需要的是父类的name变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样得到的结果就不一样了：</p><p><img src="https://s2.loli.net/2022/09/21/DobHL2CWRMIif3z.png" alt="image-20220921160851193"></p><p>但是注意，没有<code>super.super</code>这种用法，也就是说如果存在多级继承的话，那么最多只能通过这种方法访问到父类的属性（包括继承下来的属性）</p><h3 id="顶层Object类"><a href="#顶层Object类" class="headerlink" title="顶层Object类"></a>顶层Object类</h3><p>实际上所有类都默认继承自Object类，除非手动指定继承的类型，但是依然改变不了最顶层的父类是Object类。所有类都包含Object类中的方法，比如：</p><p><img src="https://s2.loli.net/2022/09/21/FCHDEI4rTAQquas.png" alt="image-20220921214642969"></p><p>我们发现，除了我们自己在类中编写的方法之外，还可以调用一些其他的方法，那么这些方法不可能无缘无故地出现，肯定同样是因为继承得到的，那么这些方法是继承谁得到的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Object</span>&#123;   </span><br><span class="line"><span class="comment">//除非我们手动指定要继承的类是什么，实际上默认情况下所有的类都是继承自Object的，只是可以省略</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说我们的继承结构差不多就是：</p><p><img src="https://s2.loli.net/2022/09/21/hkapOYVHBrjy7UC.png" alt="image-20220921214944267"></p><p>既然所有的类都默认继承自Object，我们来看看这个类里面有哪些内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;   <span class="comment">//标记为native的方法是本地方法，底层是由C++实现的</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();   <span class="comment">//这个类在初始化时会对类中其他本地方法进行注册，本地方法不是我们SE中需要学习的内容，我们会在JVM篇视频教程中进行介绍</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前的类型Class对象，这个我们会在最后一章的反射中进行讲解，目前暂时不会用到</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取对象的哈希值，我们会在第五章集合类中使用到，目前各位小伙伴就暂时理解为会返回对象存放的内存地址</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断当前对象和给定对象是否相等，默认实现是直接用等号判断，也就是直接判断是否为同一个对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//克隆当前对象，可以将复制一个完全一样的对象出来，包括对象的各个属性</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将当前对象转换为String的形式，默认情况下格式为 完整类名@十六进制哈希值</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//唤醒一个等待当前对象锁的线程，有关锁的内容，我们会在第六章多线程部分中讲解，目前暂时不会用到</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//唤醒所有等待当前对象锁的线程，同上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使得持有当前对象锁的线程进入等待状态，同上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当对象被判定为已经不再使用的“垃圾”时，在回收之前，会由JVM来调用一次此方法进行资源释放之类的操作，这同样不是SE中需要学习的内容，这个方法我们会在JVM篇视频教程中详细介绍，目前暂时不会用到</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以尝试调用一下Object为我们提供的<code>toString()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> person.toString();</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是按照上面说的格式进行打印：</p><p><img src="https://s2.loli.net/2022/09/21/hpBOjqf4iwJW1Pr.png" alt="image-20220921221053801"></p><p>当然，我们直接可以给<code>println</code>传入一个Object类型的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(Object x)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(x);   <span class="comment">//这里同样会调用对象的toString方法，所以说跟上面效果是一样的</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        print(s);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有小伙伴肯定会好奇，这里不是接受的一个Object类型的值的，为什么任意类型都可以传入呢？因为所有类型都是继承自Object，如果方法接受的参数是一个引用类型的值，那只要是这个类的对象或是这个类的子类的对象，都可以作为参数传入。</p><p>我们也可以试试看默认提供的<code>equals</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    System.out.println(p1.equals(p2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为默认比较的是两个对象是否为同一个对象，所以说这里得到的肯定是false，但是有些情况下，实际上我们所希望的情况是如果名字、年龄、性别都完全相同，那么这肯定是同一个人，但是这里却做不到这样的判断，我们需要修改一下<code>equals</code>方法的默认实现来完成，这就要用到方法的重写了。</p><h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><p>注意，方法的重写不同于之前的方法重载，不要搞混了，方法的重载是为某个方法提供更多种类，而方法的重写是覆盖原有的方法实现，比如我们现在不希望使用Object类中提供的<code>equals</code>方法，那么我们就可以将其重写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//重写方法可以添加 @Override 注解，有关注解我们会在最后一章进行介绍，这个注解默认情况下可以省略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;   <span class="comment">//重写方法要求与父类的定义完全一致</span></span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//如果传入的对象为null，那肯定不相等</span></span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person) &#123;     <span class="comment">//只有是当前类型的对象，才能进行比较，要是都不是这个类型还比什么</span></span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) obj;   <span class="comment">//先转换为当前类型，接着我们对三个属性挨个进行比较</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name.equals(person.name) &amp;&amp;    <span class="comment">//字符串内容的比较，不能使用==，必须使用equals方法</span></span><br><span class="line">                    <span class="built_in">this</span>.age == person.age &amp;&amp;       <span class="comment">//基本类型的比较跟之前一样，直接==</span></span><br><span class="line">                    <span class="built_in">this</span>.sex.equals(person.sex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在重写Object提供的<code>equals</code>方法之后，就会按照我们的方式进行判断了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    System.out.println(p1.equals(p2));   <span class="comment">//此时由于三个属性完全一致，所以说判断结果为真，即使是两个不同的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候为了方便查看对象的各个属性，我们可以将Object类提供的<code>toString</code>方法重写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;    <span class="comment">//使用IDEA可以快速生成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">            <span class="string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, profession=&#x27;&quot;</span> + profession + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们直接打印对象时，就会打印出对象的各个属性值了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/21/FCAnxSUjhaLuXW8.png" alt="image-20220921223249343"></p><p>注意，静态方法不支持重写，因为它是属于类本身的，但是它可以被继承。</p><p>基于这种方法可以重写的特性，对于一个类定义的行为，不同的子类可以出现不同的行为，比如考试，学生考试可以得到A，而工人去考试只能得到D：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是考试方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是学生，我就是小镇做题家，拿个 A 轻轻松松&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是工人，做题我并不擅长，只能得到 D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，不同的子类，对于同一个方法会产生不同的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    person.exam();</span><br><span class="line"></span><br><span class="line">    person = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;小强&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    person.exam();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/21/zogT67B91tJaHLD.png" alt="image-20220921224525855"></p><p>这其实就是面向对象编程中多态特性的一种体现。</p><p>注意，我们如果不希望子类重写某个方法，我们可以在方法前添加<code>final</code>关键字，表示这个方法已经是最终形态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是考试方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/21/zpKfDlGTLwx5iy8.png" alt="image-20220921224907373"></p><p>或者，如果父类中方法的可见性为<code>private</code>，那么子类同样无法访问，也就不能重写，但是可以定义同名方法：</p><p><img src="https://s2.loli.net/2022/09/21/d9k21hyGL6WExZ3.png" alt="image-20220921225651487"></p><p>虽然这里可以编译通过，但是并不是对父类方法的重写，仅仅是子类自己创建的一个新方法。</p><p>还有，我们在重写父类方法时，如果希望调用父类原本的方法实现，那么同样可以使用<code>super</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.exam();   <span class="comment">//调用父类的实现</span></span><br><span class="line">    System.out.println(<span class="string">&quot;我是工人，做题我并不擅长，只能得到 D&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是访问权限的问题，子类在重写父类方法时，不能降低父类方法中的可见性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是考试方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/21/zfhZ3YdFeCgJu89.png" alt="image-20220921225234226"></p><p>因为子类实际上可以当做父类使用，如果子类的访问权限比父类还低，那么在被当做父类使用时，就可能出现无视访问权限调用的情况，这样肯定是不行的，但是相反的，我们可以在子类中提升权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是考试方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span> &#123;   <span class="comment">//将可见性提升为public </span></span><br><span class="line">    System.out.println(<span class="string">&quot;我是工人，做题我并不擅长，只能得到 D&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/21/igvGNTQs2xKOZrI.png" alt="image-20220921225840122"></p><p>可以看到作为子类时就可以正常调用，但是如果将其作为父类使用，因为访问权限不足所有就无法使用，总之，子类重写的方法权限不能比父类还低。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在我们学习了类的继承之后，实际上我们会发现，越是处于顶层定义的类，实际上可以进一步地进行抽象，比如我们前面编写的考试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是考试方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法再子类中一定会被重写，所以说除非子类中调用父类的实现，否则一般情况下永远都不会被调用，就像我们说一个人会不会考试一样，实际上人怎么考试是一个抽象的概念，而学生怎么考试和工人怎么考试，才是具体的一个实现，所以说，我们可以将人类进行进一步的抽象，让某些方法完全由子类来实现，父类中不需要提供实现。</p><p>要实现这样的操作，我们可以将人类变成抽象类，抽象类比类还要抽象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;   <span class="comment">//通过添加abstract关键字，表示这个类是一个抽象类</span></span><br><span class="line">    <span class="keyword">protected</span> String name;   <span class="comment">//大体内容其实普通类差不多</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">protected</span> String sex;</span><br><span class="line">    <span class="keyword">protected</span> String profession;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, String sex, String profession)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.profession = profession;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span>;   <span class="comment">//抽象类中可以具有抽象方法，也就是说这个方法只有定义，没有方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而具体的实现，需要由子类来完成，而且如果是子类，必须要实现抽象类中所有抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age, sex, <span class="string">&quot;工人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span> &#123;   <span class="comment">//子类必须要实现抽象类所有的抽象方法，这是强制要求的，否则会无法通过编译</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我是工人，做题我并不擅长，只能得到 D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类由于不是具体的类定义（它是类的抽象）可能会存在某些方法没有实现，因此无法直接通过new关键字来直接创建对象：</p><p><img src="https://s2.loli.net/2022/09/21/GLQU8hANw36P5J7.png" alt="image-20220921231744420"></p><p>要使用抽象类，我们只能去创建它的子类对象。</p><p>抽象类一般只用作继承使用，当然，抽象类的子类也可以是一个抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;   <span class="comment">//如果抽象类的子类也是抽象类，那么可以不用实现父类中的抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age, sex, <span class="string">&quot;学生&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//抽象类中并不是只能有抽象方法，抽象类中也可以有正常方法的实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是学生，我就是小镇做题家，拿个 A 轻轻松松&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，抽象方法的访问权限不能为<code>private</code>：</p><p><img src="https://s2.loli.net/2022/09/21/1ZJSRU2Aj5K9Ikv.png" alt="image-20220921232435056"></p><p>因为抽象方法一定要由子类实现，如果子类都访问不了，那么还有什么意义呢？所以说不能为私有。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！接口一般只代表某些功能的抽象，接口包含了一些列方法的定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）</p><p>咋一看，这啥意思啊，什么叫支持接口代表的功能？实际上接口的目标就是将类所具有某些的行为抽象出来。</p><p>比如说，对于人类的不同子类，学生和老师来说，他们都具有学习这个能力，既然都有，那么我们就可以将学习这个能力，抽象成接口来进行使用，只要是实现这个接口的类，都有学习的能力：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Study</span> &#123;    <span class="comment">//使用interface表示这是一个接口</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>;    <span class="comment">//接口中只能定义访问权限为public抽象方法，其中public和abstract关键字可以省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以让类实现这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Study</span> &#123;   <span class="comment">//使用implements关键字来实现接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age, sex, <span class="string">&quot;学生&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;    <span class="comment">//实现接口时，同样需要将接口中所有的抽象方法全部实现</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我会学习！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Teacher</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age, sex, <span class="string">&quot;教师&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我会加倍学习！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口不同于继承，接口可以同时实现多个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Study</span>, A, B, C &#123;  <span class="comment">//多个接口的实现使用逗号隔开</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说有些人说接口其实就是Java中的多继承，但是我个人认为这种说法是错的，实际上实现接口更像是一个类的功能列表，作为附加功能存在，一个类可以附加很多个功能，接口的使用和继承的概念有一定的出入，顶多说是多继承的一种替代方案。</p><p>接口跟抽象类一样，不能直接创建对象，但是我们也可以将接口实现类的对象以接口的形式去使用：</p><p><img src="https://s2.loli.net/2022/09/21/VJfhzYKuF38tRq4.png" alt="image-20220921234735828"></p><p>当做接口使用时，只有接口中定义的方法和Object类的方法，无法使用类本身的方法和父类的方法。</p><p>接口同样支持向下转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;小王&quot;</span>, <span class="number">27</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(study <span class="keyword">instanceof</span> Teacher) &#123;   <span class="comment">//直接判断引用的对象是不是Teacher类型</span></span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> (Teacher) study;   <span class="comment">//强制类型转换</span></span><br><span class="line">        teacher.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的使用其实跟之前的父类是差不多的。</p><p>从Java8开始，接口中可以存在方法的默认实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;   <span class="comment">//使用default关键字为接口中的方法添加默认实现</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我是默认实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果方法在接口中存在默认实现，那么实现类中不强制要求进行实现。</p><p>接口不同于类，接口中不允许存在成员变量和成员方法，但是可以存在静态变量和静态方法，在接口中定义的变量只能是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;   <span class="comment">//接口中定义的静态变量只能是public static final的</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;    <span class="comment">//接口中定义的静态方法也只能是public的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我是静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟普通的类一样，我们可以直接通过接口名.的方式使用静态内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(Study.a);</span><br><span class="line">    Study.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口是可以继承自其他接口的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> exetnds B &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且接口没有继承数量限制，接口支持多继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> exetnds B, C, D &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的继承相当于是对接口功能的融合罢了。</p><p>最后我们来介绍一下Object类中提供的克隆方法，为啥要留到这里才来讲呢？因为它需要实现接口才可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cloneable</span> &#123;    <span class="comment">//这个接口中什么都没定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现接口后，我们还需要将克隆方法的可见性提升一下，不然还用不了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Study</span>, Cloneable &#123;   <span class="comment">//首先实现Cloneable接口，表示这个类具有克隆的功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age, sex, <span class="string">&quot;学生&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;   <span class="comment">//提升clone方法的访问权限</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();   <span class="comment">//因为底层是C++实现，我们直接调用父类的实现就可以了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我会学习！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来尝试一下，看看是不是会得到一个一模一样的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;  <span class="comment">//这里向上抛出一下异常，还没学异常，所以说照着写就行了</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">clone</span> <span class="operator">=</span> (Student) student.clone();   <span class="comment">//调用clone方法，得到一个克隆的对象</span></span><br><span class="line">    System.out.println(student);</span><br><span class="line">    System.out.println(clone);</span><br><span class="line">    System.out.println(student == clone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，原对象和克隆对象，是两个不同的对象，但是他们的各种属性都是完全一样的：</p><p><img src="https://s2.loli.net/2022/09/22/E3dNFYT5sWaS8Rx.png" alt="image-20220922110044636"></p><p>通过实现接口，我们就可以很轻松地完成对象的克隆了，在我们之后的学习中，还会经常遇到接口的使用。</p><p><strong>注意：</strong>以下内容为选学内容，在设计模式篇视频教程中有详细介绍。</p><blockquote><p>克隆操作可以完全复制一个对象的所有属性，但是像这样的拷贝操作其实也分为浅拷贝和深拷贝。</p><ul><li><strong>浅拷贝：</strong>对于类中基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象，拷贝个基莫。 </li><li><strong>深拷贝：</strong>无论是基本类型还是引用类型，深拷贝会将引用类型的所有内容，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝。</li></ul><p>那么clone方法出来的克隆对象，是深拷贝的结果还是浅拷贝的结果呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">clone</span> <span class="operator">=</span> (Student) student.clone();</span><br><span class="line">    System.out.println(student.name == clone.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/22/gpM1iukyoSdn2RE.png" alt="image-20220922110750697"></p><p>可以看到，虽然Student对象成功拷贝，但是其内层对象并没有进行拷贝，依然只是对象引用的复制，所以Java为我们提供的<code>clone</code>方法只会进行浅拷贝。</p></blockquote><hr><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>假设现在我们想给小明添加一个状态（跑步、学习、睡觉），外部可以实时获取小明的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Study</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String status;   <span class="comment">//状态，可以是跑步、学习、睡觉这三个之中的其中一种</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(String status)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样会出现一个问题，如果我们仅仅是存储字符串，似乎外部可以不按照我们规则，传入一些其他的字符串。这显然是不够严谨的，有没有一种办法，能够更好地去实现这样的状态标记呢？我们希望开发者拿到使用的就是我们预先定义好的状态，所以，我们可以使用枚举类来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;   <span class="comment">//enum表示这是一个枚举类，枚举类的语法稍微有一些不一样</span></span><br><span class="line">    RUNNING, STUDY, SLEEP;    <span class="comment">//直接写每个状态的名字即可，最后面分号可以不打，但是推荐打上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举类也非常方便，就像使用普通类型那样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Status status;   <span class="comment">//类型变成刚刚定义的枚举类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Status <span class="title function_">getStatus</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(Status status)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.status = status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，别人在使用时，就能很清楚地知道我们支持哪些了：</p><p><img src="https://s2.loli.net/2022/09/22/6SDXckyIfFoCZWg.png" alt="image-20220922111426974"></p><p>枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自<code>Enum</code>类，我们定义的每一个状态其实就是一个<code>public static final</code>的Status类型成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里使用javap命令对class文件进行反编译得到 Compiled from &quot;Status.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">com</span>.test.Status <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;com.test.Status&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.test.Status RUNNING;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.test.Status STUDY;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.test.Status SLEEP;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.test.Status[] values();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.test.Status <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    RUNNING(<span class="string">&quot;睡觉&quot;</span>), STUDY(<span class="string">&quot;学习&quot;</span>), SLEEP(<span class="string">&quot;睡觉&quot;</span>);   <span class="comment">//无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;    <span class="comment">//枚举的成员变量</span></span><br><span class="line">    Status(String name)&#123;    <span class="comment">//覆盖原有构造方法（默认private，只能内部使用！）</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;   <span class="comment">//获取封装的成员变量</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，枚举就可以按照我们想要的中文名称打印了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    student.setStatus(Status.RUNNING);</span><br><span class="line">    System.out.println(student.getStatus().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类还自带一些继承下来的实用方法，比如获取枚举类中的所有枚举，只不过这里用到了数组，我们会在下一章进行介绍。</p><p>至此，面向对象基础内容就全部讲解完成了，下一章我们还将继续讲解面向对象的其他内容。</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="java" scheme="https://www.hoveco.top/categories/java/"/>
    
    
    <category term="JavaSE" scheme="https://www.hoveco.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-学习笔记-面向过程（二）</title>
    <link href="https://www.hoveco.top/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/"/>
    <id>https://www.hoveco.top/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</id>
    <published>2023-10-12T00:30:00.000Z</published>
    <updated>2023-10-12T14:49:21.693Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/09/16/ymtrNQlPu9Loh27.png" alt="image-20220916174714019"></p><h1 id="面向过程篇"><a href="#面向过程篇" class="headerlink" title="面向过程篇"></a>面向过程篇</h1><p>前面我们已经认识了Java语言的相关特性，并且已经成功配置好了开发环境，从这节课开始，我们就可以正式进入到Java语言的学习当中了。Java语言是一门面向对象的语言，但是在面向对象之前，我们还得先学会如何面向过程编程。</p><h2 id="Java程序基础"><a href="#Java程序基础" class="headerlink" title="Java程序基础"></a>Java程序基础</h2><p>首先我们还是从最基本的Java程序基础开始讲解。</p><h3 id="程序代码基本结构"><a href="#程序代码基本结构" class="headerlink" title="程序代码基本结构"></a>程序代码基本结构</h3><p>还记得我们之前使用的示例代码吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码要实现的功能很简单，就是将 Hello World 输出到控制台就行。</p><p>由于我们还没有学习到类的相关性质，所以在第二章之前，各位小伙伴直接记住固定模式即可，首先我们创建的源文件名称需要为<code>Main.java</code>然后编写的代码第一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意需要区分大小写，Java语言严格区分大小写，如果我们没有按照规则来编写，那么就会出现红色波浪线报错：</p><p><img src="https://s2.loli.net/2022/09/16/5mpBD1JyjCMGgnO.png" alt="image-20220916213529426"></p><p>只要源代码中存在报错的地方，就无法正常完成编译得到二进制文件，会提示构建失败：</p><p><img src="https://s2.loli.net/2022/09/16/x5PjR9OAGMCQtS6.png" alt="image-20220916213641899"></p><p>注意最后还有一个花括号，并且此花括号是成对出现的，一一对应。</p><p>所以说各位小伙伴在编写代码时一定要注意大小写。然后第二行，准确的说是最外层花括号内部就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们整个Java程序的入口点，我们称为主方法（如果你学习过C肯定能够联想到主函数，只不过Java中不叫函数，叫方法）最后也会有一个花括号成对出现，而在主方法的花括号中编写的代码，就是按照从上往下的顺序依次执行的。</p><p>比如我们之前编写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure><p>这段代码的意思就是将双引号括起来的内容（字符串，我们会在后面进行讲解）输出（打印）到控制台上，可以看到最后还加上了一个<code>;</code>符号，表示这一句代码结束。我们每一段代码结束时都需要加上一个分号表示这一句的结束，就像我们写作文一样。</p><p>比如下面的代码，我们就可以实现先打印Hello World!，然后再打印YYDS!到控制台。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;YYDS!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://s2.loli.net/2022/09/16/GLZdxf6B3Agu98N.png" alt="image-20220916214557378"></p><p>如果两段代码没有加上分号分割，那么编译器会认为这两段代码是同一句代码中的，即使出现换行或者是空格：</p><p><img src="https://s2.loli.net/2022/09/16/ErQnpo2DVw7mJks.png" alt="image-20220916214736541"></p><p>这里IDEA很聪明，会提醒我们这里少加了分号，所以说这个IDEA能够在初期尽可能地帮助新手。</p><p>再比如下面的代码：</p><p><img src="https://s2.loli.net/2022/09/16/sDcuan8MJ92l3P1.png" alt="image-20220916214822072"></p><p><img src="https://s2.loli.net/2022/09/16/i1VFk6RUtp8XfMr.png" alt="image-20220916214929651"></p><p>这里我们尝试在中途换行和添加空格，因为没有添加分号，所以说编译器依然会认为是一行代码，因此编译不会出现错误，能够正常通过。当然，为了代码写得工整和规范，我们一般不会随意进行换行编写或者是添加没必要的空格。</p><p>同样的，如果添加了分号，即使在同一行，也会被认为是两句代码：</p><p><img src="https://s2.loli.net/2022/09/16/XopC59keJiMWjmd.png" alt="image-20220916221833145"></p><p>如果在同一行就是从左往右的顺序，得到的结果跟上面是一样的。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>我们在编写代码时，可能有些时候需要标记一下这段代码表示什么意思：</p><p><img src="https://s2.loli.net/2022/09/16/8Mzo36BbYVuRgm9.png" alt="image-20220916221711430"></p><p>但是如果直接写上文字的话，会导致编译不通过，因为这段文字也会被认为是程序的一部分。</p><p>这种情况，我们就可以告诉编译器，这段文字是我们做的笔记，并不是程序的一部分，那么要怎么告诉编译器这不是代码呢？很简单，我们只需要在前面加上双斜杠就可以了：</p><p><img src="https://s2.loli.net/2022/09/16/N4rZHt6onGfXuhg.png" alt="image-20220916222035778"></p><p>添加双斜杠之后（自动变成了灰色），后续的文本内容只要没有发生换行，那么都会被认为是一段注释，并不属于程序，在编译时会被直接忽略，之后这段注释也不会存在于程序中。但是一旦发生换行那就不行了：</p><p><img src="https://s2.loli.net/2022/09/16/GiUMCmXewanWJSN.png" alt="image-20220916222225047"></p><p>那要是此时注释很多，一行写不完，我们想要编写很多行的注释呢？我们可以使用多行注释标记：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这里面的内容</span></span><br><span class="line"><span class="comment">            无论多少行</span></span><br><span class="line"><span class="comment">            都可以</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多行可以使用<code>/*</code>和<code>*/</code>的组合来囊括需要编写的注释内容。</p><p>当然还有一种方式就是使用<code>/**</code>来进行更加详细的文档注释：</p><p><img src="https://s2.loli.net/2022/09/16/sFhkS2ezONjZvMK.png" alt="image-20220916222636943"></p><p>这种注释可以用来自动生成文档，当我们鼠标移动到Main上时，会显示相关的信息，我们可以自由添加一些特殊的注释，比如作者、时间等信息，也可以是普通的文字信息。</p><h3 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h3><p>我们的程序不可能永远都只进行上面那样的简单打印操作，有些时候可能需要计算某些数据，此时我们就需要用到变量了。</p><p>那么，什么是变量呢？我们在数学中其实已经学习过变量了：</p><blockquote><p>变量，指值可以变的量。变量以非<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97/6204?fromModule=lemma_inlink">数字</a>的符号来表达，一般用拉丁字母。变量的用处在于能一般化描述指令的方式。结果只能使用真实的值，指令只能应用于某些情况下。变量能够作为某特定种类的值中任何一个的保留器。</p></blockquote><p>比如一个公式 $x^2 + 6 = 22$ 此时<code>x</code>就是一个变量，变量往往代表着某个值，比如这里的<code>x</code>就代表的是4这个值。在Java中，我们也可以让变量去代表一个具体的值，并且变量的值是可以发生变化的。</p><p>要声明一个变量，我们需要使用以下格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[数据类型] [变量名称];</span><br></pre></td></tr></table></figure><p>这里的数据类型我们会在下节课开始逐步讲解，比如整数就是<code>int</code>类型，不同类型的变量可以存储不同的类型的值。后面的变量名称顾名思义，就像<code>x</code>一样，这个名称我们可以随便起一个，但是注意要满足以下要求：</p><ul><li>标识符可以由大小写字母、数字、下划线(_)和美元符号($)组成，但是不能以数字开头。</li><li>变量不能重复定义，大小写敏感，比如A和a就是两个不同的变量。</li><li>不能有空格、@、#、+、-、/ 等符号。</li><li>应该使用有意义的名称，达到见名知意的目的（一般我们采用英文单词），最好以小写字母开头。</li><li>不可以是 true 和 false。</li><li>不能与Java语言的关键字或是基本数据类型重名，关键字列表如下：</li></ul><p>![image-20220916224014438](/Users/nagocoler/Library/Application Support/typora-user-images/image-20220916224014438.png)</p><p>当然各位小伙伴没必要刻意去进行记忆，我们会在学习的过程中逐步认识到这些关键字。新手要辨别一个单词是否为关键字，只需要通过IDEA的高亮颜色进行区分即可，比如：</p><p><img src="https://s2.loli.net/2022/09/16/qtsjIhSGQoxBYVM.png" alt="image-20220916224129597"></p><p>深色模式下，关键字会高亮为橙色，浅色模式下会高亮为深蓝色，普通的代码都是正常的灰白色。</p><p> 比如现在我们想要定义一个变量<code>a</code>，那么就可以这样编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a;    <span class="comment">//声明一个整数类型变量a</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个变量一开始没有任何值，比如现在我们要让这个变量表示10，那么就可以将10赋值给这个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;   <span class="comment">//直接在定义变量后面添加 = 10，表示这个变量的初始值为10，这里的10就是一个常量数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者我们可以在使用时再对其进行赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    a = <span class="number">10</span>;   <span class="comment">//使用时再赋值也可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉跟数学差不多？这种写法对于我们人来说，实际上是很好理解的，意思表达很清晰。</p><p>我们可以一次性定义多个变量，比如现在我们想定义两个<code>int</code>类型的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b;   <span class="comment">//定义变量a和变量b，中间使用逗号隔开就行了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者两个变量单独声明也可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;   <span class="comment">//分两句进行声明</span></span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更直观地查看变量的值，我们可以直接将变量的值也给打印到控制台：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">666</span>;</span><br><span class="line">    System.out.println(a);    <span class="comment">//之前我们在小括号写的是&quot;&quot;，现在我们直接将变量给进去就可以打印变量的值了</span></span><br><span class="line">  System.out.println(<span class="number">888</span>);   <span class="comment">//甚至直接输出一个常量值都可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果：</p><p><img src="https://s2.loli.net/2022/09/16/3nUAHINdXMmlxvJ.png" alt="image-20220916225037221"></p><p>变量的值也可以在中途进行修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">666</span>;</span><br><span class="line">    a = <span class="number">777</span>;</span><br><span class="line">    System.out.println(a);   <span class="comment">//这里打印得到的值就是777了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量的值也可以直接指定为其他变量的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;   <span class="comment">//直接让b等于a，那么a的值就会给到b</span></span><br><span class="line">    System.out.println(b);   <span class="comment">//这里输出的就是10了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以让变量与数值之间做加减法（运算符会在后面详细介绍）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>;   <span class="comment">//a初始值为9</span></span><br><span class="line">    a = a + <span class="number">1</span>;   <span class="comment">//a = a + 1也就是将a+1的结果赋值给a，跟数学是一样的，很好理解对吧</span></span><br><span class="line">    System.out.println(a);   <span class="comment">//最后得到的结果就是10了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候我们希望变量的值一直保持不变，我们就可以将其指定为常量，这里我们介绍Java中第一个需要认识的关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">666</span>;   <span class="comment">//在变量前面添加final关键字，表示这是一个常量</span></span><br><span class="line">    a = <span class="number">777</span>;    <span class="comment">//常量的值不允许发生修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时出现：</p><p><img src="https://s2.loli.net/2022/09/16/kT46yi8KNOLWlp3.png" alt="image-20220916225429474"></p><p>常量的值只有第一次赋值可以修改，其他任何情况下都不行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> a;</span><br><span class="line">    a = <span class="number">777</span>;   <span class="comment">//第一次赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，Java的基础语法部分介绍完毕，下一部分我们将开始介绍Java中的几大基本数据类型。</p><hr><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>我们的程序中可能需要表示各种各样的数据，比如整数、小数、字符等等，这一部分我们将探索Java中的八大基本数据类型。只不过在开始之前，我们还需要先补充一点简单的计算机小知识。</p><h3 id="计算机中的二进制表示"><a href="#计算机中的二进制表示" class="headerlink" title="计算机中的二进制表示"></a>计算机中的二进制表示</h3><p>在计算机中，所有的内容都是二进制形式表示。十进制是以10为进位，如9+1=10；二进制则是满2进位（因为我们的计算机是电子的，电平信号只有高位和低位，你也可以暂且理解为通电和不通电，高电平代表1，低电平代表0，由于只有0和1，因此只能使用2进制表示我们的数字！）比如1+1=10=2^1+0，一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个bit称为一个双字，64个bit称为一个四字，我们一般采用字节来描述数据大小。</p><p>注意这里的bit跟我们生活中的网速MB/s是不一样的，小b代表的是bit，大B代表的是Byte字节（8bit = 1Byte字节），所以说我们办理宽带的时候，100Mbps这里的b是小写的，所以说实际的网速就是100/8 = 12.5 MB/s了。</p><blockquote><p>十进制的7 -&gt; 在二进制中为 111 = 2^2 + 2^1 + 2^0</p></blockquote><p>现在有4个bit位，最大能够表示多大的数字呢？</p><ul><li>最小：0000 =&gt; 0</li><li>最大：1111 =&gt; 23+22+21+20 =&gt; 8 + 4 + 2 + 1 = 15</li></ul><p>在Java中，无论是小数还是整数，他们都要带有符号（和C语言不同，C语言有无符号数）所以，首位就作为我们的符号位，还是以4个bit为例，首位现在作为符号位（1代表负数，0代表正数）：</p><ul><li>最小：1111 =&gt; -(22+21+2^0) =&gt; -7</li><li>最大：0111 =&gt; +(22+21+2^0) =&gt; +7 =&gt; 7</li></ul><p>现在，我们4bit能够表示的范围变为了-7~+7，这样的表示方式称为<strong>原码</strong>。虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例：</p><blockquote><p>1+(-1) = 0001 + 1001 = 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道！）</p></blockquote><p>我们得创造一种更好的表示方式！于是我们引入了<strong>反码</strong>：</p><ul><li>正数的反码是其本身</li><li>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反</li></ul><p>经过上面的定义，我们再来进行加减法：</p><blockquote><p>1+(-1) = 0001 + 1110 = 1111 =&gt; -0 （直接相加，这样就简单多了！）</p></blockquote><p>思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？0既不是正数也不是负数，那么显然这样的表示依然不够合理！根据上面的问题，我们引入了最终的解决方案，那就是<strong>补码</strong>，定义如下：</p><ul><li>正数的补码就是其本身 （不变！）</li><li>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1（即在反码的基础上+1，此时1000表示-8）</li><li>对补码再求一次补码就可得该补码对应的原码。</li></ul><p>比如-7原码为1111，反码为1000，补码就是1001了，-6原码为1110，反码为1001，补码就是1010。所以在补码下，原本的1000就作为新增的最小值-8存在。</p><p>所以现在就已经能够想通，-0已经被消除了！我们再来看上面的运算：</p><blockquote><p>1+(-1) = 0001 + 1111 = (1)0000 =&gt; +0 （现在无论你怎么算，也不会有-0了！）</p></blockquote><p>所以现在，1111代表的不再是-0，而是-1，相应的，由于消除-0，负数多出来一个可以表示的数（1000拿去表示-8了），那么此时4bit位能够表示的范围是：-8~+7（Java使用的就是补码！）在了解了计算机底层的数据表示形式之后，我们再来学习这些基本数据类型就会很轻松了。</p><h3 id="整数类形"><a href="#整数类形" class="headerlink" title="整数类形"></a>整数类形</h3><p>整数类型是最容易理解的类型！既然我们知道了计算机中的二进制数字是如何表示的，那么我们就可以很轻松的以二进制的形式来表达我们十进制的内容了。</p><p>在Java中，整数类型包括以下几个：</p><ul><li>byte 字节型 （8个bit，也就是1个字节）范围：-128~+127</li><li>short 短整形（16个bit，也就是2个字节）范围：-32768~+32767</li><li>int 整形（32个bit，也就是4个字节）最常用的类型：-2147483648 ~ +2147483647</li><li>long 长整形（64个bit，也就是8个字节）范围：-9223372036854775808 ~ +9223372036854775807</li></ul><p>这里我们来使用一下，其实这几种变量都可以正常表示整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">short</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为都可以表示整数，所以说我们可以将小的整数类型值传递给大的整数类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">short</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;   <span class="comment">//小的类型可以直接传递给表示范围更大的类型</span></span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反之会出现报错：</p><p><img src="https://s2.loli.net/2022/09/16/NLZlDgxz3ci5Idr.png" alt="image-20220916231650085"></p><p>这是由于我们在将小的整数类型传递给大的整数类型时发生了<strong>隐式类型转换</strong>，只要是从存储范围小的类型到存储范围大的类型，都支持隐式类型转换，它可以自动将某种类型的值，转换为另一种类型，比如上面就是将short类型的值转换为了int类型的值。</p><p>隐式类型转换不仅可以发生在整数之间，也可以是其他基本数据类型之间，我们后面会逐步介绍。</p><p>实际上我们在为变量赋一个常量数值时，也发生了隐式类型转换，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="comment">//这里的整数常量10，实际上默认情况下是int类型，但是由于正好在对应类型可以表示的范围内，所以说直接转换为了byte类型的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于直接编写的整数常量值默认为<code>int</code>，这里需要特别注意一下，比如下面这种情况：</p><p><img src="https://s2.loli.net/2022/09/16/76GgjWYz4DPBy1p.png" alt="image-20220916232420547"></p><p>按照<code>long</code>类型的规定，实际上是可以表示这么大的数字的，但是为什么这里报错了呢？这是因为我们直接在代码中写的常量数字，默认情况下就是<code>int</code>类型，这么大肯定是表示不下的，如果需要将其表示为一个long类型的常量数字，那么需要在后面添加大写或是小写的<code>L</code>才可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">922337203685477580L</span>;   <span class="comment">//这样就可以正常编译通过了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，针对于这种很长的数字，为了提升辨识度，我们可以使用下划线分割每一位：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1_000_000</span>;    <span class="comment">//当然这里依然表示的是1000000，没什么区别，但是辨识度会更高</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以以8进制或是16进制表示一个常量值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">0xA</span>);</span><br><span class="line">    System.out.println(<span class="number">012</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>十六进制：</strong>以<code>0x</code>开头的都是十六进制表示法，十六进制满16进一，但是由于我们的数学只提供了0-9这十个数字，10、11、12…15该如何表示呢，我们使用英文字母A按照顺序开始表示，A表示10、B表示11…F表示15。比如上面的0xA实际上就是我们十进制中的10。</li><li><strong>八进制：</strong>以0开头的都是八进制表示法，八进制就是满8进一，所以说只能使用0-7这几个数字，比如上面的012实际上就是十进制的10。</li></ul><p>我们最后再来看一个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2147483647</span>;   <span class="comment">//int最大值</span></span><br><span class="line">    a = a + <span class="number">1</span>;   <span class="comment">//继续加</span></span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时a的值已经来到了<code>int</code>类型所能表示的最大值了，那么如果此时再继续<code>+1</code>，各位小伙伴觉得会发生什么？可以看到结果很奇怪：</p><p><img src="https://s2.loli.net/2022/09/16/YztefPIvLE6y94u.png" alt="image-20220916234540720"></p><p>什么情况？？？怎么正数加1还变成负数了？请各位小伙伴回想一下我们之前讲解的原码、反码和补码。</p><p>我们先来看看，当int为最大值时，二进制表示形式为什么：</p><ul><li>2147483647 = 01111111 11111111 11111111 11111111（第一个是符号位0，其他的全部为1，就是正数的最大值）</li></ul><p>那么此时如果加1，会进位成：</p><ul><li>10000000 00000000 00000000 00000000</li></ul><p>各位想一想，符号位为1，那么此时表示的不就是一个负数了吗？我们回想一下负数的补码表示规则，瞬间就能明白了，这不就是补码形式下的最小值了吗？</p><p>所以说最后的结果就是<code>int</code>类型的最小值：-2147483648，是不是感觉了解底层原理会更容易理解这是为什么。</p><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>前面我们介绍了整数类型，我们接着来看看浮点类型，在Java中也可以轻松地使用小数。</p><p>首先来看看Java中的小数类型包含哪些：</p><ul><li>float 单精度浮点型 （32bit，4字节）</li><li>double 双精度浮点型（64bit，8字节）</li></ul><p>那么小数在计算机中又是如何存放的呢？</p><p><img src="https://s2.loli.net/2022/09/17/CpI5jaWgR9nqTbc.png" alt="image-20220917102209246"></p><p>根据国际标准 IEEE 754，任意一个二进制浮点数 V 可以表示成下面的形式：<br>$$<br>V = (-1)^S \times M \times 2^E<br>$$</p><ul><li>$(-1)^S$ 表示符号位，当 S=0，V 为正数；当 S=1，V 为负数。</li><li>M 表示有效数字，大于等于 1，小于 2，但整数部分的 1 不变，因此可以省略。（例如尾数为1111010，那么M实际上就是1.111010，尾数首位必须是1，1后面紧跟小数点，如果出现0001111这样的情况，去掉前面的0，移动1到首位；题外话：随着时间的发展，IEEE 754标准默认第一位为1，故为了能够存放更多数据，就舍去了第一位，比如保存1.0101 的时候， 只保存 0101，这样能够多存储一位数据）</li><li>$2^E$ 表示指数位。（用于移动小数点，所以说才称为浮点型）</li></ul><p>比如， 对于十进制的 5.25 对应的二进制为：101.01，相当于：$1.0101 \times 2^2$。所以，S 为 0，M 为 1.0101，E 为 2。因此，对于浮点类型，最大值和最小值不仅取决于符号和尾数，还有它的阶码，所以浮点类型的大致取值范围：</p><ul><li>单精度：$±3.40282347 \times 10^{38}$</li><li>双精度：$±1.79769313486231570 \times 10^{308}$</li></ul><p>我们可以直接创建浮点类型的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10.5</span>, b = <span class="number">66</span>;   <span class="comment">//整数类型常量也可以隐式转换到浮点类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，跟整数类型常量一样，小数类型常量默认都是<code>double</code>类型，所以说如果我们直接给一个float类型赋值：</p><p><img src="https://s2.loli.net/2022/09/17/x7bOzyIacpDowKk.png" alt="image-20220917105141288"></p><p>由于<code>float</code>类型的精度不如<code>double</code>，如果直接给其赋一个double类型的值，会直接出现错误。</p><p>同样的，我们可以给常量后面添加大写或小写的F来表示这是一个<code>float</code>类型的常量值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">9.9F</span>;   <span class="comment">//这样就可以正常编译通过了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是反之，由于<code>double</code>精度更大，所以说可以直接接收<code>float</code>类型的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">9.9F</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> f;    <span class="comment">//隐式类型转换为double值</span></span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过由于精度问题，最后的打印结果：</p><p><img src="https://s2.loli.net/2022/09/17/1JqHY2so6Qwz4WX.png" alt="image-20220917105849862"></p><p>这种情况是正常的，因为浮点类型并不保证能够精确计算，我们会在下一章介绍 BigDecimal 和 BigInteger，其中BigDecimal更适合需要精确计算的场景。</p><p>我们最后来看看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">21731371236768L</span>;</span><br><span class="line">    <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> l;   <span class="comment">//这里能编译通过吗？</span></span><br><span class="line">    System.out.println(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们发现，<code>long</code>类型的值居然可以直接丢给<code>float</code>类型隐式类型转换，很明显<code>float</code>只有32个bit位，而<code>long</code>有足足64个，这是什么情况？怎么大的还可以隐式转换为小的？这是因为虽然<code>float</code>空间没有那么大，但是由于是浮点类型，指数可以变化，最大的数值表示范围实际上是大于<code>long</code>类型的，虽然会丢失精度，但是确实可以表示这么大的数。</p><p>所以说我们来总结一下隐式类型转换规则：byte→short(char)→int→long→float→double</p><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>字符类型也是一个重要的基本数据类型，它可以表示计算机中的任意一个字符（包括中文、英文、标点等一切可以显示出来的字符）</p><ul><li>char 字符型（16个bit，也就是2字节，它不带符号）范围是0 ~ 65535</li></ul><p>可以看到char类型依然存储的是数字，那么它是如何表示每一个字符的呢？实际上每个数字在计算机中都会对应一个字符，首先我们需要介绍ASCII码：</p><p><img src="https://s2.loli.net/2022/09/17/Z7AiBPNO6ylML4z.png" alt="img"></p><p>比如我们的英文字母<code>A</code>要展示出来，那就是一个字符的形式，而其对应的ASCII码值为65，所以说当char为65时，打印出来的结果就是大写的字母A了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">65</span>;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果为：</p><p><img src="https://s2.loli.net/2022/09/17/dvizHYa2fCOKhA3.png" alt="image-20220917110854266"></p><p>或者我们也可以直接写一个字符常量值赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;    <span class="comment">//字符常量值需要使用单引号囊括，并且内部只能有一个字符</span></span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法效果与上面是一样的。</p><p>不过，我们回过来想想，这里的字符表里面不就128个字符吗，那<code>char</code>干嘛要两个字节的空间来存放呢？我们发现表中的字符远远没有我们所需要的那么多，这里只包含了一些基础的字符，中文呢？那么多中文字符（差不多有6000多个），用ASCII编码表那128个肯定是没办法全部表示的，但是我们现在需要在电脑中使用中文。这时，我们就需要扩展字符集了。</p><blockquote><p>我们可以使用两个甚至多个字节来表示一个中文字符，这样我们能够表示的数量就大大增加了，GB2132方案规定当连续出现两个大于127的字节时（注意不考虑符号位，此时相当于是第一个bit位一直为1了），表示这是一个中文字符（所以为什么常常有人说一个英文字符占一字节，一个中文字符占两个字节），这样我们就可以表示出超过7000种字符了，不仅仅是中文，甚至中文标点、数学符号等，都可以被正确的表示出来。</p><p>不过这样能够表示的内容还是不太够，除了那些常见的汉字之外，还有很多的生僻字，比如龘、錕、釿、拷这类的汉字，后来干脆直接只要第一个字节大于127，就表示这是一个汉字的开始，无论下一个字节是什么内容（甚至原来的128个字符也被编到新的表中），这就是Windows至今一直在使用的默认GBK编码格式。</p><p>虽然这种编码方式能够很好的解决中文无法表示的问题，但是由于全球还有很多很多的国家以及很多很多种语言，所以我们的最终目标是能够创造一种可以表示全球所有字符的编码方式，整个世界都使用同一种编码格式，这样就可以同时表示全球的语言了。所以这时就出现了一个叫做ISO的（国际标准化组织）组织，来定义一套编码方案来解决所有国家的编码问题，这个新的编码方案就叫做Unicode（准确的说应该是规定的字符集，包含了几乎全世界所有语言的字符），规定每个字符必须使用两个字节，即用16个bit位来表示所有的字符（也就是说原来的那128个字符也要强行用两位来表示）</p><p>但是这样的话实际上是很浪费资源的，因为这样很多字符都不会用到两字节来保存，肯定不能直接就这样去表示，这会导致某些字符浪费了很多空间，我们需要一个更加好用的具体的字符编码方式。所以最后就有了UTF-8编码格式（它是Unicode字符集的一个编码规则），区分每个字符的开始是根据字符的高位字节来区分的，比如用一个字节表示的字符，第一个字节高位以“0”开头；用两个字节表示的字符，第一个字节的高位为以“110”开头，后面一个字节以“10开头”；用三个字节表示的字符，第一个字节以“1110”开头，后面俩字节以“10”开头；用四个字节表示的字符，第一个字节以“11110”开头，后面的三个字节以“10”开头：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10000011 10000110    //这就是一个连续出现都大于127的字节（注意这里是不考虑符号位的）</span><br></pre></td></tr></table></figure><p>所以如果我们的程序需要表示多种语言，最好采用UTF-8编码格式，随着更多的字符加入，实际上两个字节也装不下了，可能需要3个甚至4个字节才能表示某些符号，后来就有了UTF-16编码格式，Java在运行时采用的就是UTF-16，几乎全世界的语言用到的字符都可以表示出来。</p></blockquote><table><thead><tr><th>Unicode符号范围（十六进制）</th><th>UTF-8编码方式(二进制)</th></tr></thead><tbody><tr><td>0000 0000 ~ 0000 007F</td><td>0xxxxxxx</td></tr><tr><td>0000 0080 ~ 0000 07FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>0000 0800 ~ 0000 FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>0001 0000 ~ 0010 FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p><strong>注意：</strong>Unicode 是“字符集”，也就是有哪些字符，而UTF-8、UTF-16 是“编码规则”，也就是怎么对这些字符编码，怎么以二进制的形式保存，千万不要搞混了。</p><p>简而言之，char实际上需要两个字节才能表示更多种类的字符，所以，<code>char</code>类型可以直接表示一个中文字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;淦&#x27;</span>;   <span class="comment">//使用int类型接收字符类型常量值可以直接转换为对应的编码</span></span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果为：</p><p><img src="https://s2.loli.net/2022/09/17/ZgzMUafmYAKoOXt.png" alt="image-20220917111838629"></p><p>Java程序在编译为<code>.class</code>文件之后，会采用UTF-8的编码格式，支持的字符也非常多，所以你甚至可以直接把变量名写成中文，依然可以编译通过：</p><p><img src="https://s2.loli.net/2022/09/17/vAnPCgx5ThEUBHe.png" alt="image-20220917112033102"></p><p>介绍完了字符之后，我们接着来看看字符串，其实字符串我们在一开始就已经接触到了。字符虽然可以表示一个中文，但是它没办法表示多个字符：</p><p><img src="https://s2.loli.net/2022/09/17/JmdQkSw2qc4ZTuW.png" alt="image-20220917114628564"></p><p>但是实际上我们使用率最高的还是多个字符的情况，我们需要打印一连串的字符。这个时候，我们就可以使用字符串了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;啊这&quot;</span>;    <span class="comment">//字符串需要使用双引号囊括，字符串中可以包含0-N个字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里使用的类型是<code>String</code>类型，这种类型并<strong>不是基本数据类型</strong>，它是对象类型，我们会在下一章继续对其进行介绍，这里我们只需要简单了解一下就可以了。</p><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔类型是Java中的一个比较特殊的类型，它并不是存放数字的，而是状态，它有下面的两个状态：</p><ul><li>true  -  真</li><li>false  -  假</li></ul><p>布尔类型（boolean）只有<code>true</code>和<code>false</code>两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句（不同于C语言，C语言中一般使用0表示false，除0以外的所有数都表示true）布尔类型占据的空间大小并未明确定义，而是根据不同的JVM会有不同的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">true</span>;   <span class="comment">//值只能是true或false</span></span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果给一个其他的值，会无法编译通过：</p><p><img src="https://s2.loli.net/2022/09/17/1TtJdKcvRWPfAI2.png" alt="image-20220917115424504"></p><p>至此，基本数据类型的介绍就结束了。</p><hr><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>前面我们介绍了多种多样的基本数据类型，但是光有这些基本数据类型还不够，我们还需要让这些数据之间进行运算，才可以真正意义上发挥计算机的作用。</p><p>要完成计算，我们需要借助运算符来完成，实际上我们在数学中就已经接触过多种多样的运算符了。</p><blockquote><p>比如：+   -    ×    ÷</p></blockquote><p>这些运算符都是我们在初等数学中学习的，而使用规则也很简单，我们只需要将需要进行运算的两个数放到运算符的两边就可以了：</p><blockquote><p>比如：10 ÷ 2</p></blockquote><p>上面运算的结果就是5了，而在Java中，我们同样可以使用这样的方式来进行运算。</p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>首先我们还是来回顾一下之前认识的老朋友：赋值运算符。</p><p>赋值运算符可以直接给某个变量赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">666</span>;   <span class="comment">//使用等号进行赋值运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用规则为：</strong>赋值运算符的左边必须是一个可以赋值的目标，比如变量，右边可以是任意满足要求的值，包括变量。</p><p>当然，赋值运算符并不只是单纯的赋值，它是有结果的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a = <span class="number">777</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当出现连续使用赋值运算符时，按照从右往左的顺序进行计算，首先是<code>a = 777</code>，计算完成后，a的值就变成了777，计算完成后，会得到计算结果（赋值运算的计算结果就是赋的值本身，就像1 + 1的结果是2一样，a = 1的结果就是1）此时继续进行赋值计算，那么b就被赋值为<code>a = 777</code>的计算结果，同样的也是 777 了。</p><p>所以，使用连等可以将一连串变量都赋值为最右边的值。</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算符也就是我们初等数学中认识的这些运算符，包括加减乘除，当然Java还支持取模运算，算术运算同样需要左右两边都有一个拿来计算的目标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到a赋值为1+1的结果，所以说最后a就是2了。</p><p>当然变量也是可以参与到算术运算中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a - <span class="number">10</span>;</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同类型之间也可以进行运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="type">short</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;   </span><br><span class="line">  <span class="comment">//不同类型的整数一起运算，小类型需要转换为大类型，short、byte、char一律转换为int再进行计算（无论算式中有无int，都需要转换），结果也是int；如果算式中出现了long类型，那么全部都需要转换到long类型再进行计算，结果也是long，反正就是依大的来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为运算时会发生隐式类型转换，所以说这里b自动转换为了int类型进行计算，所以说最后得到结果也一定是转换后的类型：</p><p><img src="https://s2.loli.net/2022/09/17/KovME45pl2sPiBN.png" alt="image-20220917141359260"></p><p>小数和整数一起计算同样会发生隐式类型转换：</p><p><img src="https://s2.loli.net/2022/09/17/jxW3KfwBACidyMY.png" alt="image-20220917141955891"></p><p>因为小数表示范围更广，所以说整数会被转换为小数再进行计算，而最后的结果也肯定是小数了。</p><p>我们也可以将加减号作为正负符号使用，比如我们现在需要让a变成自己的相反数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    a = -a;   <span class="comment">//减号此时作为负号运算符在使用，会将右边紧跟的目标变成相反数</span></span><br><span class="line">    System.out.println(a);   <span class="comment">//这里就会得到-10了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，正号也可以使用，但是似乎没什么卵用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    a = +a;   <span class="comment">//正号本身在数学中就是可以省略的存在，所以Java中同样如此</span></span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意加法支持对字符串的拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;伞兵&quot;</span> + <span class="string">&quot;lbw&quot;</span>;   <span class="comment">//我们可以使用加号来拼接两个字符串</span></span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后这个字符串就变成了拼接后的结果了：</p><p><img src="https://s2.loli.net/2022/09/17/TeUCBM9ZzINuoa8.png" alt="image-20220917145901135"></p><p>字符串不仅可以跟字符串拼接，也可以跟基本数据类型拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;伞兵&quot;</span> + <span class="literal">true</span> + <span class="number">1.5</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就可以得到对应的结果了：</p><p><img src="https://s2.loli.net/2022/09/17/URJxsgXvzYMQh8t.png" alt="image-20220917150010919"></p><p>当然，除了加减法之外乘除法也是支持的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>, b = <span class="number">2</span>;</span><br><span class="line">    System.out.println(a * b);   <span class="comment">//乘法使用*表示乘号</span></span><br><span class="line">  System.out.println(a / b);   <span class="comment">//除法就是一个/表示除号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，两个整数在进行除法运算时，得到的结果也是整数（会直接砍掉小数部分，注意不是四舍五入）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>, b = <span class="number">5</span>;</span><br><span class="line">    System.out.println(a / b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是两个int类型的值进行的除法运算，正常情况下8除以5应该得到1.6，但是由于结果也是整数，所以说最后小数部分被丢弃：</p><p><img src="https://s2.loli.net/2022/09/17/TdhHPN64UnyFozq.png" alt="image-20220917141816599"></p><p>但是如果是两个小数一起计算的话，因为结果也是小数，所以说就可以准确得到结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8.0</span>, b = <span class="number">5.0</span>;</span><br><span class="line">    System.out.println(a / b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/17/3zjJoeL6bgdRqNA.png" alt="image-20220917142201392"></p><p>同样的，整数和小数一起计算，由于所有的整数范围都比小数小，根据我们上一部分介绍的转换规则，整数和小数一起计算时，所有的整数都会变成小数参与运算，所以说最后的结果也就是小数了，同样可以得到正确的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8.0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    System.out.println(a / b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，现在我们有两个整数需要进行计算，但是我们就是希望可以得到一个小数的结果该怎么办呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> a;   <span class="comment">//我们可以将其先隐式转换为小数类型，再那转换后的小数变量去参与计算</span></span><br><span class="line">    System.out.println(c / b);   <span class="comment">//同样可以得到正确结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下一节，我们将介绍强制类型转换，通过使用强制类型转换，我们可以更轻松地让整数计算出小数的结果。</p><p>除了最基本的加减乘除操作，我们也可以进行取模操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    System.out.println(a % <span class="number">3</span>);   <span class="comment">//比如这里对a进行取模操作，实际上就是计算除以3的余数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面的是 10 % 3 得到的结果就是10除以3最后的余数1，取模操作也是非常好用的。</p><p>比如我们查看某个数是否为双数，只需要将其对2进行取模操作即可，因为如果是双数一定是可以整除的，如果是单数一定会余1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">17</span> % <span class="number">2</span>);   <span class="comment">//17不是双数，所以说最后会得到1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，运算符之间是有优先级之分的，比如乘除法优先级高于加减法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">10</span> + <span class="number">3</span> * <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的算式按照数学中的规则，应该先计算3 * 4，然后再进行加法计算，而Java中同样遵循这样的规律。我们来总结一下到目前为止所有学习到的运算符相关性质：</p><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">结合性（出现同优先级运算符时）</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">-(负号)  +(正号)</td><td align="center">从右向左</td></tr><tr><td align="center">2</td><td align="center">*   /  %</td><td align="center">从左往右</td></tr><tr><td align="center">3</td><td align="center">+(加法，包括字符串)   -(减法)</td><td align="center">从左往右</td></tr><tr><td align="center">4</td><td align="center">=</td><td align="center">从右向左</td></tr></tbody></table><p>比如下面的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a = <span class="number">8</span> * -a + <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. 正负号优先级最高，所有首先计算的是-a，得到-10</span></span><br><span class="line"><span class="comment">        2. 其次是乘除号优先级更高，所以说这里计算 8 * -10，得到 -80</span></span><br><span class="line"><span class="comment">        3. 然后是加减法，-80 + 10 = -70</span></span><br><span class="line"><span class="comment">        4. 最后是赋值运算，因为等号运算符从右往左结合，先算a = -70的结果就是 -70</span></span><br><span class="line"><span class="comment">        5. 最后b就是 -70</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用这些基本算术运算符，我们就可以更加快速地计算我们想要的结果了。</p><h3 id="括号运算符"><a href="#括号运算符" class="headerlink" title="括号运算符"></a>括号运算符</h3><p>前面我们介绍了算术运算符，我们接着来看括号运算符。</p><p>我们常常在数学中使用括号提升某些运算的优先级，比如：</p><blockquote><p>(1 + 7) × (3 - 6) = -24</p></blockquote><p>虽然加法优先级比乘法要低但是我们给其添加括号之后，相当于提升了内部加法运算的优先级，所以说需要先计算括号中的再去计算括号外的，Java同样满足这个要求。</p><p>我们可以通过添加括号的方式来提升某些运算的优先级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (a = <span class="number">8</span>) * (-a + <span class="number">10</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. 括号的优先级是最高的，我们需要先计算括号中的内容，如果存在多个括号，就从左往右计算</span></span><br><span class="line"><span class="comment">        2. 首先是 a = 8，计算完成之后a变成8，并且运算结果也为8</span></span><br><span class="line"><span class="comment">        3. 然后是后面的加法，-a就是-8，加上10就是2</span></span><br><span class="line"><span class="comment">        4. 最后才是乘法，左边此时是8，右边是2，最后结果为16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，通过添加括号，就可以更加灵活的控制计算。</p><p>当然，括号是可以嵌套的，这一点跟数学中也是一样的，只不过我们不需要使用方括号和花括号，一律使用小括号就行了。</p><p>在嵌套的情况下，会优先计算最内层括号中的算式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="number">2</span> + (<span class="number">3</span> + <span class="number">1</span>) * <span class="number">3</span>) * <span class="number">2</span>;</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会优先计算 3 + 1的结果，然后由于第二层都在一个括号中，所以说按照正常优先级计算，2 + 4 * 3  = 14，最后来到最外层14*2 = 28，计算结束。</p><p>括号除了可以用来提升运算优先级，也可以用作<strong>强制类型转换</strong>，前面我们介绍了隐式类型转换，但是隐式类型转换存在局限性，比如此时我们希望将一个大的类型转换为一个小的类型：</p><p><img src="https://s2.loli.net/2022/09/17/En2uzTl5PFgKeNX.png" alt="image-20220917150256987"></p><p>正常情况下无法编译通过，但是实际上a的值并没有超出<code>short</code>的范围，理论上是可以直接给到b存放的，此时我们就可以使用强制类型转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">short</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">short</span>) a;   <span class="comment">//在括号中填写上强制转换的类型，就可以强制转换到对应的类型了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过强制类型转换存在一定的风险，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">128</span>;   <span class="comment">//已经超出byte的范围了</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>) a;  <span class="comment">//此时强制类型转换为byte类型，那么只会保留byte能够表示的bit位</span></span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如这里的128：</p><ul><li>00000000 00000000 00000000 10000000  -&gt;  byte只有一个字节，所以说只保留最后8位 -&gt; 10000000</li></ul><p>这里的10000000，由于第一个位置是符号位，导致此时直接变成了byte的最小值：</p><p><img src="https://s2.loli.net/2022/09/17/Kt6rfkYE1HSvNnl.png" alt="image-20220917151028191"></p><p>所以说强制类型转换只有在明确不会出现问题的情况下，才可以使用。当然，强制类型转换也可以用在后面的类中，我们将会在下一章继续探讨。</p><p>有了强制类型转换，我们就可以很轻松地让两个整数计算出小数的结果了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> a/(<span class="type">double</span>)b;  </span><br><span class="line">  <span class="comment">//强制类型转换的优先级跟正负号一样</span></span><br><span class="line">  <span class="comment">//计算时，只需要将其中一者转换为double类型，此时按照隐式类型转换规则，全都会变成double参与运算，所以结果也就是小数了</span></span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各位思考一下下面的这种情况可以正确得到小数的结果吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">double</span>) (a/b);</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能得到，因为括号将a/b的运算优先进行了，此时得到的结果已经是一个整数结果，再转换为double毫无意义。</p><p>最后我们还是来总结一下目前遇到的所有运算符：</p><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">结合性</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">( )</td><td align="center">从左向右</td></tr><tr><td align="center">2</td><td align="center">-  +  (强制类型转换)</td><td align="center">从右向左</td></tr><tr><td align="center">3</td><td align="center">*   /  %</td><td align="center">从左向右</td></tr><tr><td align="center">4</td><td align="center">+(加法，包括字符串)   -(减法)</td><td align="center">从左向右</td></tr><tr><td align="center">5</td><td align="center">=</td><td align="center">从右向左</td></tr></tbody></table><h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3><p><strong>注意：</strong>这一节很容易搞晕，请务必记清楚顺序！</p><p>有时候我们可能需要让变量自己进行增加操作，比如我们现在想要进行跳绳计数，每转动一圈，计数+1，当我们想要对一个变量进行这样的自增操作时，可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    a = a + <span class="number">1</span>;    <span class="comment">//让a等于a本身+1，相当于自增了1</span></span><br><span class="line">    System.out.println(a);   <span class="comment">//得到9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，除了这种方式，我们也可以使用自增自减运算符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    a++;   <span class="comment">//自增运算符就是两个加号连在一起，效果跟上面是一样的，a都会自增1</span></span><br><span class="line">  a--;   <span class="comment">//自减不用我多说了吧</span></span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自增自减运算符可以放到操作数的前后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    ++a;   <span class="comment">//自增运算符在前在后最终效果都是让a自增1，是一样的</span></span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自增自减操作同样是有结果的，注意，这两种方式自增操作的结果不一样，我们来看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a++;   <span class="comment">//先出结果，再自增</span></span><br><span class="line">    System.out.println(b);  <span class="comment">//b得到的是a自增前的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> ++a;   <span class="comment">//先自增，再出结果</span></span><br><span class="line">    System.out.println(b);   <span class="comment">//b得到的是a自增之后的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个结果为8，而第二个结果却是9，这是因为，自增运算符放在前面，是先自增再得到结果，而自增运算符放到后面，是先出结果再自增（自减同理），这个新手很容易记混，所以说一定要分清楚。</p><p>自增自减运算符的优先级与正负号等价比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> -a++ + ++a; </span><br><span class="line">  <span class="comment">//我们首先来看前面的a，因为正负号和自增是同一个优先级，结合性是从右往左，所以说先计算a++</span></span><br><span class="line">  <span class="comment">//a++的结果还是8，然后是负号，得到-8</span></span><br><span class="line">  <span class="comment">//接着是后面的a，因为此时a已经经过前面变成9了，所以说++a就是先自增，再得到10</span></span><br><span class="line">  <span class="comment">//最后得到的结果为 -8 + 10 = 2</span></span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，除了考试为了考察各位小伙伴对运算符的优先级和结合性的理解，会出现这种恶心人的写法之外，各位小伙伴尽量不要去写这种难以阅读的东西。</p><p>当然，有些时候我们并不是希望以1进行自增，可能希望以其他的数进行自增操作，除了按照之前的方式老老实实写之外：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    a = a + <span class="number">4</span>;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将其缩写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    a += <span class="number">4</span>;   <span class="comment">//加号和等号连在一起，与a = a + 4效果完全一样</span></span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且结果也是操作之后的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a += <span class="number">4</span>;   <span class="comment">//+=的运算结果就是自增之后的结果</span></span><br><span class="line">    System.out.println(b);  <span class="comment">//所以b就是12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不止加法，包括我们前面介绍的全部算术运算符，都是支持这种缩写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    a *= <span class="number">9</span>;   <span class="comment">//跟 a = a * 9 等价</span></span><br><span class="line">    System.out.println(a);   <span class="comment">//得到72</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉能够编写更简洁的代码了？</p><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">结合性</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">( )</td><td align="center">从左向右</td></tr><tr><td align="center">2</td><td align="center">-  +  (强制类型转换)  ++ –</td><td align="center">从右向左</td></tr><tr><td align="center">3</td><td align="center">*   /  %</td><td align="center">从左向右</td></tr><tr><td align="center">4</td><td align="center">+(加法，包括字符串)   -(减法)</td><td align="center">从左向右</td></tr><tr><td align="center">5</td><td align="center">=  +=  -=  *=   /=   %=</td><td align="center">从右向左</td></tr></tbody></table><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>我们接着来看位运算符，它比较偏向于底层，但是只要各位小伙伴前面的计算机二进制表示听明白了，这里就不是问题。</p><p>我们可以使用位运算符直接以二进制形式操作目标，位运算符包括：&amp;    |    ^    ~</p><p>我们先来看按位与&amp;，比如下面的两个数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a &amp; b;    <span class="comment">//进行按位与运算</span></span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按位与实际上就是让这两个数每一位都进行比较，如果这一位两个数都是1，那么结果就是1，否则就是0：</p><ul><li>a = 9 = 1001</li><li>b = 3 = 0011</li><li>c = 1 = 0001（因为只有最后一位，两个数都是1，所以说结果最后一位是1，其他都是0）</li></ul><p>同样的，按位或，其实就是只要任意一个为1（不能同时为0）那么结果就是1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a | b;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>a = 9 = 1001</li><li>b = 3 = 0011</li><li>c =11= 1011（只要上下有一个是1或者都是1，那结果就是1）</li></ul><p>按位异或符号很多小伙伴会以为是乘方运算，但是Java中并没有乘方运算符，<code>^</code>是按位异或运算符，不要记错了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a ^ b;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异或的意思就是只有两边不相同的情况下，结果才是1，也就是说一边是1一边是0的情况：</p><ul><li>a = 9 = 1001</li><li>b = 3 = 0011</li><li>c =10= 1010（从左往右第二位、第四位要么两个都是0，要么两个都是1，所以说结果为0）</li></ul><p>按位取反操作跟前面的正负号一样，只操作一个数，最好理解，如果这一位上是1，变成0，如果是0，变成1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">c</span> <span class="operator">=</span> ~<span class="number">127</span>;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>127 = 01111111</li><li>-128 = 10000000</li></ul><p>所以说计算的结果就是-128了。</p><p>除了以上的四个运算符之外，还有位移运算符，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;    <span class="comment">//两个连续的小于符号，表示左移运算</span></span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1 = 00000001</li><li>4 = 00000100（左移两位之后，1跑到前面去了，尾部使用<strong>0</strong>填充，此时就是4）</li></ul><p>我们发现，左移操作每进行一次，结果就会x2，所以说，除了直接使用<code>*</code>进行乘2的运算之外，我们也可以使用左移操作来完成。</p><p>同样的，右移操作就是向右移动每一位咯：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">8</span> &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>8 = 00001000</li><li>2 = 00000010（右移两位之后，1跑到后面去了，头部使用<strong>符号位数字</strong>填充，此时变成2）</li></ul><p>跟上面一样，右移操作可以快速进行除以2的计算。</p><p>对于负数来说，左移和右移操作不会改变其符号位上的数字，符号位不受位移操作影响：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">4</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>-4   = 11111100</li><li>-2   = 11111110（前面这一长串1都被推到后面一位了，因为是负数，头部需要使用<strong>符号位数字</strong>来进行填充）</li></ul><p>我们来总结一下：</p><ul><li><strong>左移操作&lt;&lt;：</strong>高位直接丢弃，低位补0</li><li><strong>右移操作&gt;&gt;：</strong>低位直接丢弃，符号位是什么高位补什么</li></ul><p>我们也可以使用考虑符号位的右移操作，一旦考虑符号位，那么符号会被移动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt; <span class="number">1</span>;   <span class="comment">//正常的右移操作，高位补1，所以说移了还是-1</span></span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; <span class="number">1</span>;   <span class="comment">//无符号右移是三个大于符号连在一起，移动会直接考虑符号位</span></span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如：</p><ul><li>-1    =   11111111 11111111 11111111 11111111</li><li>右移：  01111111 11111111 11111111 11111111（无符号右移使用0填充高位）</li></ul><p>此时得到的结果就是正数的最大值 2147483647 了，注意，不存在无符号左移。</p><p>位移操作也可以缩写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    c = c &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以缩写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    c &lt;&lt;= <span class="number">2</span>;    <span class="comment">//直接运算符连上等号即可，跟上面是一样的</span></span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们还是来总结一下优先级：</p><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">结合性</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">( )</td><td align="center">从左向右</td></tr><tr><td align="center">2</td><td align="center">~   -   +  (强制类型转换)  ++   –</td><td align="center">从右向左</td></tr><tr><td align="center">3</td><td align="center">*   /  %</td><td align="center">从左向右</td></tr><tr><td align="center">4</td><td align="center">+   -</td><td align="center">从左向右</td></tr><tr><td align="center">5</td><td align="center">&lt;&lt;   &gt;&gt;   &gt;&gt;&gt;</td><td align="center">从左向右</td></tr><tr><td align="center">6</td><td align="center">&amp;</td><td align="center">从左向右</td></tr><tr><td align="center">7</td><td align="center">^</td><td align="center">从左向右</td></tr><tr><td align="center">8</td><td align="center">|</td><td align="center">从左向右</td></tr><tr><td align="center">9</td><td align="center">=  +=  -=  *=   /=   %=   &amp;=   |=   ^=   &lt;&lt;=  &gt;&gt;=  &gt;&gt;&gt;=</td><td align="center">从右向左</td></tr></tbody></table><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>到目前为止，我们发现有一个基本数据类型很低调，在前面的计算中<code>boolean</code>类型一直都没有机会出场，而接下来就是它的主场。</p><p>我们可以对某些事物进行判断，比如我们想判断两个变量谁更大，我们可以使用关系运算符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">c</span> <span class="operator">=</span> a &gt; b;   <span class="comment">//进行判断，如果a &gt; b那么就会得到true，否则会得到false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关系判断的结果只可能是真或是假，所以说得到的结果是一个<code>boolean</code>类型的值。</p><p>关系判断运算符包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;   大于</span><br><span class="line">&lt;   小于</span><br><span class="line">==  等于（注意是两个等号连在一起，不是一个等号，使用时不要搞混了）</span><br><span class="line">!=  不等于</span><br><span class="line">&gt;=  大于等于</span><br><span class="line">&lt;=  小于等于</span><br></pre></td></tr></table></figure><p>关系运算符的计算还是比较简单的。</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>前面我们介绍了简单的关系运算符，我们可以通过对关系的判断得到真或是假的结果，但是只能进行简单的判断，如果此时我们想要判断a是否小于等于100且大于等于60，就没办法了：</p><p><img src="https://s2.loli.net/2022/09/17/Z1yAPOKe8IVvFUt.png" alt="image-20220917223047110"></p><p>注意不能像这样进行判断，这是错误的语法，同时只能使用其中一种关系判断运算符。</p><p>为了解决这种问题，我们可以使用逻辑运算符，逻辑运算符包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp;     与运算，要求两边同时为<span class="literal">true</span>才能返回<span class="literal">true</span></span><br><span class="line">||     或运算，要求两边至少要有一个为<span class="literal">true</span>才能返回<span class="literal">true</span></span><br><span class="line">!      非运算，一般放在表达式最前面，表达式用括号扩起来，表示对表达式的结果进行反转</span><br></pre></td></tr></table></figure><p>现在，我们就可以使用逻辑运算符进行复杂条件判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span> &gt;= a &amp;&amp; a &gt;= <span class="number">60</span>;   <span class="comment">//我们可以使用与运算符连接两个判断表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与运算符要求左右两边同时为真，得到的结果才是真，否则一律为假，上面的判断虽然满足第一个判断表达式，但是不满足第二个，所以说得到的结果就是<code>false</code>。</p><p>我们再来看下面的这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">150</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span> &gt;= a &amp;&amp; a &gt;= <span class="number">60</span>;  <span class="comment">//此时上来就不满足条件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，第一个判断表达式就得到了<code>false</code>，此时不会再继续运行第二个表达式，而是直接得到结果<code>false</code>（逻辑运算符会出现短路的情况，只要第一个不是真，就算第二个是真也不可能了，所以说为了效率，后续就不用再判断了，在使用时一定要注意这一点）</p><p>同样的，比如我们现在要判断a要么大于10，要么小于0，这种关系就是一个或的关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">150</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> a &lt; <span class="number">0</span> || a &gt; <span class="number">10</span>;   <span class="comment">//或运算要求两边只要有至少一边满足，结果就为true，如果都不满足，那么就是false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或运算同样会出现短路的情况，比如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">9</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> a &lt; <span class="number">0</span> || a &gt; <span class="number">10</span>;  <span class="comment">//此时上来就满足条件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为第一个判断表达式就直接得到了<code>true</code>，那么第二个表达式无论是真还是假，结果都一定是<code>true</code>，所以说没必要继续向后进行判断了，直接得到结果<code>true</code>。</p><p>我们来看看下面的结果是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> a++ &gt; <span class="number">10</span> &amp;&amp; ++a == <span class="number">12</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;a = &quot;</span>+a + <span class="string">&quot;, b = &quot;</span>+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果为：</p><p><img src="https://s2.loli.net/2022/09/17/tJQxnace7y4VdlY.png" alt="image-20220917224320699"></p><p>这是为什么呢？很明显我们的判断中a进行了两次自增操作，但是最后a的结果却是11，这是因为第一个表达式判断的结果为<code>false</code>，由于此时进行的是与运算，所以说直接短路，不会再继续判断了，因此第二个表达式就不会执行。</p><p>当然，除了与运算和或运算，还有一个非运算，这个就比较简单了，它可以将结果变成相反的样子，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> !(a &gt; <span class="number">5</span>);   <span class="comment">//对a&gt;5的判断结果，进行非运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为上面的a &gt; 5判断为真，此时进行非运算会得到相反的结果，所以说最后b就是<code>false</code>了。</p><p>最后我们还需要介绍一个叫做三元运算符的东西，三元运算符可以根据判断条件，返回不同的结果，比如我们想要判断：</p><ul><li>当a &gt; 10时，给b赋值’A’</li><li>当a &lt;= 10时，给b赋值’B’</li></ul><p>我们就可以使用三元运算符来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> a &gt; <span class="number">10</span> ? <span class="string">&#x27;A&#x27;</span> : <span class="string">&#x27;B&#x27;</span>;   <span class="comment">//三元运算符需要三个内容，第一个是判断语句，第二个是满足判断语句的值，第三个是不满足判断语句的值</span></span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三元运算符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断语句 ? 结果1 : 结果2</span><br></pre></td></tr></table></figure><p>因此，上面的判断为假，所以说返回的是结果2，那么最后b得到的就是<code>B</code>这个字符了。</p><p>最后，我们来总结整个运算符板块学习到的所有运算符：</p><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">结合性</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">( )</td><td align="center">从左向右</td></tr><tr><td align="center">2</td><td align="center">~   -   +  (强制类型转换)  ++   –</td><td align="center">从右向左</td></tr><tr><td align="center">3</td><td align="center">*   /  %</td><td align="center">从左向右</td></tr><tr><td align="center">4</td><td align="center">+   -</td><td align="center">从左向右</td></tr><tr><td align="center">5</td><td align="center">&lt;&lt;   &gt;&gt;   &gt;&gt;&gt;</td><td align="center">从左向右</td></tr><tr><td align="center">6</td><td align="center">&gt;   &lt;   &gt;=   &gt;=</td><td align="center">从左向右</td></tr><tr><td align="center">7</td><td align="center">==     !=</td><td align="center">从左向右</td></tr><tr><td align="center">8</td><td align="center">&amp;</td><td align="center">从左向右</td></tr><tr><td align="center">9</td><td align="center">^</td><td align="center">从左向右</td></tr><tr><td align="center">10</td><td align="center">|</td><td align="center">从左向右</td></tr><tr><td align="center">11</td><td align="center">&amp;&amp;</td><td align="center">从左向右</td></tr><tr><td align="center">12</td><td align="center">||</td><td align="center">从左向右</td></tr><tr><td align="center">13</td><td align="center">? :</td><td align="center">从右向左</td></tr><tr><td align="center">14</td><td align="center">=  +=  -=  *=   /=   %=   &amp;=   |=   ^=   &lt;&lt;=  &gt;&gt;=  &gt;&gt;&gt;=</td><td align="center">从右向左</td></tr></tbody></table><p>至此，我们已经学习了Java基础部分中所有的运算符。</p><hr><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>我们的程序都是从上往下依次运行的，但是，仅仅是这样还不够，我们需要更加高级的控制语句来使得程序更加有趣。比如，判断一个整数变量，大于1则输出yes，小于1则输出no，这时我们就需要用到选择结构来帮助我们完成条件的判断和程序的分支走向。学习过C语言就很轻松！</p><p>在前面我们介绍了运算符，我们可以通过逻辑运算符和关系运算符对某些条件进行判断，并得到真或是假的结果。这一部分我们将继续使用这些运算符进行各种判断。</p><h3 id="代码块与作用域"><a href="#代码块与作用域" class="headerlink" title="代码块与作用域"></a>代码块与作用域</h3><p>在开始流程控制语句之前，我们先来介绍一下代码块和作用域。</p><p>不知道各位小伙伴是否在一开始就注意到了，为什么程序中会有一些成对出现的花括号？这些花括号代表什么意思呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;   <span class="comment">//外层花括号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;   <span class="comment">//内层花括号开始</span></span><br><span class="line">       </span><br><span class="line">    &#125;  <span class="comment">//内层花括号结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在花括号中编写一句又一句的代码，实际上这些被大括号囊括起来的内容，我们就称为<strong>块</strong>（代码块），一个代码块中可以包含多行代码，我们可以在里面做各种各样的事情，比如定义变量、进行计算等等。</p><p>我们可以自由地创建代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;   <span class="comment">//现目前这个阶段，我们还是在主方法中编写代码，不要跑去外面写</span></span><br><span class="line">    System.out.println(<span class="string">&quot;外层&quot;</span>);</span><br><span class="line">    &#123;   <span class="comment">//自由创建代码块</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然创建了代码块，但实际上程序依然是按照从上到下的顺序在进行的，所以说这里还是在逐行运行，即使使用花括号囊括。那咋一看这不就是没什么卵用吗？我们来看看变量。</p><p>我们创建的变量，实际上是有作用域的，并不是在任何地方都可以使用，比如：</p><p><img src="https://s2.loli.net/2022/09/17/DdvU3aQmE25KbxM.png" alt="image-20220917231014796"></p><p>变量的使用范围，仅限于其定义时所处的代码块，一旦超出对应的代码块区域，那么就相当于没有这个变量了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;   <span class="comment">//此时变量在最外层定义</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(a);   <span class="comment">//处于其作用域内部的代码块可以使用</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(a);   <span class="comment">//这里肯定也可以使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们目前所创建的变量都是局部变量（有范围限制），后面我们会介绍更多种类型的变量，了解了代码块及作用域之后，我们就可以正式开启流程控制语句的学习了。</p><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><p>某些时候，我们希望进行判断，只有在条件为真时，才执行某些代码，这种情况就需要使用到选择分支语句，首先我们来认识一下<code>if</code>语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (条件判断) 判断成功执行的代码;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">15</span>)    <span class="comment">//只有当a判断等于15时，才会执行下面的打印语句</span></span><br><span class="line">      System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;我是外层&quot;</span>);   <span class="comment">//if只会对紧跟着的一行代码生效，后续的内容无效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if</code>会进行判断，只有判断成功时才会执行紧跟着的语句，否则会直接跳过，注意，如果我们想要在if中执行多行代码，需要使用代码块将这些代码囊括起来（实际上代码块就是将多条语句复合到一起）所以说，我们以后使用if时，如果分支中有多行代码需要执行，就需要添加花括号，如果只有一行代码，花括号可以直接省略，包括我们后面会讲到的else、while、for语句都是这样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; <span class="number">10</span>) &#123;    <span class="comment">//只有判断成功时，才会执行下面的代码块中内容，否则直接跳过</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a大于10&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a的值为：&quot;</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;我是外层&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们希望判断条件为真时执行某些代码，条件为假时执行另一些代码，我们可以在后面继续添加else语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; <span class="number">10</span>) &#123;    <span class="comment">//只有判断成功时，才会执行下面的代码块中内容，否则直接跳过</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a大于10&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a的值为：&quot;</span>+a);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;   <span class="comment">//当判断不成功时，会执行else代码块中的代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a小于10&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a的值为：&quot;</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是外层&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if-else</code>语句就像两个分支，跟据不同的判断情况从而决定下一步该做什么，这跟我们之前认识的三元运算符性质比较类似。</p><p>那如果此时我们需要判断多个分支呢？比如我们现在希望判断学生的成绩，不同分数段打印的等级不一样，比如90以上就是优秀，70以上就是良好，60以上是及格，其他的都是不及格，那么这种我们又该如何判断呢？要像这样进行连续判断，我们需要使用<code>else-if</code>来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span>  <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(score &gt;= <span class="number">90</span>)    <span class="comment">//90分以上才是优秀</span></span><br><span class="line">        System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span>)    <span class="comment">//当上一级if判断失败时，会继续判断这一级</span></span><br><span class="line">        System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">     <span class="keyword">else</span>    <span class="comment">//当之前所有的if都判断失败时，才会进入到最后的else语句中</span></span><br><span class="line">        System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，<code>if</code>分支语句还支持嵌套使用，比如我们现在希望低于60分的同学需要补习，0-30分需要补Java，30-60分需要补C++，这时我们就需要用到嵌套：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span>  <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(score &lt; <span class="number">60</span>) &#123;   <span class="comment">//先判断不及格</span></span><br><span class="line">        <span class="keyword">if</span>(score &gt; <span class="number">30</span>)    <span class="comment">//在内层再嵌套一个if语句进行进一步的判断</span></span><br><span class="line">            System.out.println(<span class="string">&quot;学习C++&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot;学习Java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了if自己可以进行嵌套使用之外，其他流程控制语句同样可以嵌套使用，也可以与其他流程控制语句混合嵌套使用。这样，我们就可以灵活地使用<code>if</code>来进行各种条件判断了。</p><p>前面我们介绍了if语句，我们可以通过一个if语句轻松地进行条件判断，然后根据对应的条件，来执行不同的逻辑，当然除了这种方式之外，我们也可以使用<code>switch</code>语句来实现，它更适用于多分支的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (目标) &#123;   <span class="comment">//我们需要传入一个目标，比如变量，或是计算表达式等</span></span><br><span class="line">  <span class="keyword">case</span> 匹配值:    <span class="comment">//如果目标的值等于我们这里给定的匹配值，那么就执行case后面的代码</span></span><br><span class="line">    代码...</span><br><span class="line">    <span class="keyword">break</span>;    <span class="comment">//代码执行结束后需要使用break来结束，否则会溜到下一个case继续执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如现在我们要根据学生的等级进行分班，学生有ABC三个等级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;  <span class="comment">//这里目标就是变量c</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:    <span class="comment">//分别指定ABC三个匹配值，并且执行不同的代码</span></span><br><span class="line">            System.out.println(<span class="string">&quot;去尖子班！准备冲刺985大学！&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;   <span class="comment">//执行完之后一定记得break，否则会继续向下执行下一个case中的代码</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;去平行班！准备冲刺一本！&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;去职高深造。&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch</code>可以精准匹配某个值，但是它不能进行范围判断，比如我们要判断分数段，这时用switch就很鸡肋了。</p><p>当然除了精准匹配之外，其他的情况我们可以用default来表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (目标) &#123;</span><br><span class="line">    <span class="keyword">case</span>: ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    其他情况下执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还是以刚才那个例子为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;去尖子班！&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;去平行班！&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;去差生班！&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:   <span class="comment">//其他情况一律就是下面的代码了</span></span><br><span class="line">            System.out.println(<span class="string">&quot;去读职高，分流&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然switch中可以继续嵌套其他的流程控制语句，比如if：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;A&#x27;</span>) &#123;    <span class="comment">//嵌套一个if语句</span></span><br><span class="line">                System.out.println(<span class="string">&quot;去尖子班！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;去平行班！&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前，我们已经认识了两种选择分支结构语句。</p><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>通过前面的学习，我们了解了如何使用分支语句来根据不同的条件执行不同的代码，我们接着来看第二种重要的流程控制语句：循环语句。</p><p>我们在某些时候，可能需要批量执行某些代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);   <span class="comment">//把这句话给我打印三遍</span></span><br><span class="line">    System.out.println(<span class="string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遇到这种情况，我们由于还没学习循环语句，那么就只能写N次来实现这样的多次执行。但是如果此时要求我们将一句话打印100遍、1000遍、10000遍，那么我们岂不是光CV代码就要搞一下午？</p><p>现在，要解决这种问题，我们可以使用for循环语句来多次执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>) 循环体;</span><br></pre></td></tr></table></figure><p>介绍一下详细规则：</p><ul><li>表达式1：在循环开始时仅执行一次。</li><li>表达式2：每次循环开始前会执行一次，要求为判断语句，用于判断是否可以结束循环，若结果为真，那么继续循环，否则结束循环。</li><li>表达式3：每次循环完成后会执行一次。</li><li>循环体：每次循环都会执行一次循环体。</li></ul><p>一个标准的for循环语句写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//比如我们希望让刚刚的打印执行3次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)    <span class="comment">//这里我们在for语句中定义一个变量i，然后每一轮i都会自增，直到变成3为止</span></span><br><span class="line">        System.out.println(<span class="string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);   <span class="comment">//这样，就会执行三轮循环，每轮循环都会执行紧跟着的这一句打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用调试来观察每一轮的变化，调试模式跟普通的运行一样，也会执行我们的Java程序，但是我们可以添加断点，也就是说当代码运行到断点位置时，会在这里暂停，我们可以观察当代码执行到这个位置时各个变量的值：</p><p><img src="https://s2.loli.net/2022/09/18/A8lRmNZCqxLStwQ.png" alt="image-20220918112006020"></p><p>调试模式在我们后面的学习中非常重要，影响深远，所以说各位小伙伴一定要学会。调试也很简单，我们只需要点击右上角的调试选项即可（图标像一个小虫子一样，因为调试的英文名称是Debug）</p><p><img src="https://s2.loli.net/2022/09/18/VKMGoJazvXAnh2k.png" alt="image-20220918112101677"></p><p>调试开始时，我们可以看到程序在断点位置暂停了：</p><p><img src="https://s2.loli.net/2022/09/18/Cdq1ifFvHwMuO29.png" alt="image-20220918112227207"></p><p>此时我们可以观察到当前的局部变量<code>i</code>的值，也可以直接在下方的调试窗口中查看：</p><p><img src="https://s2.loli.net/2022/09/18/e6AODRMCgqmGwTy.png" alt="image-20220918112409944"></p><p>随着循环的进行，i的值也会逐渐自增：</p><p><img src="https://s2.loli.net/2022/09/18/bS1DxpgwOfWhujy.png" alt="image-20220918112628585"></p><p>当<code>i</code>增长到2时，此时来到最后一轮循环，再继续向下运行，就不再满足循环条件了，所以说此时就会结束循环。</p><p>当然，如果要执行多条语句的话，只需要使用花括号囊括就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;当前i的值为：&quot;</span>+i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的<code>i</code>仅仅是for循环语句中创建的变量，所以说其作用域被限制在了循环体中，一旦离开循环体，那么就无法使用了：</p><p><img src="https://s2.loli.net/2022/09/18/2aO9Ro5yfMUvhNc.png" alt="image-20220918112923978"></p><p>但是我们可以将<code>i</code>的创建放到外面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//在外面创建变量i，这样全部范围内都可以使用了</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="number">3</span>; i++) &#123;   <span class="comment">//for循环的三个表达式并不一定需要编写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前i的值为：&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前i的值为：&quot;</span>+i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前的<code>if</code>一样，for循环同样支持嵌套使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)    <span class="comment">//外层循环执行3次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)    <span class="comment">//内层循环也执行3次</span></span><br><span class="line">            System.out.println(<span class="string">&quot;1！5！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，外层循环会执行3轮，而整个循环体又是一个循环语句，那么也就是说，每一轮循环都会执行里面的整个循环，里面的整个循环会执行3，那么总共就会执行3 x 3次，也就是9次打印语句。</p><p>实际上，for循环的三个表达式并不一定需要编写，我们甚至可以三个都不写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;)   <span class="comment">//如果什么都不写，相当于没有结束条件，这将会导致无限循环</span></span><br><span class="line">        System.out.println(<span class="string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有表达式2，那么整个for循环就没有结束条件，默认会判定为真，此时就会出现无限循环的情况（无限循环是很危险的，因为它会疯狂地消耗CPU资源来执行循环，可能很快你的CPU就满载了，一定要避免）</p><p>当然，我们也可以在循环过程中提前终止或是加速循环的进行，这里我们需要认识两个新的关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">continue</span>;   <span class="comment">//比如我们希望当i等于1时跳过这一轮，不执行后面的打印</span></span><br><span class="line">        System.out.println(<span class="string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前i的值为：&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用<code>continue</code>关键字来跳过本轮循环，直接开启下一轮。这里的跳过是指，循环体中，无论后面有没有未执行的代码，一律不执行，比如上面的判断如果成功，那么将执行<code>continue</code>进行跳过，虽然后面还有打印语句，但是不会再去执行了，而是直接结束当前循环，开启下一轮。</p><p>在某些情况下，我们可能希望提前结束循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">break</span>;   <span class="comment">//我们希望当i等于1时提前结束</span></span><br><span class="line">    System.out.println(<span class="string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;当前i的值为：&quot;</span>+i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用<code>break</code>关键字来提前终止整个循环，和上面一样，本轮循环中无论后续还有没有未执行的代码，都不会执行了，而是直接结束整个循环，跳出到循环外部。</p><p>虽然使用break和continue关键字能够更方便的控制循环，但是注意在多重循环嵌套下，它只对离它最近的循环生效（就近原则）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;    <span class="comment">//当i == j时加速循环</span></span><br><span class="line">        System.out.println(i+<span class="string">&quot;, &quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>continue</code>加速的对象并不是外层的for，而是离它最近的内层for循环，<code>break</code>也是同样的规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j) <span class="keyword">break</span>;    <span class="comment">//当i == j时终止循环</span></span><br><span class="line">        System.out.println(i+<span class="string">&quot;, &quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，要是我们就是想要终止或者是加速外层循环呢？我们可以为循环语句打上标记：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">outer: <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">4</span>; ++i) &#123;   <span class="comment">//在循环语句前，添加 标签: 来进行标记</span></span><br><span class="line">    inner: <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j) <span class="keyword">break</span> outer;    <span class="comment">//break后紧跟要结束的循环标记，当i == j时终止外层循环</span></span><br><span class="line">        System.out.println(i+<span class="string">&quot;, &quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个代码块中存在多个循环，那么直接对当前代码块的标记执行<code>break</code>时会直接跳出整个代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">outer: &#123;    <span class="comment">//直接对整个代码块打标签</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">7</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span> outer;   <span class="comment">//执行break时，会直接跳出整个代码块，而不是第一个循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;？？？&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然效果挺奇特的，但是一般情况下没人这么玩，所以说了解就行了。</p><p>前面我们介绍了for循环语句，我们接着来看第二种while循环，for循环要求我们填写三个表达式，而while相当于是一个简化版本，它只需要我们填写循环的维持条件即可，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件) 循环体;</span><br></pre></td></tr></table></figure><p>相比for循环，while循环更多的用在不明确具体的结束时机的情况下，而for循环更多用于明确知道循环的情况，比如我们现在明确要进行循环10次，此时用for循环会更加合适一些，又比如我们现在只知道当<code>i</code>大于10时需要结束循环，但是<code>i</code>在循环多少次之后才不满足循环条件我们并不知道，此时使用while就比较合适了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;   <span class="comment">//比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;   <span class="comment">//现在唯一知道的是循环条件，只要大于0那么就可以继续除</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        i /= <span class="number">2</span>;   <span class="comment">//每次循环都除以2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这种情况就非常适合使用while循环。</p><p>和for循环一样，while也支持使用break和continue来进行循环的控制，以及嵌套使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">10</span>) <span class="keyword">break</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        i /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以反转循环判断的时机，可以先执行循环内容，然后再做循环条件判断，这里要用到<code>do-while</code>语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确</span></span><br><span class="line">    <span class="keyword">do</span> &#123;  <span class="comment">//无论满不满足循环条件，先执行循环体里面的内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>);   <span class="comment">//再做判断，如果判断成功，开启下一轮循环，否则结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，面向过程相关的内容就讲解完毕了，从下一章开始，我们将进入面向对象编程的学习（类、数组、字符串）</p><hr><h2 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h2><p>面向过程的内容全部学习完成，我们来做几个练习题吧！</p><h3 id="寻找水仙花数"><a href="#寻找水仙花数" class="headerlink" title="寻找水仙花数"></a>寻找水仙花数</h3><blockquote><p>“水仙花数（Narcissistic number）也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number），水仙花数是指<strong>一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身。</strong>例如：1^3 + 5^3+ 3^3 = 153。”</p></blockquote><p>现在请你设计一个Java程序，打印出所有1000以内的水仙花数。</p><h3 id="打印九九乘法表"><a href="#打印九九乘法表" class="headerlink" title="打印九九乘法表"></a>打印九九乘法表</h3><p><img src="https://s2.loli.net/2022/09/18/zy1wuvj6gfHmAZS.jpg" alt="img"></p><p>现在我们要做的是在我们的程序中，也打印出这样的一个乘法表出来，请你设计一个Java程序来实现它。</p><p><img src="https://s2.loli.net/2022/09/18/Iek7OnbRoTw46Cl.jpg" alt="img"></p><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><blockquote><p>斐波那契数列（Fibonacci sequence），又称<a href="https://baike.baidu.com/item/%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2/115896">黄金分割</a>数列，因数学家莱昂纳多·斐波那契（Leonardo Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：<strong>1、1、2、3、5、8、13、21、34、……</strong>在数学上，斐波那契数列以如下被以递推的方法定义：<em>F</em>(0)=0，<em>F</em>(1)=1, <em>F</em>(n)=<em>F</em>(n - 1)+<em>F</em>(n - 2)（<em>n</em> ≥ 2，<em>n</em> ∈ N*）在现代物理、准<a href="https://baike.baidu.com/item/%E6%99%B6%E4%BD%93%E7%BB%93%E6%9E%84/10401467">晶体结构</a>、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从 1963 年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。</p></blockquote><p>斐波那契数列：1，1，2，3，5，8，13，21，34，55，89…，不难发现一个规律，实际上从第三个数开始，每个数字的值都是前两个数字的和，现在请你设计一个Java程序，可以获取斐波那契数列上任意一位的数字，比如获取第5个数，那么就是5。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">7</span>, result;  <span class="comment">//target是要获取的数，result是结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//请在这里实现算法</span></span><br><span class="line"></span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="java" scheme="https://www.hoveco.top/categories/java/"/>
    
    
    <category term="JavaSE" scheme="https://www.hoveco.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-学习笔记-面向对象高级（四）</title>
    <link href="https://www.hoveco.top/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/"/>
    <id>https://www.hoveco.top/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/</id>
    <published>2023-10-12T00:30:00.000Z</published>
    <updated>2023-10-12T14:49:22.045Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/09/22/lmKBNFc5wPEgjaS.png" alt="image-20220922170926093"></p><h1 id="面向对象高级篇"><a href="#面向对象高级篇" class="headerlink" title="面向对象高级篇"></a>面向对象高级篇</h1><p>经过前面的学习，我们已经了解了面向对象编程的大部分基础内容，这一部分，我们将继续探索面向对象编程过程中一些常用的东西。</p><h2 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h2><p>Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。Java中的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！</p><h3 id="包装类介绍"><a href="#包装类介绍" class="headerlink" title="包装类介绍"></a>包装类介绍</h3><p>所有的包装类层次结构如下：</p><p><img src="https://s2.loli.net/2022/09/22/mulb5VdvBLiWNe2.png" alt="5c3a6a27-6370-4c60-9bbc-8039e11e752d"></p><p>其中能够表示数字的基本类型包装类，继承自Number类，对应关系如下表：</p><ul><li>byte  -&gt;  Byte</li><li>boolean  -&gt;  Boolean</li><li>short  -&gt;  Short</li><li>char  -&gt;  Character</li><li>int -&gt; Integer</li><li>long -&gt;  Long</li><li>float -&gt; Float</li><li>double -&gt; Double</li></ul><p>我们可以直接使用，这里我们以Integer类为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);    <span class="comment">//将10包装为一个Integer类型的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包装类实际上就是将我们的基本数据类型，封装成一个类（运用了封装的思想）我们可以来看看Integer类中是怎么写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;  <span class="comment">//类中实际上就靠这个变量在存储包装的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Integer</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包装类型支持自动装箱，我们可以直接将一个对应的基本类型值作为对应包装类型引用变量的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="comment">//将int类型值作为包装类型使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是怎么做到的？为什么一个对象类型的值可以直接接收一个基本类类型的值？实际上这里就是自动装箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);    <span class="comment">//上面的写法跟这里是等价的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里本质上就是被自动包装成了一个Integer类型的对象，只是语法上为了简单，就支持像这样编写。既然能装箱，也是支持拆箱的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上上面的写法本质上就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i.intValue();   <span class="comment">//通过此方法变成基本类型int值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是自动拆箱，得益于包装类型的自动装箱和拆箱机制，我们可以让包装类型轻松地参与到基本类型的运算中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a * b;    <span class="comment">//直接自动拆箱成基本类型参与到计算中</span></span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为包装类是一个类，不是基本类型，所以说两个不同的对象，那么是不相等的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(a == b);    <span class="comment">//虽然a和b的值相同，但是并不是同一个对象，所以说==判断为假</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么自动装箱的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b = <span class="number">10</span>;</span><br><span class="line">    System.out.println(a == b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，通过自动装箱转换的Integer对象，如果值相同，得到的会是同一个对象，这是因为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)   <span class="comment">//这里会有一个IntegerCache，如果在范围内，那么会直接返回已经提前创建好的对象</span></span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IntegerCache会默认缓存-128<del>127之间的所有值，将这些值提前做成包装类放在数组中存放，虽然我们目前还没有学习数组，但是各位小伙伴只需要知道，我们如果直接让 -128</del>127之间的值自动装箱为Integer类型的对象，那么始终都会得到同一个对象，这是为了提升效率，因为小的数使用频率非常高，有些时候并不需要创建那么多对象，创建对象越多，内存也会消耗更多。</p><p>但是如果超出这个缓存范围的话，就会得到不同的对象了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">128</span>, b = <span class="number">128</span>;</span><br><span class="line">    System.out.println(a == b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就不会得到同一个对象了，因为超出了缓存的范围。同样的，Long、Short、Byte类型的包装类也有类似的机制，感兴趣的小伙伴可以自己点进去看看。</p><p>我们来看看包装类中提供了哪些其他的方法，包装类支持字符串直接转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;666&quot;</span>);   <span class="comment">//直接将字符串的666，转换为数字666</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，字符串转Integer有多个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;5555&quot;</span>);</span><br><span class="line">    <span class="comment">//Integer i = Integer.parseInt(&quot;5555&quot;);</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们甚至可以对十六进制和八进制的字符串进行解码，得到对应的int值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.decode(<span class="string">&quot;0xA6&quot;</span>);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以将十进制的整数转换为其他进制的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(Integer.toHexString(<span class="number">166</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，Integer中提供的方法还有很多，这里就不一一列出了。</p><h3 id="特殊包装类"><a href="#特殊包装类" class="headerlink" title="特殊包装类"></a>特殊包装类</h3><p>除了我们上面认识的这几种基本类型包装类之外，还有两个比较特殊的包装类型。</p><p>其中第一个是用于计算超大数字的BigInteger，我们知道，即使是最大的long类型，也只能表示64bit的数据，无法表示一个非常大的数，但是BigInteger没有这些限制，我们可以让他等于一个非常大的数字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> BigInteger.valueOf(Long.MAX_VALUE);    <span class="comment">//表示Long的最大值，轻轻松松</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过调用类中的方法，进行运算操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> BigInteger.valueOf(Long.MAX_VALUE);</span><br><span class="line">    i = i.multiply(BigInteger.valueOf(Long.MAX_VALUE));   <span class="comment">//即使是long的最大值乘以long的最大值，也能给你算出来</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看结果：</p><p><img src="https://s2.loli.net/2022/09/22/FTPGhgnAEm1QKkV.png" alt="image-20220922211414392"></p><p>可以看到，此时数值已经非常大了，也可以轻松计算出来。咱们来点更刺激的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> BigInteger.valueOf(Long.MAX_VALUE);</span><br><span class="line">    i = i.pow(<span class="number">100</span>);   <span class="comment">//long的最大值来个100次方吧</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个数字已经大到一排显示不下了：</p><p><img src="https://s2.loli.net/2022/09/22/w1OoFmbLiJ4rlcV.png" alt="image-20220922211651719"></p><p>一般情况，对于非常大的整数计算，我们就可以使用BigInteger来完成。</p><p>我们接着来看第二种，前面我们说了，浮点类型精度有限，对于需要精确计算的场景，就没办法了，而BigDecimal可以实现小数的精确计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">i</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">10</span>);</span><br><span class="line">    i = i.divide(BigDecimal.valueOf(<span class="number">3</span>), <span class="number">100</span>, RoundingMode.CEILING);</span><br><span class="line">  <span class="comment">//计算10/3的结果，精确到小数点后100位</span></span><br><span class="line">  <span class="comment">//RoundingMode是舍入模式，就是精确到最后一位时，该怎么处理，这里CEILING表示向上取整</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，确实可以精确到这种程度：</p><p><img src="https://s2.loli.net/2022/09/22/IUJ5rwzxonCBMT4.png" alt="image-20220922212222762"></p><p>但是注意，对于这种结果没有终点的，无限循环的小数，我们必须要限制长度，否则会出现异常。</p><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>我们接着来看一个比较特殊的类型，数组。</p><p>假设出现一种情况，我们想记录100个数字，要是采用定义100个变量的方式可以吗？是不是有点太累了？这种情况我们就可以使用数组来存放一组相同类型的数据。</p><p><img src="https://s2.loli.net/2022/09/22/y4ISWZLrYE3Pdig.png" alt="image-20220922214604430"></p><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>数组是相同类型数据的有序集合，数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素，我们来看看如何去定义一个数组变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array;   <span class="comment">//类型[]就表示这个是一个数组类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，数组类型比较特殊，它本身也是类，但是编程不可见（底层C++写的，在运行时动态创建）即使是基本类型的数组，也是以对象的形式存在的，并不是基本数据类型。所以，我们要创建一个数组，同样需要使用<code>new </code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];   <span class="comment">//在创建数组时，需要指定数组长度，也就是可以容纳多个int变量的值</span></span><br><span class="line">  <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> array;   <span class="comment">//因为同样是类，肯定是继承自Object的，所以说可以直接向上转型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上面这种方式之外，我们也可以使用其他方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型[] 变量名称 = <span class="keyword">new</span> 类型[数组大小];</span><br><span class="line">类型 变量名称[] = <span class="keyword">new</span> 类型[数组大小];  <span class="comment">//支持C语言样式，但不推荐！</span></span><br><span class="line"></span><br><span class="line">类型[] 变量名称 = <span class="keyword">new</span> 类型[]&#123;...&#125;;  <span class="comment">//静态初始化（直接指定值和大小）</span></span><br><span class="line">类型[] 变量名称 = &#123;...&#125;;   <span class="comment">//同上，但是只能在定义时赋值</span></span><br></pre></td></tr></table></figure><p>创建出来的数组每个位置上都有默认值，如果是引用类型，就是null，如果是基本数据类型，就是0，或者是false，跟对象成员变量的默认值是一样的，要访问数组的某一个元素，我们可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    System.out.println(<span class="string">&quot;数组的第一个元素为：&quot;</span>+array[<span class="number">0</span>]);  <span class="comment">//使用 变量名[下标] 的方式访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，数组的下标是从0开始的，不是从1开始的，所以说第一个元素的下标就是0，我们要访问第一个元素，那么直接输入0就行了，但是注意千万别写成负数或是超出范围了，否则会出现异常。</p><p>我们也可以使用这种方式为数组的元素赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">888</span>;   <span class="comment">//就像使用变量一样，是可以放在赋值运算符左边的，我们可以直接给对应下标位置的元素赋值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;数组的第一个元素为：&quot;</span>+array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为数组本身也是一个对象，数组对象也是具有属性的，比如长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    System.out.println(<span class="string">&quot;当前数组长度为：&quot;</span>+array.length);   <span class="comment">//length属性是int类型的值，表示当前数组长度，长度是在一开始创建数组的时候就确定好的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这个<code>length</code>是在一开始就确定的，而且是<code>final</code>类型的，不允许进行修改，也就是说数组的长度一旦确定，不能随便进行修改，如果需要使用更大的数组，只能重新创建。</p><p>当然，既然是类型，那么肯定也是继承自Object类的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    System.out.println(array.toString());</span><br><span class="line">    System.out.println(array.equals(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，很遗憾，除了clone()之外，这些方法并没有被重写，也就是说依然是采用的Object中的默认实现：</p><p><img src="https://s2.loli.net/2022/09/22/UfTGu9sZheW21jB.png" alt="image-20220922220403391"></p><p>所以说通过<code>toString()</code>打印出来的结果，好丑，只不过我们可以发现，数组类型的类名很奇怪，是<code>[</code>开头的。</p><p>因此，如果我们要打印整个数组中所有的元素，得一个一个访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        System.out.print(array[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候为了方便，我们可以使用简化版的for语句<code>foreach</code>语法来遍历数组中的每一个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : array) &#123;    <span class="comment">//int i就是每一个数组中的元素，array就是我们要遍历的数组</span></span><br><span class="line">        System.out.print(i+<span class="string">&quot; &quot;</span>);   <span class="comment">//每一轮循环，i都会更新成数组中下一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉这种写法更加简洁？只不过这仅仅是语法糖而已，编译之后依然是跟上面一样老老实实在遍历的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;   <span class="comment">//反编译的结果</span></span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>[] var2 = array;</span><br><span class="line">    <span class="type">int</span> <span class="variable">var3</span> <span class="operator">=</span> array.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> var2[var4];</span><br><span class="line">        System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种普通的数组，其实使用还是挺简单的。这里需要特别说一下，对于基本类型的数组来说，是不支持自动装箱和拆箱的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    Integer[] test = arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有，由于基本数据类型和引用类型不同，所以说int类型的数组时不能被Object类型的数组变量接收的：</p><p><img src="https://s2.loli.net/2022/09/24/XbfZ9YHkqjv7613.png" alt="image-20220924114859252"></p><p>但是如果是引用类型的话，是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">    Object[] array = arr;    <span class="comment">//数组同样支持向上转型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Object[] arr = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">    String[] array = (String[]) arr;   <span class="comment">//也支持向下转型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>前面我们介绍了简单的数组（一维数组）既然数组可以是任何类型的，那么我们能否创建数组类型的数组呢？答案是可以的，套娃嘛，谁不会：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">10</span>];    <span class="comment">//数组类型数组那么就要写两个[]了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存放数组的数组，相当于将维度进行了提升，比如上面的就是一个2x10的数组：</p><p><img src="https://s2.loli.net/2022/09/22/kRcO1aGY6fMBiu9.png" alt="image-20220922221557130"></p><p>这个中数组一共有2个元素，每个元素都是一个存放10个元素的数组，所以说最后看起来就像一个矩阵一样。甚至可以继续套娃，将其变成一个三维数组，也就是存放数组的数组的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] arr = &#123; &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">5</span>, <span class="number">6</span>&#125;&#125;;   <span class="comment">//一个三行两列的数组</span></span><br><span class="line">    System.out.println(arr[<span class="number">2</span>][<span class="number">1</span>]);   <span class="comment">//访问第三行第二列的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在访问多维数组时，我们需要使用多次<code>[]</code>运算符来得到对应位置的元素。如果我们要遍历多维数组话，那么就需要多次嵌套循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;    <span class="comment">//要遍历一个二维数组，那么我们得一列一列一行一行地来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            System.out.println(arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h3><p>我们接着来看数组的延伸应用，实际上我们的方法是支持可变长参数的，什么是可变长参数？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String... strings)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在使用时，可以传入0 - N个对应类型的实参：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    person.test(<span class="string">&quot;1！&quot;</span>, <span class="string">&quot;5！&quot;</span>, <span class="string">&quot;哥们在这跟你说唱&quot;</span>); <span class="comment">//这里我们可以自由传入任意数量的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们在方法中怎么才能得到这些传入的参数呢，实际上可变长参数本质就是一个数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String... strings)</span>&#123;   <span class="comment">//strings这个变量就是一个String[]类型的</span></span><br><span class="line">    <span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">        System.out.println(string);   <span class="comment">//遍历打印数组中每一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果同时存在其他参数，那么可变长参数只能放在最后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, String... strings)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最后我们再来说一个从开始到现在一直都没有说的东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;   <span class="comment">//这个String[] args到底是个啥？？？</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这个是我们在执行Java程序时，输入的命令行参数，我们可以来打印一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">        System.out.println(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，默认情况下直接运行什么都没有，但是如果我们在运行时，添加点内容的话：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java com/test/Main lbwnb aaaa xxxxx   <span class="comment">#放在包中需要携带主类完整路径才能运行</span></span><br></pre></td></tr></table></figure><p>可以看到，我们在后面随意添加的三个参数，都放到数组中了：</p><p><img src="https://s2.loli.net/2022/09/22/DL3WTMdRwrSYJIl.png" alt="image-20220922223152648"></p><p>这个东西我们作为新手一般也不会用到，只做了解就行了。</p><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串类是一个比较特殊的类，它用于保存字符串。我们知道，基本类型<code>char</code>可以保存一个2字节的Unicode字符，而字符串则是一系列字符的序列（在C中就是一个字符数组）Java中没有字符串这种基本类型，因此只能使用类来进行定义。注意，字符串中的字符一旦确定，无法进行修改，只能重新创建。</p><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>String本身也是一个类，只不过它比较特殊，每个用双引号括起来的字符串，都是String类型的一个实例对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以象征性地使用一下new关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World!&quot;</span>);  <span class="comment">//这种方式就是创建一个新的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果是直接使用双引号创建的字符串，如果内容相同，为了优化效率，那么始终都是同一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    System.out.println(str1 == str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果我们使用构造方法主动创建两个新的对象，那么就是不同的对象了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    System.out.println(str1 == str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么会出现这种情况，我们在JVM篇视频教程中会进行详细的介绍，这里各位小伙伴只需要记住就行了。因此，如果我们仅仅是想要判断两个字符串的内容是否相同，不要使用<code>==</code>，String类重载了<code>equals</code>方法用于判断和比较内容是否相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    System.out.println(str1.equals(str2));   <span class="comment">//字符串的内容比较，一定要用equals</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然String也是一个类，那么肯定是具有一些方法的，我们可以来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    System.out.println(str.length());   <span class="comment">//length方法可以求字符串长度，这个长度是字符的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为双引号括起来的字符串本身就是一个实例对象，所以说我们也可以直接用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>.length());   <span class="comment">//虽然看起来挺奇怪的，但是确实支持这种写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串类中提供了很多方便我们操作的方法，比如字符串的裁剪、分割操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> str.substring(<span class="number">0</span>, <span class="number">3</span>);   <span class="comment">//分割字符串，并返回一个新的子串对象</span></span><br><span class="line">    System.out.println(sub);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    String[] strings = str.split(<span class="string">&quot; &quot;</span>);   <span class="comment">//使用split方法进行字符串分割，比如这里就是通过空格分隔，得到一个字符串数组</span></span><br><span class="line">    <span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符数组和字符串之间是可以快速进行相互转换的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">    System.out.println(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;奥&#x27;</span>, <span class="string">&#x27;利&#x27;</span>, <span class="string">&#x27;给&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，String类还有很多其他的一些方法，这里就不一一介绍了。</p><h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p>我们在之前的学习中已经了解，字符串支持使用<code>+</code>和<code>+=</code>进行拼接操作。</p><p>但是拼接字符串实际上底层需要进行很多操作，如果程序中大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接会在编译时进行各种优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;杰哥&quot;</span> + <span class="string">&quot;你干嘛&quot;</span>;    <span class="comment">//我们在写代码时使用的是拼接的形式</span></span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后就变成这样了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;杰哥你干嘛&quot;</span>;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于变量来说，也有优化，比如下面这种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;你看&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;这&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;汉堡&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;做滴&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;行不行&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> str1 + str2 + str3 + str4 + str5;   <span class="comment">//5个变量连续加</span></span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接使用加的话，每次运算都会生成一个新的对象，这里进行4次加法运算，那么中间就需要产生4个字符串对象出来，是不是有点太浪费了？这种情况实际上会被优化为下面的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;你看&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;这&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;汉堡&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;做滴&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;行不行&quot;</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    builder.append(str1).append(str2).append(str3).append(str4).append(str5);</span><br><span class="line">    System.out.println(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了一个StringBuilder的类型，这个类型是干嘛的呢？实际上它就是专门用于构造字符串的，我们可以使用它来对字符串进行拼接、裁剪等操作，它就像一个字符串编辑器，弥补了字符串不能修改的不足：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();   <span class="comment">//一开始创建时，内部什么都没有</span></span><br><span class="line">    builder.append(<span class="string">&quot;AAA&quot;</span>);   <span class="comment">//我们可以使用append方法来讲字符串拼接到后面</span></span><br><span class="line">    builder.append(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">    System.out.println(builder.toString());   <span class="comment">//当我们字符串编辑完成之后，就可以使用toString转换为字符串了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它还支持裁剪等操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;AAABBB&quot;</span>);   <span class="comment">//在构造时也可以指定初始字符串</span></span><br><span class="line">    builder.delete(<span class="number">2</span>, <span class="number">4</span>);   <span class="comment">//删除2到4这个范围内的字符</span></span><br><span class="line">    System.out.println(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，StringBuilder类的编辑操作也非常多，这里就不一一列出了。</p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>我们现在想要实现这样一个功能，对于给定的字符串进行判断，如果字符串符合我们的规则，那么就返回真，否则返回假，比如现在我们想要判断字符串是不是邮箱的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;aaaa731341@163.com&quot;</span>;</span><br><span class="line">  <span class="comment">//假设邮箱格式为 数字/字母@数字/字母.com</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么现在请你设计一个Java程序用于判断，你该怎么做？是不是感觉很麻烦，但是我们使用正则表达式就可以很轻松解决这种字符串格式匹配问题。</p><blockquote><p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p></blockquote><p>我们先来看看下面的这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;oooo&quot;</span>;</span><br><span class="line">  <span class="comment">//matches方法用于对给定正则表达式进行匹配，匹配成功返回true，否则返回false</span></span><br><span class="line">    System.out.println(str.matches(<span class="string">&quot;o+&quot;</span>));   <span class="comment">//+表示对前面这个字符匹配一次或多次，这里字符串是oooo，正好可以匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于规定给定组件必须要出现多少次才能满足匹配的，我们一般称为限定符，限定符表如下：</p><table><thead><tr><th align="center">字符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">*</td><td align="center">匹配前面的子表达式零次或多次。例如，<strong>zo*</strong> 能匹配 <strong>“z”</strong> 以及 <strong>“zoo”<strong>。</strong>*</strong> 等价于 **{0,}**。</td></tr><tr><td align="center">+</td><td align="center">匹配前面的子表达式一次或多次。例如，<strong>zo+</strong> 能匹配 <strong>“zo”</strong> 以及 “**zoo”**，但不能匹配 <strong>“z”<strong>。</strong>+</strong> 等价于 **{1,}**。</td></tr><tr><td align="center">?</td><td align="center">匹配前面的子表达式零次或一次。例如，<strong>do(es)?</strong> 可以匹配 <strong>“do”</strong> 、 <strong>“does”<strong>、 <strong>“doxy”</strong> 中的 <strong>“do”</strong> 。</strong>?</strong> 等价于 **{0,1}**。</td></tr><tr><td align="center">{n}</td><td align="center">n 是一个非负整数。匹配确定的 <strong>n</strong> 次。例如，<strong>o{2}</strong> 不能匹配 <strong>“Bob”</strong> 中的 <strong>o</strong>，但是能匹配 <strong>“food”</strong> 中的两个 <strong>o</strong>。</td></tr><tr><td align="center">{n,}</td><td align="center">n 是一个非负整数。至少匹配n 次。例如，<strong>o{2,}</strong> 不能匹配 <strong>“Bob”</strong> 中的 <strong>o</strong>，但能匹配 <strong>“foooood”</strong> 中的所有 <strong>o</strong>。<strong>o{1,}</strong> 等价于 <strong>o+<strong>。</strong>o{0,}</strong> 则等价于 **o***。</td></tr><tr><td align="center">{n,m}</td><td align="center">m 和 n 均为非负整数，其中 n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，<strong>o{1,3}</strong> 将匹配 <strong>“fooooood”</strong> 中的前三个 <strong>o</strong>。<strong>o{0,1}</strong> 等价于 **o?**。请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><p>如果我们想要表示一个范围内的字符，可以使用方括号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcabccaa&quot;</span>;</span><br><span class="line">    System.out.println(str.matches(<span class="string">&quot;[abc]*&quot;</span>));   <span class="comment">//表示abc这几个字符可以出现 0 - N 次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于普通字符来说，我们可以下面的方式实现多种字符匹配：</p><table><thead><tr><th align="center">字符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>[ABC]</strong></td><td align="center">匹配 <strong>[…]</strong> 中的所有字符，例如 <strong>[aeiou]</strong> 匹配字符串 “google runoob taobao” 中所有的 e o u a 字母。</td></tr><tr><td align="center"><strong>[^ABC]</strong></td><td align="center">匹配除了 <strong>[…]</strong> 中字符的所有字符，例如 <strong>[^aeiou]</strong> 匹配字符串 “google runoob taobao” 中除了 e o u a 字母的所有字母。</td></tr><tr><td align="center"><strong>[A-Z]</strong></td><td align="center">[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。</td></tr><tr><td align="center"><strong>.</strong></td><td align="center">匹配除换行符（\n、\r）之外的任何单个字符，相等于 [^\n\r]</td></tr><tr><td align="center"><strong>[\s\S]</strong></td><td align="center">匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。</td></tr><tr><td align="center"><strong>\w</strong></td><td align="center">匹配字母、数字、下划线。等价于 [A-Za-z0-9_]</td></tr></tbody></table><p>当然，这里仅仅是对正则表达式的简单使用，实际上正则表达式内容非常多，如果需要完整学习正则表达式，可以到：<a href="https://www.runoob.com/regexp/regexp-syntax.html">https://www.runoob.com/regexp/regexp-syntax.html</a></p><p>正则表达式并不是只有Java才支持，其他很多语言比如JavaScript、Python等等都是支持正则表达式的。</p><hr><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>上一章我们详细介绍了类，我们现在已经知道该如何创建类、使用类了。当然，类的创建其实可以有多种多样的方式，并不仅仅局限于普通的创建。内部类顾名思义，就是创建在内部的类，那么具体是什么的内部呢，我们接着就来讨论一下。</p><p><strong>注意：</strong>内部类很多地方都很绕，所以说一定要仔细思考。</p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>我们可以直接在类的内部定义成员内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;   <span class="comment">//内部类也是类，所以说里面也可以有成员变量、方法等，甚至还可以继续套娃一个成员内部类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是成员内部类！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员内部类和成员方法、成员变量一样，是对象所有的，而不是类所有的，如果我们要使用成员内部类，那么就需要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();   <span class="comment">//我们首先需要创建对象</span></span><br><span class="line">    Test.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> test.<span class="keyword">new</span> <span class="title class_">Inner</span>();   <span class="comment">//成员内部类的类型名称就是 外层.内部类名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然看着很奇怪，但是确实是这样使用的。我们同样可以使用成员内部类中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    Test.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> test.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    inner.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，成员内部类也可以使用访问权限控制，如果我们我们将其权限改为<code>private</code>，那么就像我们把成员变量访问权限变成私有一样，外部是无法访问到这个内部类的：</p><p><img src="https://s2.loli.net/2022/09/24/HklipN4uOfK9JrG.png" alt="image-20220924122217070"></p><p>可以看到这里直接不认识了。</p><p>这里我们需要特别注意一下，在成员内部类中，是可以访问到外层的变量的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是成员内部类：&quot;</span>+name);</span><br><span class="line">         <span class="comment">//成员内部类可以访问到外部的成员变量</span></span><br><span class="line">          <span class="comment">//因为成员内部类本身就是某个对象所有的，每个对象都有这样的一个类定义，这里的name是其所依附对象的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/24/aQPow8piljRCs2d.png" alt="image-20220924123600217"></p><p>每个类可以创建一个对象，每个对象中都有一个单独的类定义，可以通过这个成员内部类又创建出更多对象，套娃了属于是。</p><p>所以说我们在使用时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    Test.<span class="type">Inner</span> <span class="variable">inner1</span> <span class="operator">=</span> a.<span class="keyword">new</span> <span class="title class_">Inner</span>();   <span class="comment">//依附于a创建的对象，那么就是a的</span></span><br><span class="line">    inner1.test();</span><br><span class="line"></span><br><span class="line">    <span class="type">Test</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>(<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">    Test.<span class="type">Inner</span> <span class="variable">inner2</span> <span class="operator">=</span> b.<span class="keyword">new</span> <span class="title class_">Inner</span>();  <span class="comment">//依附于b创建的对象，那么就是b的</span></span><br><span class="line">    inner2.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那现在问大家一个问题，外部能访问内部类里面的成员变量吗？</p><p>那么如果内部类中也定义了同名的变量，此时我们怎么去明确要使用的是哪一个呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line"></span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;方法参数的name = &quot;</span>+name);    <span class="comment">//依然是就近原则，最近的是参数，那就是参数了</span></span><br><span class="line">            System.out.println(<span class="string">&quot;成员内部类的name = &quot;</span>+<span class="built_in">this</span>.name);   <span class="comment">//在内部类中使用this关键字，只能表示内部类对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;成员内部类的name = &quot;</span>+Test.<span class="built_in">this</span>.name);</span><br><span class="line">          <span class="comment">//如果需要指定为外部的对象，那么需要在前面添加外部类型名称</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包括对方法的调用和super关键字的使用，也是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.toString();<span class="comment">//内部类自己的toString方法</span></span><br><span class="line">        <span class="built_in">super</span>.toString();    <span class="comment">//内部类父类的toString方法</span></span><br><span class="line">        Test.<span class="built_in">this</span>.toString();   <span class="comment">//外部类的toSrting方法</span></span><br><span class="line">        Test.<span class="built_in">super</span>.toString();  <span class="comment">//外部类父类的toString方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说成员内部类其实在某些情况下使用起来比较麻烦，对于这种成员内部类，我们一般只会在类的内部自己使用。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>前面我们介绍了成员内部类，它就像成员变量和成员方法一样，是属于对象的，同样的，静态内部类就像静态方法和静态变量一样，是属于类的，我们可以直接创建使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是静态内部类！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要依附任何对象，我们可以直接创建静态内部类的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Test.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>.Inner();   <span class="comment">//静态内部类的类名同样是之前的格式，但是可以直接new了</span></span><br><span class="line">  inner.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类由于是静态的，所以相对外部来说，整个内部类中都处于静态上下文（注意只是相当于外部来说）是无法访问到外部类的非静态内容的：</p><p><img src="https://s2.loli.net/2022/09/24/cZapwgeATlG2FHn.png" alt="image-20220924124919135"></p><p>只不过受影响的只是外部内容的使用，内部倒是不受影响，还是跟普通的类一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是静态内部类：&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也很容易想通，因为静态内部类是属于外部类的，不依附任何对象，那么我要是直接访问外部类的非静态属性，那到底访问哪个对象的呢？这样肯定是说不通的。</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类就像局部变量一样，可以在方法中定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;    <span class="comment">//直接在方法中创建局部内部类</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是在方法中声明的类，那作用范围也就只能在方法中了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;   <span class="comment">//局部内部类跟局部变量一样，先声明后使用</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是局部内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();   <span class="comment">//局部内部类直接使用类名就行</span></span><br><span class="line">        inner.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过这种局部内部类的形式，使用频率很低，基本上不会用到，所以说了解就行了。</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类是我们使用频率非常高的一种内部类，它是局部内部类的简化版。</p><p>还记得我们在之前学习的抽象类和接口吗？在抽象类和接口中都会含有某些抽象方法需要子类去实现，我们当时已经很明确地说了不能直接通过new的方式去创建一个抽象类或是接口对象，但是我们可以使用匿名内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下，要创建一个抽象类的实例对象，只能对其进行继承，先实现未实现的方法，然后创建子类对象。</p><p>而我们可以在方法中使用匿名内部类，将其中的抽象方法实现，并直接创建实例对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>() &#123;   <span class="comment">//在new的时候，后面加上花括号，把未实现的方法实现了</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是匿名内部类的实现!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    student.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时这里创建出来的Student对象，就是一个已经实现了抽象方法的对象，这个抽象类直接就定义好了，甚至连名字都没有，就可以直接就创出对象。</p><p>匿名内部类中同样可以使用类中的属性（因为它本质上就相当于是对应类型的子类）所以说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>() &#123;</span><br><span class="line">    <span class="type">int</span> a;   <span class="comment">//因为本质上就相当于是子类，所以说子类定义一些子类的属性完全没问题</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;我是匿名内部类的实现!&quot;</span>);   <span class="comment">//直接使用父类中的name变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样的，接口也可以通过这种匿名内部类的形式，直接创建一个匿名的接口实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Study</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是学习方法！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    study.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，并不是说只有抽象类和接口才可以像这样创建匿名内部类，普通的类也可以，只不过意义不大，一般情况下只是为了进行一些额外的初始化工作而已。</p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>前面我们介绍了匿名内部类，我们可以通过这种方式创建一个临时的实现子类。</p><p>特别的，<strong>如果一个接口中有且只有一个待实现的抽象方法</strong>，那么我们可以将匿名内部类简写为Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;我是学习方法！&quot;</span>);   <span class="comment">//是不是感觉非常简洁！</span></span><br><span class="line">  study.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初学阶段，为了简化学习，各位小伙伴就认为Lambda表达式就是匿名内部类的简写就行了（Lambda表达式的底层其实并不只是简简单单的语法糖替换，感兴趣的可以在新特性篇视频教程中了解）</p><p>那么它是一个怎么样的简写规则呢？我们来看一下Lambda表达式的具体规范：</p><ul><li>标准格式为：<code>([参数类型 参数名称,]...) ‐&gt; &#123; 代码语句，包括返回值 &#125;</code></li><li>和匿名内部类不同，Lambda仅支持接口，不支持抽象类</li><li>接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）</li></ul><p>比如我们之前写的Study接口，只要求实现一个无参无返回值的方法，所以说直接就是最简单的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">&quot;我是学习方法！&quot;</span>);   <span class="comment">//跟之前流程控制一样，如果只有一行代码花括号可省略</span></span><br></pre></td></tr></table></figure><p>当然，如果有一个参数和返回值的话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> (a) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是学习方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;今天学会了&quot;</span>+a;    <span class="comment">//实际上这里面就是方法体，该咋写咋写</span></span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(study.study(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果方法体中只有一个返回语句，可以直接省去花括号和<code>return</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> (a) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;今天学会了&quot;</span>+a;   <span class="comment">//这种情况是可以简化的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> (a) -&gt; <span class="string">&quot;今天学会了&quot;</span>+a;</span><br></pre></td></tr></table></figure><p>如果参数只有一个，那么可以省去小括号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> a -&gt; <span class="string">&quot;今天学会了&quot;</span>+a;</span><br></pre></td></tr></table></figure><p>是不是感觉特别简洁，实际上我们程序员追求的就是写出简洁高效的代码，而Java也在朝这个方向一直努力，近年来从Java 9开始出现的一些新语法基本都是各种各样的简写版本。</p><p>如果一个方法的参数需要的是一个接口的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test(a -&gt; <span class="string">&quot;今天学会了&quot;</span>+a);   <span class="comment">//参数直接写成lambda表达式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Study study)</span>&#123;</span><br><span class="line">    study.study(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这还只是一部分，对于已经实现的方法，如果我们想直接作为接口抽象方法的实现，我们还可以使用方法引用。</p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>方法引用就是将一个已实现的方法，直接作为接口中抽象方法的实现（当然前提是方法定义得一样才行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;   <span class="comment">//待实现的求和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么使用时候，可以直接使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> (a, b) -&gt; a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过还能更简单，因为Integer类中默认提供了求两个int值之和的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer类中就已经有对应的实现了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们可以直接将已有方法的实现作为接口的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> (a, b) -&gt; Integer.sum(a, b);   <span class="comment">//直接使用Integer为我们通过好的求和方法</span></span><br><span class="line">    System.out.println(study.sum(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，Integer.sum的参数和返回值，跟我们在Study中定义的完全一样，所以说我们可以直接使用方法引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> Integer::sum;    <span class="comment">//使用双冒号来进行方法引用，静态方法使用 类名::方法名 的形式</span></span><br><span class="line">    System.out.println(study.sum(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法引用其实本质上就相当于将其他方法的实现，直接作为接口中抽象方法的实现。任何方法都可以通过方法引用作为实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    String <span class="title function_">study</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是普通从成员方法，我们同样需要使用对象来进行方法引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">    <span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> main::lbwnb;   <span class="comment">//成员方法因为需要具体对象使用，所以说只能使用 对象::方法名 的形式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">lbwnb</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;卡布奇诺今犹在，不见当年倒茶人。&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为现在只需要一个String类型的返回值，由于String的构造方法在创建对象时也会得到一个String类型的结果，所以说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> String::<span class="keyword">new</span>;    <span class="comment">//没错，构造方法也可以被引用，使用new表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反正只要是符合接口中方法的定义的，都可以直接进行方法引用，对于Lambda表达式和方法引用，在Java新特性介绍篇视频教程中还有详细的讲解，这里就不多说了。</p><hr><h2 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h2><p>在理想的情况下，我们的程序会按照我们的思路去运行，按理说是不会出现问题的，但是，代码实际编写后并不一定是完美的，可能会有我们没有考虑到的情况，如果这些情况能够正常得到一个错误的结果还好，但是如果直接导致程序运行出现问题了呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test(<span class="number">1</span>, <span class="number">0</span>);   <span class="comment">//当b为0的时候，还能正常运行吗？</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/b;   <span class="comment">//没有任何的判断而是直接做计算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们可以看到，出现了运算异常：</p><p><img src="https://s2.loli.net/2022/09/24/5PxTJv7M2YFzfg4.png" alt="image-20220924164357033"></p><p>那么这个异常到底是什么样的一种存在呢？当程序运行出现我们没有考虑到的情况时，就有可能出现异常或是错误！</p><h3 id="异常的类型"><a href="#异常的类型" class="headerlink" title="异常的类型"></a>异常的类型</h3><p>我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等，他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自<code>Exception</code>类！异常类型本质依然类的对象，但是异常类型支持在程序运行出现问题时抛出（也就是上面出现的红色报错）也可以提前声明，告知使用者需要处理可能会出现的异常！</p><p>异常的第一种类型是运行时异常，如上述的列子，在编译阶段无法感知代码是否会出现问题，只有在运行的时候才知道会不会出错（正常情况下是不会出错的），这样的异常称为运行时异常，异常也是由类定义的，所有的运行时异常都继承自<code>RuntimeException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    object.toString();   <span class="comment">//这种情况就会出现运行时异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/24/cTAqbZ93HidRIGW.png" alt="image-20220924164637887"></p><p>又比如下面的这种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> (Main) object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/24/QxMimbjZk19C25d.png" alt="image-20220924164844005"></p><p>异常的另一种类型是编译时异常，编译时异常明确指出可能会出现的异常，在编译阶段就需要进行处理（捕获异常）必须要考虑到出现异常的情况，如果不进行处理，将无法通过编译！默认继承自<code>Exception</code>类的异常都是编译时异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br></pre></td></tr></table></figure><p>比如Object类中定义的<code>clone</code>方法，就明确指出了在运行的时候会出现的异常。</p><p>还有一种类型是错误，错误比异常更严重，异常就是不同寻常，但不一定会导致致命的问题，而错误是致命问题，一般出现错误可能JVM就无法继续正常运行了，比如<code>OutOfMemoryError</code>就是内存溢出错误（内存占用已经超出限制，无法继续申请内存了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如这样的一个无限递归的方法，会导致运行过程中无限制地向下调用方法，导致栈溢出：</p><p><img src="https://s2.loli.net/2022/09/24/9YEZV2L73ROQTuA.png" alt="image-20220924165500108"></p><p>这种情况就是错误了，已经严重到整个程序都无法正常运行了。又比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Object[] objects = <span class="keyword">new</span> <span class="title class_">Object</span>[Integer.MAX_VALUE];   <span class="comment">//这里申请一个超级大数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上我们电脑的内存是有限的，不可能无限制地使用内存来存放变量，所以说如果内存不够用了，会直接：</p><p><img src="https://s2.loli.net/2022/09/24/qj8zJnGxdS5IybX.png" alt="image-20220924165657392"></p><p>此时没有更多的可用内存供我们的程序使用，那么程序也就没办法继续运行下去了，这同样是一个很严重的错误。</p><p>当然，我们这一块主要讨论的目录依然是异常。</p><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>异常其实就两大类，一个是编译时异常，一个是运行时异常，我们先来看编译时异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);   <span class="comment">//这里我们选择使用父类的带参构造，这个参数就是异常的原因</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时异常只需要继承Exception就行了，编译时异常的子类有很多很多，仅仅是SE中就有700多个。</p><p><img src="https://s2.loli.net/2022/09/24/TzUu5Sk6NycB9An.png" alt="image-20220924202450589"></p><p>异常多种多样，不同的异常对应着不同的情况，比如在类型转换时出错那么就是类型转换异常，如果是使用一个值为null的变量调用方法，那么就会出现空指针异常。</p><p>运行时异常只需要继承RuntimeException就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RuntimeException继承自Exception，Exception继承自Throwable：</p><p><img src="https://s2.loli.net/2022/09/24/RjzWnNDc6TZeSoJ.png" alt="image-20220924203130042"></p><p>运行时异常同同样也有很多，只不过运行时异常和编译型异常在使用时有一些不同，我们会在后面的学习中慢慢认识。</p><p>当然还有一种类型是Error，它是所有错误的父类，同样是继承自Throwable的。</p><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>当别人调用我们的方法时，如果传入了错误的参数导致程序无法正常运行，这时我们就可以手动抛出一个异常来终止程序继续运行下去，同时告知上一级方法执行出现了问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;被除数不能为0&quot;</span>);  <span class="comment">//使用throw关键字来抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常的抛出同样需要创建一个异常对象出来，我们抛出异常实际上就是将这个异常对象抛出，异常对象携带了我们抛出异常时的一些信息，比如是因为什么原因导致的异常，在RuntimeException的构造方法中我们可以写入原因。</p><p>当出现异常时：</p><p><img src="https://s2.loli.net/2022/09/24/Ttr4kZSyodKi3M8.png" alt="image-20220924200817314"></p><p>程序会终止，并且会打印栈追踪信息，因为各位小伙伴才初学，还不知道什么是栈，我们这里就简单介绍一下，实际上方法之间的调用是有层级关系的，而当异常发生时，方法调用的每一层都会在栈追踪信息中打印出来，比如这里有两个<code>at</code>，实际上就是在告诉我们程序运行到哪个位置时出现的异常，位于最上面的就是发生异常的最核心位置，我们代码的第15行。</p><p>并且这里会打印出当前抛出的异常类型和我们刚刚自定义异常信息。</p><p>注意，如果我们在方法中抛出了一个非运行时异常，那么必须告知函数的调用方我们会抛出某个异常，函数调用方必须要对抛出的这个异常进行对应的处理才可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;    <span class="comment">//使用throws关键字告知调用方此方法会抛出哪些异常，请调用方处理好</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;我是编译时异常！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果不同的分支条件会出现不同的异常，那么所有在方法中可能会抛出的异常都需要注明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">throws</span> FileNotFoundException, ClassNotFoundException &#123;  <span class="comment">//多个异常使用逗号隔开</span></span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>();</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，并不是只有非运行时异常可以像这样明确指出，运行时异常也可以，只不过不强制要求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于如何处理明确抛出的异常，我们会下一个部分中进行讲解。</p><p>最后再提一下，我们在重写方法时，如果父类中的方法表明了会抛出某个异常，只要重写的内容中不会抛出对应的异常我们可以直接省去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><p>当程序没有按照我们理想的样子运行而出现异常时（默认会交给JVM来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息）现在我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;    <span class="comment">//使用try-catch语句进行异常捕获</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        object.toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e)&#123;   <span class="comment">//因为异常本身也是一个对象，catch中实际上就是用一个局部变量去接收异常</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序继续正常运行！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将代码编写到<code>try</code>语句块中，只要是在这个范围内发生的异常，都可以被捕获，使用<code>catch</code>关键字对指定的异常进行捕获，这里我们捕获的是NullPointerException空指针异常：</p><p><img src="https://s2.loli.net/2022/09/24/7Ek5A46QHNKtWoJ.png" alt="image-20220924195434572"></p><p>可以看到，当我们捕获异常之后，程序可以继续正常运行，并不会像之前一样直接结束掉。</p><p>注意，catch中捕获的类型只能是Throwable的子类，也就是说要么是抛出的异常，要么是错误，不能是其他的任何类型。</p><p>我们可以在<code>catch</code>语句块中对捕获到的异常进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        object.toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">        e.printStackTrace();   <span class="comment">//打印栈追踪信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;异常错误信息：&quot;</span>+e.getMessage());   <span class="comment">//获取异常的错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序继续正常运行！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/24/d15ns6hQblU8TAS.png" alt="image-20220924201405697"></p><p>如果某个方法明确指出会抛出哪些异常，除非抛出的异常是一个运行时异常，否则我们必须要使用try-catch语句块进行异常的捕获，不然就无法通过编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test(<span class="number">10</span>);    <span class="comment">//必须要进行异常的捕获，否则报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">throws</span> IOException &#123;  <span class="comment">//明确会抛出IOException</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果我们确实不想在当前这个方法中进行处理，那么我们可以继续踢皮球，抛给上一级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;  <span class="comment">//继续编写throws往上一级抛</span></span><br><span class="line">    test(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果已经是主方法了，那么就相当于到顶层了，此时发生异常再往上抛出的话，就会直接交给JVM进行处理，默认会让整个程序终止并打印栈追踪信息。</p><p>注意，如果我们要捕获的异常，是某个异常的父类，那么当发生这个异常时，同样可以捕获到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">100</span>;    <span class="comment">//这里发生的是数组越界异常，它是运行时异常的子类</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e)&#123;  <span class="comment">//使用运行时异常同样可以捕获到</span></span><br><span class="line">        System.out.println(<span class="string">&quot;捕获到异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当代码可能出现多种类型的异常时，我们希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            </span><br><span class="line">&#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e)&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e)&#123;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是要注意一下顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e)&#123;  <span class="comment">//父类型在前，会将子类的也捕获</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;   <span class="comment">//永远都不会被捕获</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e)&#123;   <span class="comment">//永远都不会被捕获</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过这样写好像有点丑，我们也可以简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//....</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException | IndexOutOfBoundsException e) &#123;  <span class="comment">//用|隔开每种类型即可</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果简写的话，那么发生这些异常的时候，都会采用统一的方式进行处理了。</p><p>最后，当我们希望，程序运行时，无论是否出现异常，都会在最后执行任务，可以交给<code>finally</code>语句块来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            </span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;lbwnb&quot;</span>);   <span class="comment">//无论是否出现异常，都会在最后执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>try</code>语句块至少要配合<code>catch</code>或<code>finally</code>中的一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    a /= <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;  <span class="comment">//不捕获异常，程序会终止，但在最后依然会执行下面的内容</span></span><br><span class="line">    System.out.println(<span class="string">&quot;lbwnb&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思考：</strong><code>try</code>、<code>catch</code>和<code>finally</code>执行顺序？</p><h3 id="断言表达式"><a href="#断言表达式" class="headerlink" title="断言表达式"></a>断言表达式</h3><p>我们可以使用断言表达式来对某些东西进行判断，如果判断失败会抛出错误，只不过默认情况下没有开启断言，我们需要在虚拟机参数中手动开启一下：</p><p><img src="https://s2.loli.net/2022/09/24/cAG8kY395fOuTLg.png" alt="image-20220924220327591"></p><p>开启断言之后，我们就可以开始使用了。</p><p>断言表达式需要使用到<code>assert</code>关键字，如果assert后面的表达式判断结果为false，将抛出AssertionError错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们可以判断变量的值，如果大于10就抛出错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">assert</span> a &gt; <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/24/12b6zRAL3evQ9ZB.png" alt="image-20220924220704026"></p><p>我们可以在表达式的后面添加错误信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">assert</span> a &gt; <span class="number">10</span> : <span class="string">&quot;我是自定义的错误信息&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就会显示到错误后面了：</p><p><img src="https://s2.loli.net/2022/09/24/NaYk5pFiBPLXVIr.png" alt="image-20220924220813609"></p><p>断言表达式一般只用于测试，我们正常的程序中一般不会使用，这里只做了解就行了。</p><hr><h2 id="常用工具类介绍"><a href="#常用工具类介绍" class="headerlink" title="常用工具类介绍"></a>常用工具类介绍</h2><p>前面我们学习了包装类、数组和字符串，我们接着来看看常用的一些工具类。工具类就是专门为一些特定场景编写的，便于我们去使用的类，工具类一般都会内置大量的静态方法，我们可以通过类名直接使用。</p><h3 id="数学工具类"><a href="#数学工具类" class="headerlink" title="数学工具类"></a>数学工具类</h3><p>Java提供的运算符实际上只能进行一些在小学数学中出现的运算，但是如果我们想要进行乘方、三角函数之类的高级运算，就没有对应的运算符能够做到，而此时我们就可以使用数学工具类来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//Math也是java.lang包下的类，所以说默认就可以直接使用</span></span><br><span class="line">    System.out.println(Math.pow(<span class="number">5</span>, <span class="number">3</span>));   <span class="comment">//我们可以使用pow方法直接计算a的b次方</span></span><br><span class="line">  </span><br><span class="line">  Math.abs(-<span class="number">1</span>);    <span class="comment">//abs方法可以求绝对值</span></span><br><span class="line">  Math.max(<span class="number">19</span>, <span class="number">20</span>);    <span class="comment">//快速取最大值</span></span><br><span class="line">  Math.min(<span class="number">2</span>, <span class="number">4</span>);   <span class="comment">//快速取最小值</span></span><br><span class="line">  Math.sqrt(<span class="number">9</span>);    <span class="comment">//求一个数的算术平方根</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，三角函数肯定也是安排上了的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.sin(Math.PI / <span class="number">2</span>);     <span class="comment">//求π/2的正弦值，这里我们可以使用预置的PI进行计算</span></span><br><span class="line">Math.cos(Math.PI);       <span class="comment">//求π的余弦值</span></span><br><span class="line">Math.tan(Math.PI / <span class="number">4</span>);    <span class="comment">//求π/4的正切值</span></span><br><span class="line"></span><br><span class="line">Math.asin(<span class="number">1</span>);     <span class="comment">//三角函数的反函数也是有的，这里是求arcsin1的值</span></span><br><span class="line">Math.acos(<span class="number">1</span>);</span><br><span class="line">Math.atan(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可能在某些情况下，计算出来的浮点数会得到一个很奇怪的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(Math.sin(Math.PI));   <span class="comment">//计算 sinπ 的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/23/fZ6OVRejDXWSalC.png" alt="image-20220923231536032"></p><p>正常来说，sinπ的结果应该是0才对，为什么这里得到的是一个很奇怪的数？这个E是干嘛的，这其实是科学计数法的10，后面的数就是指数，上面的结果其实就是：</p><ul><li>$1.2246467991473532 \times 10^{-16}$</li></ul><p>其实这个数是非常接近于0，这是因为精度问题导致的，所以说实际上结果就是0。</p><p>我们也可以快速计算对数函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Math.log(Math.E);    <span class="comment">//e为底的对数函数，其实就是ln，我们可以直接使用Math中定义好的e</span></span><br><span class="line">    Math.log10(<span class="number">100</span>);     <span class="comment">//10为底的对数函数</span></span><br><span class="line">    <span class="comment">//利用换底公式，我们可以弄出来任何我们想求的对数函数</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> Math.log(<span class="number">4</span>) / Math.log(<span class="number">2</span>);   <span class="comment">//这里是求以2为底4的对数，log(2)4 = ln4 / ln2</span></span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一些比较特殊的计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Math.ceil(<span class="number">4.5</span>);    <span class="comment">//通过使用ceil来向上取整</span></span><br><span class="line">    Math.floor(<span class="number">5.6</span>);   <span class="comment">//通过使用floor来向下取整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向上取整就是找一个大于当前数字的最小整数，向下取整就是砍掉小数部分。注意，如果是负数的话，向上取整就是去掉小数部分，向下取整就是找一个小于当前数字的最大整数。</p><p>这里我们再介绍一下随机数的生成，Java中想要生成一个随机数其实也很简单，我们需要使用Random类来生成（这个类时java.util包下的，需要手动导入才可以）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();   <span class="comment">//创建Random对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">        System.out.print(random.nextInt(<span class="number">100</span>)+<span class="string">&quot; &quot;</span>);  <span class="comment">//nextInt方法可以指定创建0 - x之内的随机数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为，可以看到确实是一堆随机数：</p><p><img src="https://s2.loli.net/2022/09/23/fM8J7zO2qHXhvst.png" alt="image-20220923234642670"></p><p>只不过，程序中的随机并不是真随机，而是根据某些东西计算出来的，只不过计算过程非常复杂，能够在一定程度上保证随机性（根据爱因斯坦理论，宏观物质世界不存在真随机，看似随机的事物只是现目前无法计算而已，唯物主义的公理之一就是任何事物都有因果关系）</p><h3 id="数组工具类"><a href="#数组工具类" class="headerlink" title="数组工具类"></a>数组工具类</h3><p>前面我们介绍了数组，但是我们发现，想要操作数组实在是有点麻烦，比如我们要打印一个数组，还得一个一个元素遍历才可以，那么有没有一个比较方便的方式去使用数组呢？我们可以使用数组工具类Arrays。</p><p>这个类也是<code>java.util</code>包下类，它用于便捷操作数组，比如我们想要打印数组，可以直接通过toString方法转换字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/23/fx61nKT7LjdMv5q.png" alt="image-20220923235747731"></p><p>是不是感觉非常方便？这样我们直接就可以打印数组了！</p><p>除了这个方法，它还支持将数组进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    Arrays.sort(arr);    <span class="comment">//可以对数组进行排序，将所有的元素按照从小到大的顺序排放</span></span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感兴趣的小伙伴可以在数据结构与算法篇视频教程中了解多种多样的排序算法，这里的排序底层实现实际上用到了多种排序算法。</p><p>数组中的内容也可以快速进行填充：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    Arrays.fill(arr, <span class="number">66</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以快速地对一个数组进行拷贝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] target = Arrays.copyOf(arr, <span class="number">5</span>);</span><br><span class="line">    System.out.println(Arrays.toString(target));   <span class="comment">//拷贝数组的全部内容，并生成一个新的数组对象</span></span><br><span class="line">    System.out.println(arr == target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] target = Arrays.copyOfRange(arr, <span class="number">3</span>, <span class="number">5</span>);   <span class="comment">//也可以只拷贝某个范围内的内容</span></span><br><span class="line">    System.out.println(Arrays.toString(target));</span><br><span class="line">    System.out.println(arr == target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以将一个数组中的内容拷贝到其他数组中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] target = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    System.arraycopy(arr, <span class="number">0</span>, target, <span class="number">0</span>, <span class="number">5</span>);   <span class="comment">//使用System.arraycopy进行搬运</span></span><br><span class="line">    System.out.println(Arrays.toString(target));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个有序的数组（从小到大排列）我们可以使用二分搜索快速找到对应的元素在哪个位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    System.out.println(Arrays.binarySearch(arr, <span class="number">5</span>));   <span class="comment">//二分搜索仅适用于有序数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里提到了二分搜索算法，我们会在后面的实战练习中进行讲解。</p><p>那要是现在我们使用的是多维数组呢？因为现在数组里面的每个元素就是一个数组，所以说toString会出现些问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] array = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">1</span>&#125;, &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/24/L2at7HJi3BKf6jF.png" alt="image-20220924114142785"></p><p>只不过别担心，Arrays也支持对多维数组进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] array = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">1</span>&#125;, &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    System.out.println(Arrays.deepToString(array));    <span class="comment">//deepToString方法可以对多维数组进行打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，因为数组本身没有重写equals方法，所以说无法判断两个不同的数组对象中的每一个元素是否相同，Arrays也为一维数组和多维数组提供了相等判断的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">1</span>&#125;, &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span>[][] b = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">1</span>&#125;, &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    System.out.println(Arrays.equals(a, b));   <span class="comment">//equals仅适用于一维数组</span></span><br><span class="line">    System.out.println(Arrays.deepEquals(a, b));   <span class="comment">//对于多维数组，需要使用deepEquals来进行深层次判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里肯定有小伙伴疑问了，不是说基本类型的数组不能转换为引用类型的数组吗？为什么这里的deepEquals接受的是<code>Object[]</code>也可以传入参数呢？这是因为现在是二维数组，二维数组每个元素都是一个数组，而数组本身的话就是一个引用类型了，所以说可以转换为Object类型，但是如果是一维数组的话，就报错：</p><p><img src="https://s2.loli.net/2022/09/24/ab94eNcJPERlOYA.png" alt="image-20220924115440998"></p><p>总体来说，这个工具类对于我们数组的使用还是很方便的。</p><hr><h2 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h2><p>到目前为止，关于面向对象相关的内容我们已经学习了非常多了，接着依然是练习题。</p><h3 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h3><p>有一个int数组，但是数组内的数据是打乱的，现在我们需要将数组中的数据按<strong>从小到大</strong>的顺序进行排列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请你设计一个Java程序将这个数组中的元素按照顺序排列。</p><h3 id="二分搜索算法"><a href="#二分搜索算法" class="headerlink" title="二分搜索算法"></a>二分搜索算法</h3><p>现在有一个从小到大排序的数组，给你一个目标值<code>target</code>，现在我们想要找到这个值在数组中的对应下标，如果数组中没有这个数，请返回<code>-1</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请你设计一个Java程序实现这个功能。</p><h3 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h3><p>现在一共有n个台阶，一只青蛙每次只能跳一阶或是两阶，那么一共有多少种跳到顶端的方案？</p><p>例如n=2，那么一共有两种方案，一次性跳两阶或是每次跳一阶。</p><p>现在请你设计一个Java程序，计算当台阶数为n的情况下，能够有多少种方案到达顶端。</p><h3 id="回文串判断"><a href="#回文串判断" class="headerlink" title="回文串判断"></a>回文串判断</h3><p>“回文串”是一个正读和反读都一样的字符串，请你实现一个Java程序，判断用户输入的字符串（仅出现英文字符）是否为“回文”串。</p><blockquote><p> ABCBA   就是一个回文串，因为正读反读都是一样的</p><p>ABCA   就不是一个回文串，因为反着读不一样</p></blockquote><h3 id="汉诺塔求解"><a href="#汉诺塔求解" class="headerlink" title="汉诺塔求解"></a>汉诺塔求解</h3><p>什么是汉诺塔？</p><blockquote><p><strong>汉诺塔</strong>（Tower of Hanoi），又称<strong>河内塔</strong>，是一个源于<a href="https://baike.baidu.com/item/%E5%8D%B0%E5%BA%A6/121904">印度</a>古老传说的<a href="https://baike.baidu.com/item/%E7%9B%8A%E6%99%BA%E7%8E%A9%E5%85%B7/223159">益智玩具</a>。<a href="https://baike.baidu.com/item/%E5%A4%A7%E6%A2%B5%E5%A4%A9/711550">大梵天</a>创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令<a href="https://baike.baidu.com/item/%E5%A9%86%E7%BD%97%E9%97%A8/1796550">婆罗门</a>把圆盘从下面开始</p><p><strong>按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</strong></p></blockquote><p><img src="https://s2.loli.net/2022/09/24/mMpDNwrKk6z3CIo.png" alt="img"></p><p>这三根柱子我们就依次命名为A、B、C，现在请你设计一个Java程序，计算N阶（n片圆盘）汉诺塔移动操作的每一步。</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="java" scheme="https://www.hoveco.top/categories/java/"/>
    
    
    <category term="JavaSE" scheme="https://www.hoveco.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-学习笔记-泛型（五）</title>
    <link href="https://www.hoveco.top/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/"/>
    <id>https://www.hoveco.top/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89/</id>
    <published>2023-10-12T00:30:00.000Z</published>
    <updated>2023-10-12T14:49:22.225Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/09/24/AulBzXWK6JCPMH5.png" alt="image-20220924223020333"></p><h1 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h1><p>在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们还会继续深入了解，从泛型开始，再到数据结构，最后再开始我们的集合类学习，循序渐进。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以<code>优秀、良好、合格</code> 来作为结果，还有一种就是 <code>60.0、75.5、92.5</code> 这样的数字分数，可能高等数学这门课是以数字成绩进行结算，而计算机网络实验这门课是以等级进行结算，这两种分数类型都有可能出现，那么现在该如何去设计这样的一个Score类呢？</p><p>现在的问题就是，成绩可能是<code>String</code>类型，也可能是<code>Integer</code>类型，如何才能很好的去存可能出现的两种类型呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Score</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String id;</span><br><span class="line">    Object value;  <span class="comment">//因为Object是所有类型的父类，因此既可以存放Integer也能存放String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(String name, String id, Object value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.score = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Score</span> <span class="variable">score</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Score</span>(<span class="string">&quot;数据结构与算法基础&quot;</span>, <span class="string">&quot;EP074512&quot;</span>, <span class="string">&quot;优秀&quot;</span>);  <span class="comment">//是String类型的</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> (Integer) score.score;  <span class="comment">//获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Object类型作为引用，对于使用者来说，由于是Object类型，所以说并不能直接判断存储的类型到底是String还是Integer，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺</p><p>所以说这种解决办法虽然可行，但并不是最好的方案。</p><p>为了解决以上问题，JDK 5新增了泛型，它能够在编译阶段就检查类型安全，大大提升开发效率。</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型其实就一个待定类型，我们可以使用一个特殊的名字表示泛型，泛型在定义时并不明确是什么类型，而是需要到使用时才会确定对应的泛型类型。</p><p>我们可以将一个类定义为一个泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Score</span>&lt;T&gt; &#123;   <span class="comment">//泛型类需要使用&lt;&gt;，我们需要在里面添加1 - N个类型变量</span></span><br><span class="line">    String name;</span><br><span class="line">    String id;</span><br><span class="line">    T value;   <span class="comment">//T会根据使用时提供的类型自动变成对应类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(String name, String id, T value)</span> &#123;   <span class="comment">//这里T可以是任何类型，但是一旦确定，那么就不能修改了</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看这是如何使用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Score&lt;String&gt; score = <span class="keyword">new</span> <span class="title class_">Score</span>&lt;String&gt;(<span class="string">&quot;计算机网络&quot;</span>, <span class="string">&quot;EP074512&quot;</span>, <span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">  <span class="comment">//因为现在有了类型变量，在使用时同样需要跟上&lt;&gt;并在其中填写明确要使用的类型</span></span><br><span class="line">  <span class="comment">//这样我们就可以根据不同的类型进行选择了</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> score.value;   <span class="comment">//一旦类型明确，那么泛型就变成对应的类型了</span></span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型，如果类型不符合，将无法通过编译！因为是具体使用对象时才会明确具体类型，所以说静态方法中是不能用的：</p><p><img src="https://s2.loli.net/2022/09/27/RCqAhvMGzNwfH7J.png" alt="image-20220927135128332"></p><p>只不过这里需要注意一下，我们在方法中使用待确定类型的变量时，因为此时并不明确具体是什么类型，那么默认会认为这个变量是一个Object类型的变量，因为无论具体类型是什么，一定是Object类的子类：</p><p><img src="https://s2.loli.net/2022/09/26/gkFs35US9rxo7f2.png" alt="image-20220926235642963"></p><p>我们可以对其进行强制类型转换，但是实际上没多大必要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T t)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) t;   <span class="comment">//都明确要用String了，那这里定义泛型不是多此一举吗</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为泛型本身就是对某些待定类型的简单处理，如果都明确要使用什么类型了，那大可不必使用泛型。还有，不能通过这个不确定的类型变量就去直接创建对象和对应的数组：</p><p><img src="https://s2.loli.net/2022/09/27/RlHYhPSUJ5ICswG.png" alt="image-20220927134825845"></p><p>注意，具体类型不同的泛型类变量，不能使用不同的变量进行接收：</p><p><img src="https://s2.loli.net/2022/09/25/jhekq9ZKHoiT2yI.png" alt="image-20220925170746329"></p><p>如果要让某个变量支持引用确定了任意类型的泛型，那么可以使用<code>?</code>通配符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Test&lt;?&gt; test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;Integer&gt;();</span><br><span class="line">    test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;String&gt;();</span><br><span class="line">  <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> test.value;    <span class="comment">//但是注意，如果使用通配符，那么由于类型不确定，所以说具体类型同样会变成Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，泛型变量不止可以只有一个，如果需要使用多个的话，我们也可以定义多个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;A, B, C&gt; &#123;   <span class="comment">//多个类型变量使用逗号隔开</span></span><br><span class="line">    <span class="keyword">public</span> A a;</span><br><span class="line">    <span class="keyword">public</span> B b;</span><br><span class="line">    <span class="keyword">public</span> C c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在使用时，就需要将这三种类型都进行明确指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Test&lt;String, Integer, Character&gt; test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;();  <span class="comment">//使用钻石运算符可以省略其中的类型</span></span><br><span class="line">    test.a = <span class="string">&quot;lbwnb&quot;</span>;</span><br><span class="line">    test.b = <span class="number">10</span>;</span><br><span class="line">    test.c = <span class="string">&#x27;淦&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉好像还是挺简单的？只要是在类中，都可以使用类型变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过，泛型只能确定为一个引用类型，基本类型是不支持的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> T value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/26/TI6tWwj4vXFdenr.png" alt="image-20220926232135111"></p><p>如果要存放基本数据类型的值，我们只能使用对应的包装类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Test&lt;Integer&gt; test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果是基本类型的数组，因为数组本身是引用类型，所以说是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Test&lt;<span class="type">int</span>[]&gt; test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用泛型，我们就可以将某些不明确的类型在具体使用时再明确。</p><h3 id="泛型与多态"><a href="#泛型与多态" class="headerlink" title="泛型与多态"></a>泛型与多态</h3><p>不只是类，包括接口、抽象类，都是可以支持泛型的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Study</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当子类实现此接口时，我们可以选择在实现类明确泛型类型，或是继续使用此泛型让具体创建的对象来确定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> a.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Study</span>&lt;Integer&gt; &#123;   </span><br><span class="line">      <span class="comment">//在实现接口或是继承父类时，如果子类是一个普通类，那么可以直接明确对应类型</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者是继续摆烂，依然使用泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        A&lt;String&gt; a = <span class="keyword">new</span> <span class="title class_">A</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">i</span> <span class="operator">=</span> a.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Study</span>&lt;T&gt; &#123;   </span><br><span class="line">      <span class="comment">//让子类继续为一个泛型类，那么可以不用明确</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承也是同样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span>&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>当然，类型变量并不是只能在泛型类中才可以使用，我们也可以定义泛型方法。</p><p>当某个方法（无论是是静态方法还是成员方法）需要接受的参数类型并不确定时，我们也可以使用泛型来表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> test(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">test</span><span class="params">(T t)</span>&#123;   <span class="comment">//在返回值类型前添加&lt;&gt;并填写泛型变量表示这个是一个泛型方法</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型方法会在使用时自动确定泛型类型，比如上我们定义的是类型T作为参数，同样的类型T作为返回值，实际传入的参数是一个字符串类型的值，那么T就会自动变成String类型，因此返回值也是String类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">    main.add(strings, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    System.out.println(Arrays.toString(strings));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T[] arr, T t)</span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上泛型方法在很多工具类中也有，比如说Arrays的排序方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line">Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;   </span><br><span class="line">  <span class="comment">//通过创建泛型接口的匿名内部类，来自定义排序规则，因为匿名内部类就是接口的实现类，所以说这里就明确了类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;   <span class="comment">//这个方法会在执行排序时被调用（别人来调用我们的实现）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>比如现在我们想要让数据从大到小排列，我们就可以自定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Integer[] arr = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;   <span class="comment">//两个需要比较的数会在这里给出</span></span><br><span class="line">            <span class="keyword">return</span> o2 - o1;    </span><br><span class="line">          <span class="comment">//compare方法要求返回一个int来表示两个数的大小关系，大于0表示大于，小于0表示小于</span></span><br><span class="line">          <span class="comment">//这里直接o2-o1就行，如果o2比o1大，那么肯定应该排在前面，所以说返回正数表示大于</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们前面学习了Lambda表达式，像这种只有一个方法需要实现的接口，直接安排了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Integer[] arr = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    Arrays.sort(arr, (o1, o2) -&gt; o2 - o1);   <span class="comment">//瞬间变一行，效果跟上面是一样的</span></span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包括数组复制方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] arr = &#123;<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>&#125;;</span><br><span class="line">    String[] newArr = Arrays.copyOf(arr, <span class="number">3</span>);   <span class="comment">//这里传入的类型是什么，返回的类型就是什么，也是用到了泛型</span></span><br><span class="line">    System.out.println(Arrays.toString(newArr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，泛型实际上在很多情况下都能够极大地方便我们对于程序的代码设计。</p><h3 id="泛型的界限"><a href="#泛型的界限" class="headerlink" title="泛型的界限"></a>泛型的界限</h3><p>现在有一个新的需求，现在没有String类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，我们就需要使用到泛型的上界定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Score</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;   <span class="comment">//设定类型参数上界，必须是Number或是Number的子类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(String name, String id, T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要在泛型变量的后面添加<code>extends</code>关键字即可指定上界，使用时，具体类型只能是我们指定的上界类型或是上界类型的子类，不得是其他类型。否则一律报错：</p><p><img src="https://s2.loli.net/2022/09/27/BAgmdCkDFL62V8H.png" alt="image-20220927000902574"></p><p>实际上就像这样：</p><p><img src="https://s2.loli.net/2022/09/27/rLnjHp73tdFSPUM.png" alt="img"></p><p>同样的，当我们在使用变量时，泛型通配符也支持泛型的界限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Score&lt;? <span class="keyword">extends</span> <span class="title class_">Integer</span>&gt; score = <span class="keyword">new</span> <span class="title class_">Score</span>&lt;&gt;(<span class="string">&quot;数据结构与算法&quot;</span>, <span class="string">&quot;EP074512&quot;</span>, <span class="number">60</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么既然泛型有上界，那么有没有下界呢？肯定的啊：</p><p><img src="https://s2.loli.net/2022/09/27/UJg7s41NC9Gn6fX.png" alt="image-20220927002611032"></p><p>只不过下界仅适用于通配符，对于类型变量来说是不支持的。下界限定就像这样：</p><p><img src="https://s2.loli.net/2022/09/27/QFZNSCpnAmKG7qr.png" alt="4aa52791-73f4-448f-bab3-9133ea85d850.jpg"></p><p>那么限定了上界后，我们再来使用这个对象的泛型成员，会变成什么类型呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Score&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; score = <span class="keyword">new</span> <span class="title class_">Score</span>&lt;&gt;(<span class="string">&quot;数据结构与算法基础&quot;</span>, <span class="string">&quot;EP074512&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">Number</span> <span class="variable">o</span> <span class="operator">=</span> score.getValue();   <span class="comment">//可以看到，此时虽然使用的是通配符，但是不再是Object类型，而是对应的上界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们限定下界的话，因为还是有可能是Object，所以说依然是跟之前一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Score&lt;? <span class="built_in">super</span> Number&gt; score = <span class="keyword">new</span> <span class="title class_">Score</span>&lt;&gt;(<span class="string">&quot;数据结构与算法基础&quot;</span>, <span class="string">&quot;EP074512&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> score.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过给设定泛型上限，我们就可以更加灵活地控制泛型的具体类型范围。</p><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>前面我们已经了解如何使用泛型，那么泛型到底是如何实现的呢，程序编译之后的样子是什么样的？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">abstract</span> T <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上在Java中并不是真的有泛型类型（为了兼容之前的Java版本）因为所有的对象都是属于一个普通的类型，一个泛型类型编译之后，实际上会直接使用默认的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> Object <span class="title function_">test</span><span class="params">(Object t)</span>;  <span class="comment">//默认就是Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果我们给类型变量设定了上界，那么会从默认类型变成上界定义的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt;&#123;   <span class="comment">//设定上界为Number</span></span><br><span class="line">    <span class="keyword">abstract</span> T <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么编译之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> Number <span class="title function_">test</span><span class="params">(Number t)</span>;  <span class="comment">//上界Number，因为现在只可能出现Number的子类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，泛型其实仅仅是在编译阶段进行类型检查，当程序在运行时，并不会真的去检查对应类型，所以说哪怕是我们不去指定类型也可以直接使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();    <span class="comment">//对于泛型类Test，不指定具体类型也是可以的，默认就是原始类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过此时编译器会给出警告：</p><p><img src="https://s2.loli.net/2022/09/27/kVCIg3TilOuLFmj.png" alt="image-20220927131226728"></p><p>同样的，由于类型擦除，实际上我们在使用时，编译后的代码是进行了强制类型转换的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    A&lt;String&gt; a = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    <span class="type">String</span>  <span class="variable">i</span> <span class="operator">=</span> a.test(<span class="string">&quot;10&quot;</span>);     <span class="comment">//因为类型A只有返回值为原始类型Object的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上编译之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">i</span> <span class="operator">=</span> (String) a.test(<span class="string">&quot;10&quot;</span>);   <span class="comment">//依靠强制类型转换完成的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，我们思考一个问题，既然继承泛型类之后可以明确具体类型，那么为什么<code>@Override</code>不会出现错误呢？我们前面说了，重写的条件是需要和父类的返回值类型和形参一致，而泛型默认的原始类型是Object类型，子类明确后变为其他类型，这显然不满足重写的条件，但是为什么依然能编译通过呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String <span class="title function_">test</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看编译之后长啥样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compiled from &quot;B.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.test.entity.B <span class="keyword">extends</span> <span class="title class_">com</span>.test.entity.A&lt;java.lang.String&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> com.test.entity.B();</span><br><span class="line">  java.lang.String <span class="title function_">test</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">  java.lang.Object <span class="title function_">test</span><span class="params">(java.lang.Object)</span>;   <span class="comment">//桥接方法，这才是真正重写的方法，但是使用时会调用上面的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反编译进行观察，实际上是编译器帮助我们生成了一个桥接方法用于支持重写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">test</span><span class="params">(Object obj)</span> &#123;   <span class="comment">//这才是重写的桥接方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.test((Integer) obj);   <span class="comment">//桥接方法调用我们自己写的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(String str)</span> &#123;   <span class="comment">//我们自己写的方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型擦除机制其实就是为了方便使用后面集合类（不然每次都要强制类型转换）同时为了向下兼容采取的方案。因此，泛型的使用会有一些限制：</p><p>首先，在进行类型判断时，不允许使用泛型，只能使用原始类型：</p><p><img src="https://s2.loli.net/2022/09/27/q7DQ9lAweJLOFky.png" alt="image-20220927133232627"></p><p>只能判断是不是原始类型，里面的具体类型是不支持的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test&lt;String&gt; test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;();</span><br><span class="line">System.out.println(test <span class="keyword">instanceof</span> Test);   <span class="comment">//在进行类型判断时，不允许使用泛型，只能使用原始类型</span></span><br></pre></td></tr></table></figure><p>还有，泛型类型是不支持创建参数化类型数组的：</p><p><img src="https://s2.loli.net/2022/09/27/7tK5APuSZovBLIc.png" alt="image-20220927133611288"></p><p>要用只能用原始类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Test[] test = <span class="keyword">new</span> <span class="title class_">Test</span>[<span class="number">10</span>];   <span class="comment">//同样是因为类型擦除导致的，运行时可不会去检查具体类型是什么</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过只是把它当做泛型类型的数组还是可以用的：</p><p><img src="https://s2.loli.net/2022/09/27/upjWbyq9XC5FLDv.png" alt="image-20220927134335255"></p><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>学习了泛型，我们来介绍一下再JDK 1.8中新增的函数式接口。</p><p>函数式接口就是JDK1.8专门为我们提供好的用于Lambda表达式的接口，这些接口都可以直接使用Lambda表达式，非常方便，这里我们主要介绍一下四个主要的函数式接口：</p><p><strong>Supplier供给型函数式接口：</strong>这个接口是专门用于供给使用的，其中只有一个get方法用于获取需要的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>   <span class="comment">//函数式接口都会打上这样一个注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;   <span class="comment">//实现此方法，实现供给功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们要实现一个专门供给Student对象Supplier，就可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是学生！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//专门供给Student对象的Supplier</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Supplier&lt;Student&gt; STUDENT_SUPPLIER = Student::<span class="keyword">new</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> STUDENT_SUPPLIER.get();</span><br><span class="line">    student.hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Consumer消费型函数式接口：</strong>这个接口专门用于消费某个对象的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;    <span class="comment">//这个方法就是用于消费的，没有返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Consumer&lt;T&gt; <span class="title function_">andThen</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; after)</span> &#123;   <span class="comment">//这个方法便于我们连续使用此消费接口</span></span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用起来也是很简单的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//专门消费Student对象的Consumer</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Consumer&lt;Student&gt; STUDENT_CONSUMER = student -&gt; System.out.println(student+<span class="string">&quot; 真好吃！&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    STUDENT_CONSUMER.accept(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们也可以使用<code>andThen</code>方法继续调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    STUDENT_CONSUMER   <span class="comment">//我们可以提前将消费之后的操作以同样的方式预定好</span></span><br><span class="line">            .andThen(stu -&gt; System.out.println(<span class="string">&quot;我是吃完之后的操作！&quot;</span>)) </span><br><span class="line">            .andThen(stu -&gt; System.out.println(<span class="string">&quot;好了好了，吃饱了！&quot;</span>))</span><br><span class="line">            .accept(student);   <span class="comment">//预定好之后，再执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就可以在消费之后进行一些其他的处理了，使用很简洁的代码就可以实现：</p><p><img src="https://s2.loli.net/2022/09/27/Pu1jGzKNSvnV9YZ.png" alt="image-20220927181706365"></p><p><strong>Function函数型函数式接口：</strong>这个接口消费一个对象，然后会向外供给一个对象（前两个的融合体）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;   <span class="comment">//这里一共有两个类型参数，其中一个是接受的参数类型，还有一个是返回的结果类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; Function&lt;V, R&gt; <span class="title function_">compose</span><span class="params">(Function&lt;? <span class="built_in">super</span> V, ? extends T&gt; before)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; Function&lt;T, V&gt; <span class="title function_">andThen</span><span class="params">(Function&lt;? <span class="built_in">super</span> R, ? extends V&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; Function&lt;T, T&gt; <span class="title function_">identity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口方法有点多，我们一个一个来看，首先还是最基本的<code>apply</code>方法，这个是我们需要实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里实现了一个简单的功能，将传入的int参数转换为字符串的形式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Function&lt;Integer, String&gt; INTEGER_STRING_FUNCTION = Object::toString;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> INTEGER_STRING_FUNCTION.apply(<span class="number">10</span>);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用<code>compose</code>将指定函数式的结果作为当前函数式的实参：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> INTEGER_STRING_FUNCTION</span><br><span class="line">            .compose((String s) -&gt; s.length())   <span class="comment">//将此函数式的返回值作为当前实现的实参</span></span><br><span class="line">            .apply(<span class="string">&quot;lbwnb&quot;</span>);   <span class="comment">//传入上面函数式需要的参数</span></span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相反的，<code>andThen</code>可以将当前实现的返回值进行进一步的处理，得到其他类型的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">str</span> <span class="operator">=</span> INTEGER_STRING_FUNCTION</span><br><span class="line">            .andThen(String::isEmpty)   <span class="comment">//在执行完后，返回值作为参数执行andThen内的函数式，最后得到的结果就是最终的结果了</span></span><br><span class="line">            .apply(<span class="number">10</span>);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较有趣的是，Function中还提供了一个将传入参数原样返回的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Function&lt;String, String&gt; function = Function.identity();   <span class="comment">//原样返回</span></span><br><span class="line">    System.out.println(function.apply(<span class="string">&quot;不会吧不会吧，不会有人听到现在还是懵逼的吧&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Predicate断言型函数式接口：</strong>接收一个参数，然后进行自定义判断并返回一个boolean结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;    <span class="comment">//这个方法就是我们要实现的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">and</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">negate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">or</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="title function_">isEqual</span><span class="params">(Object targetRef)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以来编写一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Predicate&lt;Student&gt; STUDENT_PREDICATE = student -&gt; student.score &gt;= <span class="number">60</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    student.score = <span class="number">80</span>;</span><br><span class="line">    <span class="keyword">if</span>(STUDENT_PREDICATE.test(student)) &#123;  <span class="comment">//test方法的返回值是一个boolean结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;及格了，真不错，今晚奖励自己一次&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不是，Java都考不及格？隔壁初中生都在打ACM了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以使用组合条件判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    student.score = <span class="number">80</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> STUDENT_PREDICATE</span><br><span class="line">            .and(stu -&gt; stu.score &gt; <span class="number">90</span>)   <span class="comment">//需要同时满足这里的条件，才能返回true</span></span><br><span class="line">            .test(student);</span><br><span class="line">    <span class="keyword">if</span>(!b) System.out.println(<span class="string">&quot;Java到现在都没考到90分？你的室友都拿国家奖学金了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，这个类型提供了一个对应的实现，用于判断两个对象是否相等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Predicate&lt;String&gt; predicate = Predicate.isEqual(<span class="string">&quot;Hello World&quot;</span>);   <span class="comment">//这里传入的对象会和之后的进行比较</span></span><br><span class="line">    System.out.println(predicate.test(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用这四个核心的函数式接口，我们就可以使得代码更加简洁，具体的使用场景会在后面讲解。</p><h3 id="判空包装"><a href="#判空包装" class="headerlink" title="判空包装"></a>判空包装</h3><p>Java8还新增了一个非常重要的判空包装类Optional，这个类可以很有效的处理空指针问题。</p><p>比如对于下面这样一个很简单的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span>&#123;   <span class="comment">//传入字符串，如果不是空串，那么就打印长度</span></span><br><span class="line">    <span class="keyword">if</span>(!str.isEmpty()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串长度为：&quot;</span>+str.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果我们在传入参数时，丢个null进去，直接原地爆炸：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(!str.isEmpty()) &#123;   <span class="comment">//此时传入的值为null，调用方法马上得到空指针异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;字符串长度为：&quot;</span>+str.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们还需要在使用之前进行判空操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">null</span>) <span class="keyword">return</span>;   <span class="comment">//这样就可以防止null导致的异常了</span></span><br><span class="line">    <span class="keyword">if</span>(!str.isEmpty()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串长度为：&quot;</span>+str.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这种方式很好，但是在Java8之后，有了Optional类，它可以更加优雅地处理这种问题，我们来看看如何使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    Optional</span><br><span class="line">            .ofNullable(str)   <span class="comment">//将传入的对象包装进Optional中</span></span><br><span class="line">            .ifPresent(s -&gt; System.out.println(<span class="string">&quot;字符串长度为：&quot;</span>+s.length()));  </span><br><span class="line">  <span class="comment">//如果不为空，则执行这里的Consumer实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优雅，真是太优雅了，同样的功能，现在我们只需要两行就搞定了，而且代码相当简洁。如果你学习过JavaScript或是Kotlin等语言，它的语法就像是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str : String? = <span class="literal">null</span></span><br><span class="line">str?.upperCase()</span><br></pre></td></tr></table></figure><p>并且，包装之后，我们再获取时可以优雅地处理为空的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Optional.ofNullable(str).get();   <span class="comment">//get方法可以获取被包装的对象引用，但是如果为空的话，会抛出异常</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以对于这种有可能为空的情况进行处理，如果为空，那么就返回另一个备选方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Optional.ofNullable(str).orElse(<span class="string">&quot;我是为null的情况备选方案&quot;</span>);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉很方便？我们还可以将包装的类型直接转换为另一种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Optional</span><br><span class="line">            .ofNullable(str)</span><br><span class="line">            .map(String::length)   <span class="comment">//使用map来进行映射，将当前类型转换为其他类型，或者是进行处理</span></span><br><span class="line">            .orElse(-<span class="number">1</span>);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，Optional的方法比较多，这里就不一一介绍了。</p><hr><h2 id="数据结构基础"><a href="#数据结构基础" class="headerlink" title="数据结构基础"></a>数据结构基础</h2><p><strong>注意：</strong>本部分内容难度很大，推荐计算机专业课程《数据结构与算法》作为前置学习课程。本部分介绍数据结构只是为了为后面的集合类型做准备。</p><p>学习集合类之前，我们还有最关键的内容需要学习，同第二章一样，自底向上才是最佳的学习方向，比起直接带大家认识集合类，不如先了解一下数据结构，只有了解了数据结构基础，才能更好地学习集合类，同时，数据结构也是你以后深入学习JDK源码的必备条件（学习不要快餐式）当然，我们主要是讲解Java，数据结构作为铺垫作用，所以我们只会讲解关键的部分，其他部分可以在数据结构与算法篇视频教程中详细学习。</p><blockquote><p>在计算机科学中，数据结构是一种数据组织、管理和存储的格式,它可以帮助我们实现对数据高效的访问和修改。更准确地说,数据结构是数据值的集合，可以体现数据值之间的关系，以及可以对数据进行应用的函数或操作。</p></blockquote><p>通俗地说，我们需要去学习在计算机中如何去更好地管理我们的数据，才能让我们对我们的数据控制更加灵活！</p><p><img src="https://s2.loli.net/2022/07/10/9RwL7pxgyfoB3WT.png" alt="image-20220710103307583"></p><p>比如现在我们需要保存100个学生的数据，那么你首先想到的肯定是使用数组吧！没错，没有什么比数组更适合存放这100个学生的数据了，但是如果我们现在有了新的需求呢？我们不仅仅是存放这些数据，我们还希望能够将这些数据按顺序存放，支持在某个位置插入一条数据、删除一条数据、修改一条数据等，这时候，数组就显得有些乏力了。</p><p>数组无法做到这么高级的功能，那么我们就需要定义一种更加高级的数据结构来做到，我们可以使用线性表（Linear List）</p><blockquote><p>线性表是由同一类型的数据元素构成的有序序列的线性结构。线性表中元素的个数就是线性表的长度，表的起始位置称为表头，表的结束位置称为表尾，当一个线性表中没有元素时，称为空表。</p></blockquote><p>线性表一般需要包含以下功能：</p><ul><li><strong>获取指定位置上的元素：</strong>直接获取线性表指定位置<code>i</code>上的元素。</li><li><strong>插入元素：</strong>在指定位置<code>i</code>上插入一个元素。</li><li><strong>删除元素：</strong>删除指定位置<code>i</code>上的一个元素。</li><li><strong>获取长度：</strong>返回线性表的长度。</li></ul><p>也就是说，现在我们需要设计的是一种功能完善的表结构，它不像是数组那么低级，而是真正意义上的表：</p><p><img src="https://s2.loli.net/2022/07/23/Ve6dlqROzhumD5o.png" alt="image-20220723112639416"></p><p>简单来说它就是列表，比如我们的菜单，我们在点菜时就需要往菜单列表中添加菜品或是删除菜品，这时列表就很有用了，因为数组长度固定、操作简单，而我们添加菜品、删除菜品这些操作又要求长度动态变化、操作多样。</p><p>那么，如此高级的数据结构，我们该如何去实现呢？实现线性表的结构一般有两种，一种是顺序存储实现，还有一种是链式存储实现，我们先来看第一种，也是最简单的的一种。</p><h3 id="线性表：顺序表"><a href="#线性表：顺序表" class="headerlink" title="线性表：顺序表"></a>线性表：顺序表</h3><p>前面我们说到，既然数组无法实现这样的高级表结构，那么我就基于数组，对其进行强化，也就是说，我们存放数据还是使用数组，但是我们可以为其编写一些额外的操作来强化为线性表，像这样底层依然采用顺序存储实现的线性表，我们称为顺序表。</p><p><img src="https://s2.loli.net/2022/07/24/elBvx4Zo1AJ2WqT.png" alt="image-20220724150015044"></p><p>这里我们可以先定义一个新的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;   <span class="comment">//泛型E，因为表中要存的具体数据类型待定</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">10</span>;   <span class="comment">//当前顺序表的容量</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//当前已经存放的元素数量</span></span><br><span class="line">    <span class="keyword">private</span> Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];   <span class="comment">//底层存放数据的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺序表的插入和删除操作，其实就是：</p><p><img src="https://s2.loli.net/2022/09/27/24Glc7UQjLt5Wny.jpg" alt="67813f22-3607-4351-934d-f8127e6ba15a"></p><p>当插入元素时，需要将插入位置给腾出来，也就是将后面的所有元素向后移，同样的，如果要删除元素，那么也需要将所有的元素向前移动，顺序表是紧凑的，不能出现空位。</p><p>所以说我们可以来尝试实现一下，首先是插入方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element, <span class="type">int</span> index)</span>&#123;   <span class="comment">//插入方法需要支持在指定下标位置插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size; i &gt; index; i--)   <span class="comment">//从后往前，一个一个搬运元素</span></span><br><span class="line">        array[i] = array[i - <span class="number">1</span>];</span><br><span class="line">    array[index] = element;   <span class="comment">//腾出位置之后，直接插入元素放到对应位置上</span></span><br><span class="line">    size++;   <span class="comment">//插入完成之后，记得将size自增</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过这样并不完美，因为我们的插入操作并不是在任何位置都支持插入的，我们允许插入的位置只能是 [0, size] 这个范围内</p><p><img src="https://s2.loli.net/2022/07/23/H67F1crBhqQiXxg.png" alt="image-20220723153933279"></p><p>所以说我们需要在插入之前进行判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size)    <span class="comment">//插入之前先判断插入位置是否合法</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;插入位置非法，合法的插入位置为：0 ~ &quot;</span>+size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size; i &gt; index; i--)</span><br><span class="line">        array[i] = array[i - <span class="number">1</span>];</span><br><span class="line">    array[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">10</span>, <span class="number">1</span>);    <span class="comment">//一上来只能在第一个位置插入，第二个位置肯定是非法的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是就成功得到异常：</p><p><img src="https://s2.loli.net/2022/09/27/rtkRMaWseE2Cm1z.png" alt="image-20220927211134905"></p><p>只不过依然不够完美，万一我们的顺序表装满了咋办？所以说，我们在插入元素之前，需要进行判断，如果已经装满了，那么我们需要先扩容之后才能继续插入新的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;插入位置非法，合法的插入位置为：0 ~ &quot;</span>+size);</span><br><span class="line">    <span class="keyword">if</span>(capacity == size) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> capacity + (capacity &gt;&gt; <span class="number">1</span>);   <span class="comment">//扩容规则就按照原本容量的1.5倍来吧</span></span><br><span class="line">        Object[] newArray = <span class="keyword">new</span> <span class="title class_">Object</span>[newCapacity];    <span class="comment">//创建一个新的数组来存放更多的元素</span></span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, size);   <span class="comment">//使用arraycopy快速拷贝原数组内容到新的数组</span></span><br><span class="line">        array = newArray;   <span class="comment">//更换为新的数组</span></span><br><span class="line">      capacity = newCapacity;   <span class="comment">//容量变成扩容之后的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size; i &gt; index; i--)</span><br><span class="line">        array[i] = array[i - <span class="number">1</span>];</span><br><span class="line">    array[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来重写一下<code>toString</code>方法打印当前存放的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) builder.append(array[i]).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们的底层数组会自动扩容，便于我们使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        list.add(i, i);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/27/6SMZxC5QI3cgXYk.png" alt="image-20220927212426959"></p><p>我们接着来看删除操作，其实操作差不多，只需要将后面的覆盖到前面就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>   <span class="comment">//屏蔽未经检查警告</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>&#123;   <span class="comment">//删除对应位置上的元素，注意需要返回被删除的元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) array[index];   <span class="comment">//因为存放的是Object类型，这里需要强制类型转换为E</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; size; i++)   <span class="comment">//从前往后，挨个往前搬一位</span></span><br><span class="line">        array[i] = array[i + <span class="number">1</span>];</span><br><span class="line">    size--;    <span class="comment">//删完记得将size--</span></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，我们需要对删除的合法范围进行判断：</p><p><img src="https://s2.loli.net/2022/07/23/uHBjUfKpd9ygScW.png" alt="image-20220723160901921"></p><p>所以说我们也来进行一下判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;删除位置非法，合法的插入位置为：0 ~ &quot;</span>+(size - <span class="number">1</span>));</span><br><span class="line">    <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) array[index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; size; i++)</span><br><span class="line">        array[i] = array[i + <span class="number">1</span>];</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为删除不需要考虑容量的问题，所以说这里的删除操作就编写完成了。</p><p>当然，我们还得支持获取指定下标位置上的元素，这个就简单了，直接从数组中那就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>)   <span class="comment">//在插入之前同样要进行范围检查</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;非法的位置，合法的位置为：0 ~ &quot;</span>+(size - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> (E) array[index];   <span class="comment">//直接返回就完事</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;   <span class="comment">//获取当前存放的元素数量</span></span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉顺便表其实还是挺简单的，也就是一个数组多了一些操作罢了。</p><h3 id="线性表：链表"><a href="#线性表：链表" class="headerlink" title="线性表：链表"></a>线性表：链表</h3><p>前面我们介绍了如何使用数组实现线性表，我们接着来看第二种方式，我们可以使用链表来实现，那么什么是链表呢？</p><p><img src="https://s2.loli.net/2022/07/23/ruemiRQplVy7q9s.png" alt="image-20220723171648380"></p><p>链表不同于顺序表，顺序表底层采用数组作为存储容器，需要分配一块连续且完整的内存空间进行使用，而链表则不需要，它通过一个指针来连接各个分散的结点，形成了一个链状的结构，每个结点存放一个元素，以及一个指向下一个结点的指针，通过这样一个一个相连，最后形成了链表。它不需要申请连续的空间，只需要按照顺序连接即可，虽然物理上可能不相邻，但是在逻辑上依然是每个元素相邻存放的，这样的结构叫做链表（单链表）。</p><p>链表分为带头结点的链表和不带头结点的链表，戴头结点的链表就是会有一个头结点指向后续的整个链表，但是头结点不存放数据：</p><p><img src="https://s2.loli.net/2022/07/23/gRUEfOqbtrGN2JZ.png" alt="image-20220723180221112"></p><p>而不带头结点的链表就像上面那样，第一个节点就是存放数据的结点，一般设计链表都会采用带头结点的结构，因为操作更加方便。</p><p>我们来尝试定义一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="comment">//链表的头结点，用于连接之后的所有结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;E&gt; head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//当前的元素数量还是要存一下，方便后面操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;  <span class="comment">//结点类，仅供内部使用</span></span><br><span class="line">        E element;   <span class="comment">//每个结点都存放元素</span></span><br><span class="line">        Node&lt;E&gt; next;   <span class="comment">//以及指向下一个结点的引用</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E element)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.element = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来设计一下链表的插入和删除，我们前面实现了顺序表的插入，那么链表的插入该怎么做呢？</p><p><img src="https://s2.loli.net/2022/07/23/71dgFSWDfoELiXB.png" alt="image-20220723175548491"></p><p>我们可以先修改新插入的结点的后继结点（也就是下一个结点）指向，指向原本在这个位置的结点：</p><p><img src="https://s2.loli.net/2022/07/23/8MNURYiacWZqwu6.png" alt="image-20220723220552680"></p><p>接着我们可以将前驱结点（也就是上一个结点）的后继结点指向修改为我们新插入的结点：</p><p><img src="https://s2.loli.net/2022/07/23/ysETUJb6cgBz2Qx.png" alt="image-20220723175745472"></p><p>这样，我们就成功插入了一个新的结点，现在新插入的结点到达了原本的第二个位置上：</p><p><img src="https://s2.loli.net/2022/07/23/Kb7jCiWa3o4AN8D.png" alt="image-20220723175842075"></p><p>按照这个思路，我们来实现一下，首先设计一下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    Node&lt;E&gt; prev = head;   <span class="comment">//先找到对应位置的前驱结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) </span><br><span class="line">        prev = prev.next;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(element);   <span class="comment">//创建新的结点</span></span><br><span class="line">    node.next = prev.next;   <span class="comment">//先让新的节点指向原本在这个位置上的结点</span></span><br><span class="line">    prev.next = node;   <span class="comment">//然后让前驱结点指向当前结点</span></span><br><span class="line">    size++;   <span class="comment">//完事之后一样的，更新size</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来重写一下toString方法看看能否正常插入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    Node&lt;E&gt; node = head.next;   <span class="comment">//从第一个结点开始，一个一个遍历，遍历一个就拼接到字符串上去</span></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        builder.append(node.element).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们的插入操作是可以正常工作的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    list.add(<span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line">    list.add(<span class="number">20</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/27/Mpj9azwWciemAZY.png" alt="image-20220927235051844"></p><p>只不过还不够完美，跟之前一样，我们还得考虑插入位置是否合法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;插入位置非法，合法的插入位置为：0 ~ &quot;</span>+size);</span><br><span class="line">    Node&lt;E&gt; prev = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(element);</span><br><span class="line">    node.next = prev.next;</span><br><span class="line">    prev.next = node;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入操作完成之后，我们接着来看删除操作，那么我们如何实现删除操作呢？实际上也会更简单一些，我们可以直接将待删除节点的前驱结点指向修改为待删除节点的下一个：</p><p><img src="https://s2.loli.net/2022/07/23/N5sZx9T2a8lOzoC.png" alt="image-20220723222922058"></p><p><img src="https://s2.loli.net/2022/07/23/tNYnBJe9pczUq1Z.png" alt="image-20220723223103306"></p><p>这样，在逻辑上来说，待删除结点其实已经不在链表中了，所以我们只需要释放掉待删除结点占用的内存空间就行了：</p><p><img src="https://s2.loli.net/2022/07/23/MFE2gZuS5eOysDW.png" alt="image-20220723223216420"></p><p>那么我们就按照这个思路来编写一下程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>)   <span class="comment">//同样的，先判断位置是否合法</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;删除位置非法，合法的删除位置为：0 ~ &quot;</span>+(size - <span class="number">1</span>));</span><br><span class="line">    Node&lt;E&gt; prev = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)   <span class="comment">//同样需要先找到前驱结点</span></span><br><span class="line">        prev = prev.next;</span><br><span class="line">    <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> prev.next.element;   <span class="comment">//先把待删除结点存放的元素取出来</span></span><br><span class="line">    prev.next = prev.next.next;  <span class="comment">//可以删了</span></span><br><span class="line">    size--;   <span class="comment">//记得size--</span></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉还是挺简单的？这样，我们就成功完成了链表的删除操作。</p><p>我们接着来实现一下获取对应位置上的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;非法的位置，合法的位置为：0 ~ &quot;</span>+(size - <span class="number">1</span>));</span><br><span class="line">    Node&lt;E&gt; node = head;</span><br><span class="line">    <span class="keyword">while</span> (index-- &gt;= <span class="number">0</span>)   <span class="comment">//这里直接让index减到-1为止</span></span><br><span class="line">        node = node.next;</span><br><span class="line">    <span class="keyword">return</span> node.element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们的链表就编写完成了，实际上只要理解了那种结构，其实还是挺简单的。</p><p><strong>问题</strong>：什么情况下使用顺序表，什么情况下使用链表呢？</p><ul><li>通过分析顺序表和链表的特性我们不难发现，链表在随机访问元素时，需要通过遍历来完成，而顺序表则利用数组的特性直接访问得到，所以，当我们读取数据多于插入或是删除数据的情况下时，使用顺序表会更好。</li><li>而顺序表在插入元素时就显得有些鸡肋了，因为需要移动后续元素，整个移动操作会浪费时间，而链表则不需要，只需要修改结点 指向即可完成插入，所以在频繁出现插入或删除的情况下，使用链表会更好。</li></ul><p>虽然单链表使用起来也比较方便，不过有一个问题就是，如果我们想要操作某一个结点，比如删除或是插入，那么由于单链表的性质，我们只能先去找到它的前驱结点，才能进行。为了解决这种查找前驱结点非常麻烦的问题，我们可以让结点不仅保存指向后续结点的指针，同时也保存指向前驱结点的指针：</p><p><img src="https://s2.loli.net/2022/07/24/oeXm6nyW7I9lPMf.png" alt="image-20220724123947104"></p><p>这样我们无论在哪个结点，都能够快速找到对应的前驱结点，就很方便了，这样的链表我们成为双向链表（双链表）</p><h3 id="线性表：栈"><a href="#线性表：栈" class="headerlink" title="线性表：栈"></a>线性表：栈</h3><p>栈（也叫堆栈，Stack）是一种特殊的线性表，它只能在在表尾进行插入和删除操作，就像下面这样：</p><p><img src="https://s2.loli.net/2022/07/24/D3heysaM9EpAgS4.png" alt="image-20220724210955622"></p><p>也就是说，我们只能在一端进行插入和删除，当我们依次插入1、2、3、4这四个元素后，连续进行四次删除操作，删除的顺序刚好相反：4、3、2、1，我们一般将其竖着看：</p><p><img src="https://s2.loli.net/2022/07/24/2NxUpCIRLoZt9Ky.png" alt="image-20220724211442421"></p><p>底部称为栈底，顶部称为栈顶，所有的操作只能在栈顶进行，也就是说，被压在下方的元素，只能等待其上方的元素出栈之后才能取出，就像我们往箱子里里面放的书一样，因为只有一个口取出里面的物品，所以被压在下面的书只能等上面的书被拿出来之后才能取出，这就是栈的思想，它是一种先进后出的数据结构（FILO，First In, Last Out）</p><p>实现栈也是非常简单的，可以基于我们前面的顺序表或是链表，这里我们需要实现两个新的操作：</p><ul><li>pop：出栈操作，从栈顶取出一个元素。</li><li>push：入栈操作，向栈中压入一个新的元素。</li></ul><p>栈可以使用顺序表实现，也可以使用链表实现，这里我们就使用链表，实际上使用链表会更加的方便，我们可以直接将头结点指向栈顶结点，而栈顶结点连接后续的栈内结点：</p><p><img src="https://s2.loli.net/2022/07/24/outf2S7D3WzQK8c.png" alt="image-20220724222836333"></p><p>当有新的元素入栈，只需要在链表头部插入新的结点即可，我们来尝试编写一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedStack</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;E&gt; head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>);   <span class="comment">//大体内容跟链表类似</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E element;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E element)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.element = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来编写一下入栈操作：</p><p><img src="https://s2.loli.net/2022/07/24/GdBj3g5YRFzSsVw.png" alt="image-20220724223550553"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E element)</span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(element);   <span class="comment">//直接创建新结点</span></span><br><span class="line">    node.next = head.next;    <span class="comment">//新结点的下一个变成原本的栈顶结点</span></span><br><span class="line">    head.next = node;     <span class="comment">//头结点的下一个改成新的结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以轻松实现入栈操作了。其实出栈也是同理，所以我们只需要将第一个元素移除即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head.next == <span class="literal">null</span>)   <span class="comment">//如果栈已经没有元素了，那么肯定是没办法取的</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">    <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> head.next.element;   <span class="comment">//先把待出栈元素取出来</span></span><br><span class="line">    head.next = head.next.next;   <span class="comment">//直接让头结点的下一个指向下一个的下一个</span></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LinkedStack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedStack</span>&lt;&gt;();</span><br><span class="line">    stack.push(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    stack.push(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">    stack.push(<span class="string">&quot;CCC&quot;</span>);</span><br><span class="line">    System.out.println(stack.pop());</span><br><span class="line">    System.out.println(stack.pop());</span><br><span class="line">    System.out.println(stack.pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，入栈顺序和出栈顺序是完全相反的：</p><p><img src="https://s2.loli.net/2022/09/28/yaWmfPDU63X8BQn.png" alt="image-20220928101152179"></p><p>其实还是挺简单的。</p><h3 id="线性表：队列"><a href="#线性表：队列" class="headerlink" title="线性表：队列"></a>线性表：队列</h3><p>前面我们学习了栈，栈中元素只能栈顶出入，它是一种特殊的线性表，同样的，队列（Queue）也是一种特殊的线性表。</p><p>就像我们在超市、食堂需要排队一样，我们总是排成一列，先到的人就排在前面，后来的人就排在后面，越前面的人越先完成任务，这就是队列，队列有队头和队尾：</p><p><img src="https://s2.loli.net/2022/07/25/xBuZckTNtR54AEq.png" alt="image-20220725103600318"></p><p>秉承先来后到的原则，队列中的元素只能从队尾进入，只能从队首出去，也就是说，入队顺序为1、2、3、4，那么出队顺序也一定是1、2、3、4，所以队列是一种先进先出（FIFO，First In, First Out）的数据结构。</p><p>队列也可以使用链表和顺序表来实现，只不过使用链表的话就不需要关心容量之类的问题了，会更加灵活一些：</p><p><img src="https://s2.loli.net/2022/07/25/lwGgHXqAV5z2KNk.png" alt="image-20220725145214955"></p><p>注意我们需要同时保存队首和队尾两个指针，因为是单链表，所以队首需要存放指向头结点的指针，因为需要的是前驱结点，而队尾则直接是指向尾结点的指针即可，后面只需要直接在后面拼接就行。</p><p>当有新的元素入队时，只需要拼在队尾就行了，同时队尾指针也要后移一位：</p><p><img src="https://s2.loli.net/2022/07/25/ufmFEwrS9xVKoIZ.png" alt="image-20220725145608827"></p><p>出队时，只需要移除队首指向的下一个元素即可：</p><p><img src="https://s2.loli.net/2022/07/25/geJRFwHKhGT69XD.png" alt="image-20220725145707707"></p><p>那么我们就按照这个思路，来编写一下代码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedQueue</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;E&gt; head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(E element)</span>&#123;  <span class="comment">//入队操作</span></span><br><span class="line">        Node&lt;E&gt; last = head;</span><br><span class="line">        <span class="keyword">while</span> (last.next != <span class="literal">null</span>)   <span class="comment">//入队直接丢到最后一个结点的屁股后面就行了</span></span><br><span class="line">            last = last.next;</span><br><span class="line">        last.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span>&#123;   <span class="comment">//出队操作</span></span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>)   <span class="comment">//如果队列已经没有元素了，那么肯定是没办法取的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> head.next.element;</span><br><span class="line">        head.next = head.next.next;   <span class="comment">//直接从队首取出</span></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E element;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E element)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.element = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实使用起来还是挺简单的，我们来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LinkedQueue&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedQueue</span>&lt;&gt;();</span><br><span class="line">    stack.offer(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    stack.offer(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">    stack.offer(<span class="string">&quot;CCC&quot;</span>);</span><br><span class="line">    System.out.println(stack.poll());</span><br><span class="line">    System.out.println(stack.poll());</span><br><span class="line">    System.out.println(stack.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/28/FUS1Rc8JuEMT6bq.png" alt="image-20220928154121872"></p><p>可以看到，队列遵从先进先出，入队顺序和出队顺序是一样的。</p><h3 id="树：二叉树"><a href="#树：二叉树" class="headerlink" title="树：二叉树"></a>树：二叉树</h3><p>树是一种全新的数据结构，它就像一棵树的树枝一样，不断延伸。</p><p><img src="https://s2.loli.net/2022/08/08/NajFZzXHxUCDQBW.png" alt="树枝666"></p><p>在我们的程序中，想要表示出一棵树，就可以像下面这样连接：</p><p><img src="https://s2.loli.net/2022/08/01/aoBjrR5bPqWzCel.png" alt="image-20220801210920230"></p><p>可以看到，现在一个结点下面可能会连接多个节点，并不断延伸，就像树枝一样，每个结点都有可能是一个分支点，延伸出多个分支，从位于最上方的结点开始不断向下，而这种数据结构，我们就称为<strong>树</strong>（Tree）注意分支只能向后单独延伸，之后就分道扬镳了，<strong>不能与其他分支上的结点相交！</strong></p><ul><li>我们一般称位于最上方的结点为树的<strong>根结点</strong>（Root）因为整棵树正是从这里开始延伸出去的。</li><li>每个结点连接的子结点数目（分支的数目），我们称为结点的<strong>度</strong>（Degree），而各个结点度的最大值称为树的度。</li><li>每个结点延伸下去的下一个结点都可以称为一棵<strong>子树</strong>（SubTree）比如结点<code>B</code>及其之后延伸的所有分支合在一起，就是一棵<code>A</code>的子树。</li><li>每个<strong>结点的层次</strong>（Level）按照从上往下的顺序，树的根结点为<code>1</code>，每向下一层<code>+1</code>，比如<code>G</code>的层次就是<code>3</code>，整棵树中所有结点的最大层次，就是这颗<strong>树的深度</strong>（Depth），比如上面这棵树的深度为4，因为最大层次就是4。</li></ul><p>由于整棵树错综复杂，所以说我们需要先规定一下结点之间的称呼，就像族谱那样：</p><ul><li>与当前结点直接向下相连的结点，我们称为<strong>子结点</strong>（Child），比如<code>B、C、D</code>结点，都是<code>A</code>的子结点，就像族谱中的父子关系一样，下一代一定是子女，相反的，那么<code>A</code>就是<code>B、C、D</code>的<strong>父结点</strong>（Parent），也可以叫双亲结点。</li><li>如果某个节点没有任何的子结点（结点度为0时）那么我们称这个结点为<strong>叶子结点</strong>（因为已经到头了，后面没有分支了，这时就该树枝上长叶子了那样）比如<code>K、L、F、G、M、I、J</code>结点，都是叶子结点。</li><li>如果两个结点的父结点是同一个，那么称这两个节点为<strong>兄弟结点</strong>（Sibling）比如<code>B</code>和<code>C</code>就是兄弟结点，因为都是<code>A</code>的孩子。</li><li>从根结点开始一直到某个结点的整条路径的所有结点，都是这个结点的<strong>祖先结点</strong>（Ancestor）比如<code>L</code>的祖先结点就是<code>A、B、E</code></li></ul><p>那么在了解了树的相关称呼之后，相信各位就应该对树有了一定的了解，虽然概念比较多，但是还请各位一定记住，不然后面就容易听懵。</p><p>而我们本章需要着重讨论的是<strong>二叉树</strong>（Binary Tree）它是一种特殊的树，它的度最大只能为<code>2</code>，所以我们称其为二叉树，一棵二叉树大概长这样：</p><p><img src="https://s2.loli.net/2022/08/01/QGLfnYWFby37deP.png" alt="image-20220801224008266"></p><p>并且二叉树任何结点的子树是有左右之分的，不能颠倒顺序，比如A结点左边的子树，称为左子树，右边的子树称为右子树。</p><p>当然，对于某些二叉树我们有特别的称呼，比如，在一棵二叉树中，所有分支结点都存在左子树和右子树，且叶子结点都在同一层：</p><p><img src="https://s2.loli.net/2022/08/01/btfjlJhDuWrSXYi.png" alt="image-20220801231216578"></p><p>这样的二叉树我们称为<strong>满二叉树</strong>，可以看到整棵树都是很饱满的，没有出现任何度为1的结点，当然，还有一种特殊情况：</p><p><img src="https://s2.loli.net/2022/08/01/QGLfnYWFby37deP.png" alt="image-20220801224008266"></p><p>可以看到只有最后一层有空缺，并且所有的叶子结点是按照从左往右的顺序排列的，这样的二叉树我们一般称其为<strong>完全二叉树</strong>，所以，一棵满二叉树，一定是一棵完全二叉树。</p><p>我们接着来看看二叉树在程序中的表示形式，我们在前面使用链表的时候，每个结点不仅存放对应的数据，而且会存放一个指向下一个结点的引用：</p><p><img src="https://s2.loli.net/2022/07/23/ruemiRQplVy7q9s.png" alt="image-20220723171648380"></p><p>而二叉树也可以使用这样的链式存储形式，只不过现在一个结点需要存放一个指向左子树的引用和一个指向右子树的引用了：</p><p><img src="https://s2.loli.net/2022/08/06/H9MqkghmAjFJnuO.png" alt="image-20220806111610082"></p><p>通过这种方式，我们就可以通过连接不同的结点形成一颗二叉树了，这样也更便于我们去理解它，我们首先定义一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> E element;</span><br><span class="line">    <span class="keyword">public</span> TreeNode&lt;E&gt; left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(E element)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.element = element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们现在想要构建一颗像这样的二叉树：</p><p><img src="https://s2.loli.net/2022/08/05/uan6A3ZRLykt289.png" alt="image-20220805231744693"></p><p>首先我们需要创建好这几个结点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    TreeNode&lt;Character&gt; a = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; b = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; c = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; d = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; e = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们从最上面开始，挨着进行连接，首先是A这个结点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    a.left = b;</span><br><span class="line">    a.right = c;</span><br><span class="line">    b.left = d;</span><br><span class="line">    b.right = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，我们就成功构建好了这棵二叉树，比如现在我们想通过根结点访问到D：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(a.left.left.element);</span><br></pre></td></tr></table></figure><p>断点调试也可以看的很清楚：</p><p><img src="https://s2.loli.net/2022/09/30/XCkDxVBFz2bWph8.png" alt="image-20220930160452608"></p><p>这样，我们就通过使用链式结构，成功构建出了一棵二叉树，接着我们来看看如何遍历一棵二叉树，也就是说我们想要访问二叉树的每一个结点，由于树形结构特殊，遍历顺序并不唯一，所以一共有四种访问方式：<strong>前序遍历、中序遍历、后序遍历、层序遍历。</strong>不同的访问方式输出都结点顺序也不同。</p><p>首先我们来看最简单的前序遍历：</p><p><img src="https://s2.loli.net/2022/08/06/G6ujstSVZ2XWJLE.png" alt="image-20220806171459056"></p><p>前序遍历是一种勇往直前的态度，走到哪就遍历到那里，先走左边再走右边，比如上面的这个图，首先会从根节点开始：</p><p><img src="https://s2.loli.net/2022/08/06/qCFMosHtujEZ3U6.png" alt="image-20220806171431845"></p><p>从A开始，先左后右，那么下一个就是B，然后继续走左边，是D，现在ABD走完之后，B的左边结束了，那么就要开始B的右边了，所以下一个是E，E结束之后，现在A的左子树已经全部遍历完成了，然后就是右边，接着就是C，C没有左子树了，那么只能走右边了，最后输出F，所以上面这个二叉树的前序遍历结果为：ABDECF</p><ol><li>打印根节点</li><li>前序遍历左子树</li><li>前序遍历右子树</li></ol><p>我们不难发现规律，整棵二叉树（包括子树）的根节点一定是出现在最前面的，比如A在最前面，A的左子树根结点B也是在最前面的。我们现在就来尝试编写一下代码实现一下，先把二叉树构建出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    TreeNode&lt;Character&gt; a = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; b = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; c = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; d = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; e = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; f = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">    a.left = b;</span><br><span class="line">    a.right = c;</span><br><span class="line">    b.left = d;</span><br><span class="line">    b.right = e;</span><br><span class="line">    c.right = f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组装好之后，我们来实现一下前序遍历的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode&lt;T&gt; root)</span>&#123;</span><br><span class="line">    System.out.print(root.element + <span class="string">&quot; &quot;</span>);   <span class="comment">//首先肯定要打印，这个是必须的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印完成之后，我们就按照先左后右的规则往后遍历下一个结点，这里我们就直接使用递归来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode&lt;T&gt; root)</span>&#123;</span><br><span class="line">    System.out.print(root.element + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    preOrder(root.left);    <span class="comment">//先走左边</span></span><br><span class="line">    preOrder(root.right);   <span class="comment">//再走右边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过还没完，我们的递归肯定是需要一个终止条件的，不可能无限地进行下去，如果已经走到底了，那么就不能再往下走了，所以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode&lt;T&gt; root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    System.out.print(root.element);</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    preOrder(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到结果为：</p><p><img src="https://s2.loli.net/2022/08/06/hZ8qEfWaP5o6L2j.png" alt="image-20220806173227580"></p><p>这样我们就通过一个简单的递归操作完成了对一棵二叉树的前序遍历，如果不太好理解，建议结合调试进行观察。</p><p>那么前序遍历我们了解完了，接着就是中序遍历了，中序遍历在顺序上与前序遍历不同，前序遍历是走到哪就打印到哪，而中序遍历需要先完成整个左子树的遍历后再打印，然后再遍历其右子树。</p><p>我们还是以上面的二叉树为例：</p><p><img src="https://s2.loli.net/2022/08/06/W6Yb5M92gQApNJa.png" alt="image-20220806230603967"></p><p>首先需要先不断遍历左子树，走到最底部，但是沿途并不进行打印，而是到底之后，再打印，所以第一个打印的是D，接着由于没有右子树，所以我们回到B，此时再打印B，然后再去看B的右结点E，由于没有左子树和右子树了，所以直接打印E，左边遍历完成，接着回到A，打印A，然后对A的右子树重复上述操作。所以说遍历的基本规则还是一样的，只是打印值的时机发生了改变。</p><ol><li>中序遍历左子树</li><li>打印结点</li><li>中序遍历右子树</li></ol><p>所以这棵二叉树的中序遍历结果为：DBEACF，我们可以发现一个规律，就是在某个结点的左子树中所有结点，其中序遍历结果也是按照这样的规律排列的，比如A的左子树中所有结点，中序遍历结果中全部都在A的左边，右子树中所有的结点，全部都在A的右边（这个规律很关键，后面在做一些算法题时会用到）</p><p>那么怎么才能将打印调整到左子树全部遍历结束之后呢？其实很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode&lt;T&gt; root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root.left);    <span class="comment">//先完成全部左子树的遍历</span></span><br><span class="line">    System.out.print(root.element);    <span class="comment">//等待左子树遍历完成之后再打印</span></span><br><span class="line">    inOrder(root.right);    <span class="comment">//然后就是对右子树进行遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要将打印放到左子树遍历之后即可，这样打印出来的结果就是中序遍历的结果了：</p><p><img src="https://s2.loli.net/2022/08/06/V2KdMy3T5Beo8vx.png" alt="image-20220806231752418"></p><p>这样，我们就实现了二叉树的中序遍历，实际上还是很好理解的。</p><p>接着我们来看一下后序遍历，后序遍历继续将打印的时机延后，需要等待左右子树全部遍历完成，才会去进行打印。</p><p><img src="https://s2.loli.net/2022/08/06/YE2rODdqpCInUa9.png" alt="image-20220806233407910"></p><p>首先还是一路向左，到达结点D，此时结点D没有左子树了，接着看结点D还有没有右子树，发现也没有，左右子树全部遍历完成，那么此时再打印D，同样的，D完事之后就回到B了，此时接着看B的右子树，发现有结点E，重复上述操作，E也打印出来了，接着B的左右子树全部OK，那么再打印B，接着A的左子树就完事了，现在回到A，看到A的右子树，继续重复上述步骤，当A的右子树也遍历结束后，最后再打印A结点。</p><ol><li>后序遍历左子树</li><li>后序遍历右子树</li><li>打印结点</li></ol><p>所以最后的遍历顺序为：DEBFCA，不难发现，整棵二叉树（包括子树）根结点一定是在后面的，比如A在所有的结点的后面，B在其子节点D、E的后面，这一点恰恰和前序遍历相反（注意不是得到的结果相反，是规律相反）</p><p>所以，按照这个思路，我们来编写一下后序遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode&lt;T&gt; root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    System.out.print(root.element);  <span class="comment">//时机延迟到最后</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://s2.loli.net/2022/08/06/6Vx9fmSUcqw51Mp.png" alt="image-20220806234428922"></p><p>最后我们来看层序遍历，实际上这种遍历方式是我们人脑最容易理解的，它是按照每一层在进行遍历：</p><p><img src="https://s2.loli.net/2022/08/07/ywF6r9MU1JSPIge.png" alt="image-20220807205135936"></p><p>层序遍历实际上就是按照从上往下每一层，从左到右的顺序打印每个结点，比如上面的这棵二叉树，那么层序遍历的结果就是：ABCDEF，像这样一层一层的挨个输出。</p><p>虽然理解起来比较简单，但是如果让你编程写出来，该咋搞？是不是感觉有点无从下手？</p><p>我们可以利用队列来实现层序遍历，首先将根结点存入队列中，接着循环执行以下步骤：</p><ul><li>进行出队操作，得到一个结点，并打印结点的值。</li><li>将此结点的左右孩子结点依次入队。</li></ul><p>不断重复以上步骤，直到队列为空。</p><p>我们来分析一下，首先肯定一开始A在里面：</p><p><img src="https://s2.loli.net/2022/08/07/ZsNpeVUivEjCymt.png" alt="image-20220807211522409"></p><p>接着开始不断重复上面的步骤，首先是将队首元素出队，打印A，然后将A的左右孩子依次入队：</p><p><img src="https://s2.loli.net/2022/08/07/v8yXWNato3sfeUn.png" alt="image-20220807211631110"></p><p>现在队列中有B、C两个结点，继续重复上述操作，B先出队，打印B，然后将B的左右孩子依次入队：</p><p><img src="https://s2.loli.net/2022/08/07/Qkprfi5RhAXP7Cd.png" alt="image-20220807211723776"></p><p>现在队列中有C、D、E这三个结点，继续重复，C出队并打印，然后将F入队：</p><p><img src="https://s2.loli.net/2022/08/07/MxQTArlWK2gDjqi.png" alt="image-20220807211800852"></p><p>我们发现，这个过程中，打印的顺序正好就是我们层序遍历的顺序，所以说队列还是非常有用的，这里我们可以直接把之前的队列拿来用。那么现在我们就来上代码吧，首先是之前的队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedQueue</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;E&gt; head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(E element)</span>&#123;</span><br><span class="line">        Node&lt;E&gt; last = head;</span><br><span class="line">        <span class="keyword">while</span> (last.next != <span class="literal">null</span>)</span><br><span class="line">            last = last.next;</span><br><span class="line">        last.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> head.next.element;</span><br><span class="line">        head.next = head.next.next;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;   <span class="comment">//这里多写了一个判断队列为空的操作，方便之后使用</span></span><br><span class="line">        <span class="keyword">return</span> head.next == <span class="literal">null</span>;   <span class="comment">//直接看头结点后面还有没有东西就行了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E element;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E element)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.element = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来尝试编写一下层序遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">levelOrder</span><span class="params">(TreeNode&lt;T&gt; root)</span>&#123;</span><br><span class="line">    LinkedQueue&lt;TreeNode&lt;T&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedQueue</span>&lt;&gt;();  <span class="comment">//创建一个队列</span></span><br><span class="line">    queue.offer(root);    <span class="comment">//将根结点丢进队列</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;   <span class="comment">//如果队列不为空，就一直不断地取出来</span></span><br><span class="line">        TreeNode&lt;T&gt; node = queue.poll();   <span class="comment">//取一个出来</span></span><br><span class="line">        System.out.print(node.element);  <span class="comment">//打印</span></span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.offer(node.left);   <span class="comment">//如果左右孩子不为空，直接将左右孩子丢进队列</span></span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到结果就是层序遍历的结果：</p><p><img src="https://s2.loli.net/2022/08/07/YlUfDhPoQrg9TkB.png" alt="image-20220807215630429"></p><p>当然，使用递归也可以实现，但是需要单独存放结果然后单独输出，不是很方便，所以说这里就不演示了。</p><h3 id="树：二叉查找树和平衡二叉树"><a href="#树：二叉查找树和平衡二叉树" class="headerlink" title="树：二叉查找树和平衡二叉树"></a>树：二叉查找树和平衡二叉树</h3><p><strong>注意：</strong>本部分只进行理论介绍，不做代码实现。</p><p>还记得我们开篇讲到的二分搜索算法吗？通过不断缩小查找范围，最终我们可以以很高的效率找到有序数组中的目标位置。而二叉查找树则利用了类似的思想，我们可以借助其来像二分搜索那样快速查找。</p><p><strong>二叉查找树</strong>也叫二叉搜索树或是二叉排序树，它具有一定的规则：</p><ul><li>左子树中所有结点的值，均小于其根结点的值。</li><li>右子树中所有结点的值，均大于其根结点的值。</li><li>二叉搜索树的子树也是二叉搜索树。</li></ul><p>一棵二叉搜索树长这样：</p><p><img src="https://s2.loli.net/2022/08/14/k9G7Ad2cqezgEtJ.png" alt="image-20220814191444130"></p><p>这棵树的根结点为18，而其根结点左边子树的根结点为10，包括后续结点，都是满足上述要求的。二叉查找树满足左边一定比当前结点小，右边一定比当前结点大的规则，比如我们现在需要在这颗树种查找值为15的结点：</p><ol><li>从根结点18开始，因为15小于18，所以从左边开始找。</li><li>接着来到10，发现10比15小，所以继续往右边走。</li><li>来到15，成功找到。</li></ol><p>实际上，我们在对普通二叉树进行搜索时，可能需要挨个进行查看比较，而有了二叉搜索树，查找效率就大大提升了，它就像我们前面的二分搜索那样。</p><p>利用二叉查找树，我们在搜索某个值的时候，效率会得到巨大提升。但是虽然看起来比较完美，也是存在缺陷的，比如现在我们依次将下面的值插入到这棵二叉树中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20 15 13 8 6 3</span><br></pre></td></tr></table></figure><p>在插入完成后，我们会发现这棵二叉树竟然长这样：</p><p><img src="https://s2.loli.net/2022/08/15/E1Pf2pGv4b9Lj7t.png" alt="image-20220815113242191"></p><p>因为根据我们之前编写的插入规则，小的一律往左边放，现在正好来的就是这样一串递减的数字，最后就组成了这样的一棵只有一边的二叉树，这种情况，与其说它是一棵二叉树，不如说就是一个链表，如果这时我们想要查找某个结点，那么实际上查找的时间并没有得到任何优化，直接就退化成线性查找了。</p><p>所以，二叉查找树只有在理想情况下，查找效率才是最高的，而像这种极端情况，就性能而言几乎没有任何的提升。我们理想情况下，这样的效率是最高的：</p><p><img src="https://s2.loli.net/2022/08/15/k1jzXPoOMp9caHy.png" alt="image-20220815113705827"></p><p>所以，我们在进行结点插入时，需要尽可能地避免这种一边倒的情况，这里就需要引入<strong>平衡二叉树</strong>的概念了。实际上我们发现，在插入时如果不去维护二叉树的平衡，某一边只会无限制地延伸下去，出现极度不平衡的情况，而我们理想中的二叉查找树左右是尽可能保持平衡的，<strong>平衡二叉树</strong>（AVL树）就是为了解决这样的问题而生的。</p><p>它的性质如下：</p><ul><li>平衡二叉树一定是一棵二叉查找树。</li><li>任意结点的左右子树也是一棵平衡二叉树。</li><li>从根节点开始，左右子树都高度差不能超过1，否则视为不平衡。</li></ul><p>可以看到，这些性质规定了平衡二叉树需要保持高度平衡，这样我们的查找效率才不会因为数据的插入而出现降低的情况。二叉树上节点的左子树高度 减去 右子树高度， 得到的结果称为该节点的<strong>平衡因子</strong>（Balance Factor），比如：</p><p><img src="https://s2.loli.net/2022/08/15/vaI9qji1KYOP8kt.png" alt="image-20220815210652973"></p><p>通过计算平衡因子，我们就可以快速得到是否出现失衡的情况。比如下面的这棵二叉树，正在执行插入操作：</p><p><img src="https://s2.loli.net/2022/08/15/DMnPqGhawy5Z92V.png" alt="image-20220815115219250"></p><p>可以看到，当插入之后，不再满足平衡二叉树的定义时，就出现了失衡的情况，而对于这种失衡情况，为了继续保持平衡状态，我们就需要进行处理了。我们可能会遇到以下几种情况导致失衡：</p><p><img src="https://s2.loli.net/2022/08/15/KcOQVhlFxzwsIb9.png" alt="image-20220815115836604"></p><p>根据插入结点的不同偏向情况，分为LL型、LR型、RR型、RL型。针对于上面这几种情况，我们依次来看一下如何进行调整，使得这棵二叉树能够继续保持平衡：</p><p>动画网站：<a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html%EF%BC%88%E5%AE%9E%E5%9C%A8%E4%B8%8D%E7%90%86%E8%A7%A3%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B%E5%8A%A8%E7%94%BB%E6%98%AF%E6%80%8E%E4%B9%88%E8%B5%B0%E7%9A%84%EF%BC%89">https://www.cs.usfca.edu/~galles/visualization/AVLtree.html（实在不理解可以看看动画是怎么走的）</a></p><ol><li><p><strong>LL型调整</strong>（右旋）</p><p><img src="https://s2.loli.net/2022/08/15/KqBaWLJwOj34Ec8.png" alt="image-20220815211641144"></p><p>首先我们来看这种情况，这是典型的LL型失衡，为了能够保证二叉树的平衡，我们需要将其进行<strong>旋转</strong>来维持平衡，去纠正最小不平衡子树即可。那么怎么进行旋转呢？对于LL型失衡，我们只需要进行右旋操作，首先我们先找到最小不平衡子树，注意是最小的那一个：</p><p><img src="https://s2.loli.net/2022/08/15/q4aYvzrnjdTgAtK.png" alt="image-20220815212552176"></p><p>可以看到根结点的平衡因子是2，是目前最小的出现不平衡的点，所以说从根结点开始向左的三个结点需要进行右旋操作，右旋需要将这三个结点中间的结点作为新的根结点，而其他两个结点现在变成左右子树：</p><p><img src="https://s2.loli.net/2022/08/15/fJKz3FWclm9orVT.png" alt="image-20220815213222964"></p><p>这样，我们就完成了右旋操作，可以看到右旋之后，所有的结点继续保持平衡，并且依然是一棵二叉查找树。</p></li><li><p><strong>RR型调整</strong>（左旋）</p><p>前面我们介绍了LL型以及右旋解决方案，相反的，当遇到RR型时，我们只需要进行左旋操作即可：</p><p><img src="https://s2.loli.net/2022/08/15/kIl8ZT6Psr7mNSg.png" alt="image-20220815214026710"></p><p>操作和上面是一样的，只不过现在反过来了而已：</p><p><img src="https://s2.loli.net/2022/08/15/LB9DOJpyIlxQWTm.png" alt="image-20220815214408651"></p><p>这样，我们就完成了左旋操作，使得这棵二叉树继续保持平衡状态了。</p></li><li><p><strong>RL型调整</strong>（先右旋，再左旋）</p><p>剩下两种类型比较麻烦，需要旋转两次才行。我们来看看RL型长啥样：</p><p><img src="https://s2.loli.net/2022/08/15/fwcrEIgBxWLVGXs.png" alt="image-20220815214859501"></p><p>可以看到现在的形状是一个回旋镖形状的，先右后左的一个状态，也就是RL型，针对于这种情况，我们需要先进行右旋操作，注意这里的右旋操作针对的是后两个结点：</p><p><img src="https://s2.loli.net/2022/08/15/ukK6C4PNBwoaJbc.png" alt="image-20220815215929303"></p><p>其中右旋和左旋的操作，与之前一样，该怎么分配左右子树就怎么分配，完成两次旋转后，可以看到二叉树重新变回了平衡状态。</p></li><li><p><strong>LR型调整</strong>（先左旋，再右旋）</p><p>和上面一样，我们来看看LR型长啥样，其实就是反着的：</p><p><img src="https://s2.loli.net/2022/08/15/6Cj8VlgGekULXvP.png" alt="image-20220815220609357"></p><p>形状是先向左再向右，这就是典型的LR型了，我们同样需要对其进行两次旋转：</p><p><img src="https://s2.loli.net/2022/08/15/y6WscFPxHuzTiaI.png" alt="image-20220815221349044"></p><p>这里我们先进行的是左旋，然后再进行的右旋，这样二叉树就能继续保持平衡了。</p></li></ol><p>这样，我们只需要在插入结点时注意维护整棵树的平衡因子，保证其处于稳定状态，这样就可以让这棵树一直处于高度平衡的状态，不会再退化了。</p><h3 id="树：红黑树"><a href="#树：红黑树" class="headerlink" title="树：红黑树"></a>树：红黑树</h3><p><strong>注意：</strong>本部分只进行理论介绍，不做代码实现。</p><p>很多人都说红黑树难，其实就那几条规则，跟着我推一遍其实还是很简单的，当然前提是一定要把前面的平衡二叉树搞明白。</p><p>前面我们讲解了二叉平衡树，通过在插入结点时维护树的平衡，这样就不会出现极端情况使得整棵树的查找效率急剧降低了。但是这样是否开销太大了一点，因为一旦平衡因子的绝对值超过1那么就失衡，这样每插入一个结点，就有很大的概率会导致失衡，我们能否不这么严格，但同时也要在一定程度上保证平衡呢？这就要提到红黑树了。</p><p>在线动画网站：<a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</a></p><p>红黑树也是二叉查找树的一种，它大概长这样，可以看到结点有红有黑：</p><p><img src="https://s2.loli.net/2022/08/15/t86B7sxvYeP9TiR.png" alt="image-20220815222810537"></p><p>它并不像平衡二叉树那样严格要求高度差不能超过1，而是只需要满足五个规则即可，它的规则如下：</p><ul><li>规则1：每个结点可以是黑色或是红色。</li><li>规则2：根结点一定是黑色。</li><li>规则3：红色结点的父结点和子结点不能为红色，也就是说不能有两个连续的红色。</li><li>规则4：所有的空结点都是黑色（空结点视为NIL，红黑树中是将空节点视为叶子结点）</li><li>规则5：每个结点到空节点（NIL）路径上出现的黑色结点的个数都相等。</li></ul><p>它相比平衡二叉树，通过不严格平衡和改变颜色，就能在一定程度上减少旋转次数，这样的话对于整体性能是有一定提升的，只不过我们在插入结点时，就有点麻烦了，我们需要同时考虑变色和旋转这两个操作了，但是会比平衡二叉树更简单。</p><p>那么什么时候需要变色，什么时候需要旋转呢？我们通过一个简单例子来看看：</p><p><img src="https://s2.loli.net/2022/08/16/wIj5qnhxFAHcyG7.png" alt="image-20220816104917851"></p><p>首先这棵红黑树只有一个根结点，因为根结点必须是黑色，所以说直接变成黑色。现在我们要插入一个新的结点了，所有新插入的结点，默认情况下都是红色：</p><p><img src="https://s2.loli.net/2022/08/16/yHRXgbsvOM27xLr.png" alt="image-20220816105119178"></p><p>所以新来的结点7根据规则就直接放到11的左边就行了，然后注意7的左右两边都是NULL，那么默认都是黑色，这里就不画出来了。同样的，我们往右边也来一个：</p><p><img src="https://s2.loli.net/2022/08/16/kJiA71fQuKHnIdb.png" alt="image-20220816105553070"></p><p>现在我们继续插入一个结点：</p><p><img src="https://s2.loli.net/2022/08/16/VEQLu5mb1tcTyzd.png" alt="image-20220816105656320"></p><p>插入结点4之后，此时违反了红黑树的规则3，因为红色结点的父结点和子结点不能为红色，此时为了保持以红黑树的性质，我们就需要进行<strong>颜色变换</strong>才可以，那么怎么进行颜色变换呢？我们只需要直接将父结点和其兄弟结点同时修改为黑色（为啥兄弟结点也需要变成黑色？因为要满足性质5）然后将爷爷结点改成红色即可：</p><p><img src="https://s2.loli.net/2022/08/16/kuc1B3lqhNUwaSM.png" alt="image-20220816113259643"></p><p>当然这里还需注意一下，因为爷爷结点正常情况会变成红色，相当于新来了个红色的，这时还得继续往上看有没有破坏红黑树的规则才可以，直到没有为止，比如这里就破坏了性质一，爷爷结点现在是根结点（不是根结点就不需要管了），必须是黑色，所以说还要给它改成黑色才算结束：</p><p><img src="https://s2.loli.net/2022/08/16/dpRX5DGsfWVwnQi.png" alt="image-20220816113339344"></p><p>接着我们继续插入结点：</p><p><img src="https://s2.loli.net/2022/08/16/4ZAhv7R9YusI8q6.png" alt="image-20220816113939172"></p><p>此时又来了一个插在4左边的结点，同样是连续红色，我们需要进行变色才可以讲解问题，但是我们发现，如果变色的话，那么从11开始到所有NIL结点经历的黑色结点数量就不对了：</p><p><img src="https://s2.loli.net/2022/08/16/n3M6Kfsb4jHtIci.png" alt="image-20220816114245996"></p><p>所以说对于这种<strong>父结点为红色，父结点的兄弟结点为黑色</strong>（NIL视为黑色）的情况，变色无法解决问题了，那么我们只能考虑旋转了，旋转规则和我们之前讲解的平衡二叉树是一样的，这实际上是一种LL型失衡：</p><p><img src="https://s2.loli.net/2022/08/16/POTaBfosmQiceWk.png" alt="image-20220816115015892"></p><p>同样的，如果遇到了LR型失衡，跟前面一样，先左旋在右旋，然后进行变色即可：</p><p><img src="https://s2.loli.net/2022/08/16/XqFr7hJwe38AakK.png" alt="image-20220816115924938"></p><p>而RR型和RL型同理，这里就不进行演示了，可以看到，红黑树实际上也是通过颜色规则在进行旋转调整的，当然旋转和变色的操作顺序可以交换。所以，在插入时比较关键的判断点如下：</p><ul><li>如果整棵树为NULL，直接作为根结点，变成黑色。</li><li>如果父结点是黑色，直接插入就完事。</li><li>如果父结点为红色，且父结点的兄弟结点也是红色，直接变色即可（但是注意得继续往上看有没有破坏之前的结构）</li><li>如果父结点为红色，但父结点的兄弟结点为黑色，需要先根据情况（LL、RR、LR、RL）进行旋转，然后再变色。</li></ul><p>在了解这些步骤之后，我们其实已经可以尝试去编写一棵红黑树出来了，当然代码太过复杂，这里就不演示了。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>在之前，我们已经学习了多种查找数据的方式，比如最简单的，如果数据量不大的情况下，我们可以直接通过顺序查找的方式在集合中搜索我们想要的元素；当数据量较大时，我们可以使用二分搜索来快速找到我们想要的数据，不过需要要求数据按照顺序排列，并且不允许中途对集合进行修改。</p><p>在学习完树形结构篇之后，我们可以利用二叉查找树来建立一个便于我们查找的树形结构，甚至可以将其优化为平衡二叉树或是红黑树来进一步提升稳定性。</p><p>这些都能够极大地帮助我们查找数据，而散列表，则是我们数据结构系列内容的最后一块重要知识。</p><p>散列（Hashing）通过散列函数（哈希函数）将要参与检索的数据与散列值（哈希值）关联起来，生成一种便于搜索的数据结构，我们称其为散列表（哈希表），也就是说，现在我们需要将一堆数据保存起来，这些数据会通过哈希函数进行计算，得到与其对应的哈希值，当我们下次需要查找这些数据时，只需要再次计算哈希值就能快速找到对应的元素了：</p><p><img src="https://s2.loli.net/2022/08/18/Tcj6Spy2Pt5ZIuW.png" alt="image-20220818214145347"></p><p>散列函数也叫哈希函数，哈希函数可以对一个目标计算出其对应的哈希值，并且，只要是同一个目标，无论计算多少次，得到的哈希值都是一样的结果，不同的目标计算出的结果介乎都不同。哈希函数在现实生活中应用十分广泛，比如很多下载网站都提供下载文件的MD5码校验，可以用来判别文件是否完整，哈希函数多种多样，目前应用最为广泛的是SHA-1和MD5，比如我们在下载IDEA之后，会看到有一个验证文件SHA-256校验和的选项，我们可以点进去看看：</p><p><img src="https://s2.loli.net/2022/08/18/tD8AjiGwvJkdahE.png" alt="image-20220818214908458"></p><p>点进去之后，得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e54a026da11d05d9bb0172f4ef936ba2366f985b5424e7eecf9e9341804d65bf *ideaIU-2022.2.1.dmg</span><br></pre></td></tr></table></figure><p>这一串由数字和小写字母随意组合的一个字符串，就是安装包文件通过哈希算法计算得到的结果，那么这个东西有什么用呢？我们的网络可能有时候会出现卡顿的情况，导致我们下载的文件可能会出现不完整的情况，因为哈希函数对同一个文件计算得到的结果是一样的，我们可以在本地使用同样的哈希函数去计算下载文件的哈希值，如果与官方一致，那么就说明是同一个文件，如果不一致，那么说明文件在传输过程中出现了损坏。</p><p>可见，哈希函数在这些地方就显得非常实用，在我们的生活中起了很大的作用，它也可以用于布隆过滤器和负载均衡等场景，这里不多做介绍了。</p><p>前面我们介绍了散列函数，我们知道可以通过散列函数计算一个目标的哈希值，那么这个哈希值计算出来有什么用呢，对我们的程序设计有什么意义呢？我们可以利用哈希值的特性，设计一张全新的表结构，这种表结构是专为哈希设立的，我们称其为哈希表（散列表）</p><p><img src="https://s2.loli.net/2022/08/18/M2o1vE7hHasN8DP.png" alt="image-20220818220944783"></p><p>我们可以将这些元素保存到哈希表中，而保存的位置则与其对应的哈希值有关，哈希值是通过哈希函数计算得到的，我们只需要将对应元素的关键字（一般是整数）提供给哈希函数就可以进行计算了，一般比较简单的哈希函数就是取模操作，哈希表长度是多少（长度最好是一个素数），模就是多少：</p><p><img src="https://s2.loli.net/2022/08/19/CAPhlJnQeLjMHfd.png" alt="image-20220819170355221"></p><p>比如现在我们需要插入一个新的元素（关键字为17）到哈希表中：</p><p><img src="https://s2.loli.net/2022/08/19/ovieRjrzlXhKMC2.png" alt="image-20220819171430332"></p><p>插入的位置为计算出来的哈希值，比如上面是8，那么就在下标位置8插入元素，同样的，我们继续插入27：</p><p><img src="https://s2.loli.net/2022/08/19/pisuSAIZyf5JE7B.png" alt="image-20220819210336314"></p><p>这样，我们就可以将多种多样的数据保存到哈希表中了，注意保存的数据是无序的，因为我们也不清楚计算完哈希值最后会放到哪个位置。那么如果现在我们想要从哈希表中查找数据呢？比如我们现在需要查找哈希表中是否有14这个元素：</p><p><img src="https://s2.loli.net/2022/08/19/H1hAvQPjNui2RYt.png" alt="image-20220819211656628"></p><p>同样的，直接去看哈希值对应位置上看看有没有这个元素，如果没有，那么就说明哈希表中没有这个元素。可以看到，哈希表在查找时只需要进行一次哈希函数计算就能直接找到对应元素的存储位置，效率极高。</p><p>我们来尝试编写一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashTable</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TABLE_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] TABLE = <span class="keyword">new</span> <span class="title class_">Object</span>[TABLE_SIZE];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(E element)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hash(element);</span><br><span class="line">        TABLE[index] = element;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E element)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hash(element);</span><br><span class="line">        <span class="keyword">return</span> TABLE[index] == element;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object object)</span>&#123;   <span class="comment">//哈希函数，计算出存放的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> object.hashCode();  </span><br><span class="line">      <span class="comment">//每一个对象都有一个独一无二的哈希值，可以通过hashCode方法得到（只有极小的概率会出现相同的情况）</span></span><br><span class="line">        <span class="keyword">return</span> hashCode % TABLE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就实现了一个简单的哈希表和哈希函数，通过哈希表，我们可以将数据的查找时间复杂度提升到常数阶。</p><p>前面我介绍了哈希函数，通过哈希函数计算得到一个目标的哈希值，但是在某些情况下，哈希值可能会出现相同的情况：</p><p><img src="https://s2.loli.net/2022/08/19/XqpZd1YP5ulEJRy.png" alt="image-20220819215004653"></p><p>比如现在同时插入14和23这两个元素，他们两个计算出来的哈希值是一样的，都需要在5号下标位置插入，这时就出现了打架的情况，那么到底是把哪一个放进去呢？这种情况，我们称为<strong>哈希碰撞</strong>（哈希冲突）</p><p>这种问题是很严重的，因为哈希函数的设计不同，难免会出现这种情况，这种情况是不可避免的，我们只能通过使用更加高级的哈希函数来尽可能避免这种情况，但是无法完全避免。当然，如果要完全解决这种问题，我们还需要去寻找更好的方法。这里我们只介绍一种比较重要的，会在后面集合类中用到的方案。</p><p>实际上常见的哈希冲突解决方案是<strong>链地址法</strong>，当出现哈希冲突时，我们依然将其保存在对应的位置上，我们可以将其连接为一个链表的形式：</p><p><img src="https://s2.loli.net/2022/09/30/Hd1LDvkY6ScVTN2.png" alt="image-20220820220237535"></p><p>当表中元素变多时，差不多就变成了这样，我们一般将其横过来看：</p><p><img src="https://s2.loli.net/2022/09/30/kr4CcVEwI72AiDU.png" alt="image-20220820221104298"></p><p>通过结合链表的形式，哈希冲突问题就可以得到解决了，但是同时也会出现一定的查找开销，因为现在有了链表，我们得挨个往后看才能找到，当链表变得很长时，查找效率也会变低，此时我们可以考虑结合其他的数据结构来提升效率。比如当链表长度达到8时，自动转换为一棵平衡二叉树或是红黑树，这样就可以在一定程度上缓解查找的压力了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashTable</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TABLE_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;E&gt;[] TABLE = <span class="keyword">new</span> <span class="title class_">Node</span>[TABLE_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashTable</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TABLE_SIZE; i++)</span><br><span class="line">            TABLE[i] = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(E element)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hash(element);</span><br><span class="line">        Node&lt;E&gt; prev = TABLE[index];</span><br><span class="line">        <span class="keyword">while</span> (prev.next != <span class="literal">null</span>)</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        prev.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E element)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hash(element);</span><br><span class="line">        Node&lt;E&gt; node = TABLE[index].next;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node.element == element)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object object)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> object.hashCode();</span><br><span class="line">        <span class="keyword">return</span> hashCode % TABLE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> E element;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Node</span><span class="params">(E element)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.element = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这种方案代码写起来也会更简单，使用也更方便一些。</p><p>至此，数据结构相关内容，我们就讲解到这里，学习这些数据结构，实际上也是为了方便各位小伙伴对于后续结合类的学习，因为集合类的底层实现就是这些数据结构。</p><hr><h2 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h2><p>合理利用集合类，我们可以巧妙地解决各种各样的难题。</p><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><blockquote><p>输入：head = [1,2,3,4,5]<br>输出：[5,4,3,2,1]</p></blockquote><p>示例 2：</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><blockquote><p>输入：head = [1,2]<br>输出：[2,1]</p></blockquote><p>这道题依然是考察各位小伙伴对于链表相关操作的掌握程度，我们如何才能将一个链表的顺序进行反转，关键就在于如何修改每个节点的指针指向。</p><h3 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></p><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>示例 1：</p><blockquote><p>输入：s = “()”<br>输出：true</p></blockquote><p>示例 2：</p><blockquote><p>输入：s = “()[]{}”<br>输出：true</p></blockquote><p>示例 3：</p><blockquote><p>输入：s = “(]”<br>输出：false</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p>输入：s = “([)]”<br>输出：false</p></blockquote><p><strong>示例 5：</strong></p><blockquote><p>输入：s = “{[]}”<br>输出：true</p></blockquote><p>题干很明确，就是需要我们去对这些括号完成匹配，如果给定字符串中的括号无法完成一一匹配的话，那么就表示匹配失败。实际上这种问题我们就可以利用前面学习的栈这种数据结构来解决，我们可以将所有括号的左半部分放入栈中，当遇到右半部分时，进行匹配，如果匹配失败，那么就失败，如果匹配成功，那么就消耗一个左半部分，直到括号消耗完毕。</p><h3 id="实现计算器"><a href="#实现计算器" class="headerlink" title="实现计算器"></a>实现计算器</h3><p>输入一个计算公式（含加减乘除运算符，没有负数但是有小数）得到结果，比如输入：1+4*3/1.321，得到结果为：2.2</p><p>现在请你设计一个Java程序，实现计算器。</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="java" scheme="https://www.hoveco.top/categories/java/"/>
    
    
    <category term="JavaSE" scheme="https://www.hoveco.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-学习笔记-集合类与IO（六）</title>
    <link href="https://www.hoveco.top/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89/"/>
    <id>https://www.hoveco.top/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89/</id>
    <published>2023-10-12T00:30:00.000Z</published>
    <updated>2023-10-12T14:49:22.403Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/10/04/SkAn9RQpqC4tVW5.png" alt="image-20221004131436371"></p><h1 id="集合类与IO"><a href="#集合类与IO" class="headerlink" title="集合类与IO"></a>集合类与IO</h1><p>前面我们已经把基础介绍完了，从这节课开始，我们就正式进入到集合类的讲解中。</p><h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><p>集合类是Java中非常重要的存在，使用频率极高。集合其实与我们数学中的集合是差不多的概念，集合表示一组对象，每一个对象我们都可以称其为元素。不同的集合有着不同的性质，比如一些集合允许重复的元素，而另一些则不允许，一些集合是有序的，而其他则是无序的。</p><p><img src="https://s2.loli.net/2022/09/30/ZWxPduaYGgRzmNO.png" alt="image-20220930233059528"></p><p>集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。从这一块开始，我们会从源码角度给大家讲解（先从接口定义对于集合需要实现哪些功能开始说起，包括这些集合类的底层机制是如何运作的）不仅仅是教会大家如何去使用。</p><p>集合跟数组一样，可以表示同样的一组元素，但是他们的相同和不同之处在于：</p><ol><li>它们都是容器，都能够容纳一组元素。</li></ol><p>不同之处：</p><ol><li>数组的大小是固定的，集合的大小是可变的。</li><li>数组可以存放基本数据类型，但集合只能存放对象。</li><li>数组存放的类型只能是一种，但集合可以有不同种类的元素。</li></ol><h3 id="集合根接口"><a href="#集合根接口" class="headerlink" title="集合根接口"></a>集合根接口</h3><p>Java中已经帮我们将常用的集合类型都实现好了，我们只需要直接拿来用就行了，比如我们之前学习的顺序表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;   <span class="comment">//集合类基本都是在java.util包下定义的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;树脂666&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们会在这一部分中认识大部分Java为我们提供的集合类。所有的集合类最终都是实现自集合根接口的，比如我们下面就会讲到的ArrayList类，它的祖先就是Collection接口：</p><p><img src="https://s2.loli.net/2022/09/30/U9DdJinhCp6BITe.png" alt="image-20220930232759715"></p><p>这个接口定义了集合类的一些基本操作，我们来看看有哪些方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//-------这些是查询相关的操作----------</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取当前集合中的元素数量</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看当前集合是否为空</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询当前集合中是否包含某个元素</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前集合的迭代器，我们会在后面介绍</span></span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将集合转换为数组的形式</span></span><br><span class="line">    Object[] toArray();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//支持泛型的数组转换，同上</span></span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------这些是修改相关的操作----------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向集合中添加元素，不同的集合类具体实现可能会对插入的元素有要求，</span></span><br><span class="line">  <span class="comment">//这个操作并不是一定会添加成功，所以添加成功返回true，否则返回false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从集合中移除某个元素，同样的，移除成功返回true，否则false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------这些是批量执行的操作----------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询当前集合是否包含给定集合中所有的元素</span></span><br><span class="line">  <span class="comment">//从数学角度来说，就是看给定集合是不是当前集合的子集</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加给定集合中所有的元素</span></span><br><span class="line">  <span class="comment">//从数学角度来说，就是将当前集合变成当前集合与给定集合的并集</span></span><br><span class="line">  <span class="comment">//添加成功返回true，否则返回false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除给定集合中出现的所有元素，如果某个元素在当前集合中不存在，那么忽略这个元素</span></span><br><span class="line">  <span class="comment">//从数学角度来说，就是求当前集合与给定集合的差集</span></span><br><span class="line">  <span class="comment">//移除成功返回true，否则false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Java8新增方法，根据给定的Predicate条件进行元素移除操作</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeIf</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> E&gt; filter)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(filter);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;E&gt; each = iterator();   <span class="comment">//这里用到了迭代器，我们会在后面进行介绍</span></span><br><span class="line">        <span class="keyword">while</span> (each.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (filter.test(each.next())) &#123;</span><br><span class="line">                each.remove();</span><br><span class="line">                removed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> removed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只保留当前集合中在给定集合中出现的元素，其他元素一律移除</span></span><br><span class="line">  <span class="comment">//从数学角度来说，就是求当前集合与给定集合的交集</span></span><br><span class="line">  <span class="comment">//移除成功返回true，否则false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空整个集合，删除所有元素</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------这些是比较以及哈希计算相关的操作----------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断两个集合是否相等</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算当前整个集合对象的哈希值</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与迭代器作用相同，但是是并行执行的，我们会在下一章多线程部分中进行介绍</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="built_in">this</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成当前集合的流，我们会在后面进行讲解</span></span><br><span class="line">    <span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成当前集合的并行流，我们会在下一章多线程部分中进行介绍</span></span><br><span class="line">    <span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在这个接口中对于集合相关的操作，还是比较齐全的，那么我们接着就来看看它的实现类。</p><h3 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h3><p>首先我们需要介绍的是List列表（线性表），线性表支持随机访问，相比之前的Collection接口定义，功能还会更多一些。首先介绍ArrayList，我们已经知道，它的底层是用数组实现的，内部维护的是一个可动态进行扩容的数组，也就是我们之前所说的顺序表，跟我们之前自己写的ArrayList相比，它更加的规范，并且功能更加强大，同时实现自List接口。</p><p><img src="https://s2.loli.net/2022/09/30/U9DdJinhCp6BITe.png" alt="image-20220930232759715"></p><p>List是集合类型的一个分支，它的主要特性有：</p><ul><li>是一个有序的集合，插入元素默认是插入到尾部，按顺序从前往后存放，每个元素都有一个自己的下标位置</li><li>列表中允许存在重复元素</li></ul><p>在List接口中，定义了列表类型需要支持的全部操作，List直接继承自前面介绍的Collection接口，其中很多地方重新定义了一次Collection接口中定义的方法，这样做是为了更加明确方法的具体功能，当然，为了直观，我们这里就省略掉：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//List是一个有序的集合类，每个元素都有一个自己的下标位置</span></span><br><span class="line"><span class="comment">//List中可插入重复元素</span></span><br><span class="line"><span class="comment">//针对于这些特性，扩展了Collection接口中一些额外的操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//将给定集合中所有元素插入到当前结合的给定位置上（后面的元素就被挤到后面去了，跟我们之前顺序表的插入是一样的）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Java 8新增方法，可以对列表中每个元素都进行处理，并将元素替换为处理之后的结果</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(operator);</span><br><span class="line">        <span class="keyword">final</span> ListIterator&lt;E&gt; li = <span class="built_in">this</span>.listIterator();  <span class="comment">//这里同样用到了迭代器</span></span><br><span class="line">        <span class="keyword">while</span> (li.hasNext()) &#123;</span><br><span class="line">            li.set(operator.apply(li.next()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对当前集合按照给定的规则进行排序操作，这里同样只需要一个Comparator就行了</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = <span class="built_in">this</span>.toArray();</span><br><span class="line">        Arrays.sort(a, (Comparator) c);</span><br><span class="line">        ListIterator&lt;E&gt; i = <span class="built_in">this</span>.listIterator();</span><br><span class="line">        <span class="keyword">for</span> (Object e : a) &#123;</span><br><span class="line">            i.next();</span><br><span class="line">            i.set((E) e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------- 这些是List中独特的位置直接访问操作 --------</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取对应下标位置上的元素</span></span><br><span class="line">    E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接将对应位置上的元素替换为给定元素</span></span><br><span class="line">    E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在指定位置上插入元素，就跟我们之前的顺序表插入是一样的</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除指定位置上的元素</span></span><br><span class="line">    E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//------- 这些是List中独特的搜索操作 -------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询某个元素在当前列表中的第一次出现的下标位置</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询某个元素在当前列表中的最后一次出现的下标位置</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//------- 这些是List的专用迭代器 -------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代器我们会在下一个部分讲解</span></span><br><span class="line">    ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代器我们会在下一个部分讲解</span></span><br><span class="line">    ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------- 这些是List的特殊转换 -------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前集合在指定范围内的子集</span></span><br><span class="line">    List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在List接口中，扩展了大量列表支持的操作，其中最突出的就是直接根据下标位置进行的增删改查操作。而在ArrayList中，底层就是采用数组实现的，跟我们之前的顺序表思路差不多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认的数组容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放数据的底层数组，这里的transient关键字我们会在后面I/O中介绍用途</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前数组元素数的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//这是ArrayList的其中一个构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];   <span class="comment">//根据初始化大小，创建当前列表</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// 这里会判断容量是否充足，不充足需要扩容</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认的列表最大长度为Integer.MAX_VALUE - 8</span></span><br><span class="line">    <span class="comment">//JVM都C++实现中，在数组的对象头中有一个_length字段，用于记录数组的长</span></span><br><span class="line">    <span class="comment">//度，所以这个8就是存了数组_length字段（这个只做了解就行）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);   <span class="comment">//扩容规则跟我们之前的是一样的，也是1.5倍</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)    <span class="comment">//要是扩容之后的大小还没最小的大小大，那么直接扩容到最小的大小</span></span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)   <span class="comment">//要是扩容之后比最大的大小还大，需要进行大小限制</span></span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);  <span class="comment">//调整为限制的大小</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);   <span class="comment">//使用copyOf快速将内容拷贝到扩容后的新数组中并设定为新的elementData底层数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般的，如果我们要使用一个集合类，我们会使用接口的引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();   <span class="comment">//使用接口的引用来操作具体的集合类实现，是为了方便日后如果我们想要更换不同的集合类实现，而且接口中本身就已经定义了主要的方法，所以说没必要直接用实现类</span></span><br><span class="line">    list.add(<span class="string">&quot;科技与狠活&quot;</span>);   <span class="comment">//使用add添加元素</span></span><br><span class="line">  list.add(<span class="string">&quot;上头啊&quot;</span>);</span><br><span class="line">    System.out.println(list);   <span class="comment">//打印集合类，可以得到一个非常规范的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，打印集合类的效果，跟我们使用Arrays工具类是一样的：</p><p><img src="https://s2.loli.net/2022/10/01/v3uzfnhamXV5St8.png" alt="image-20221001002151164"></p><p>集合的各种功能我们都可以来测试一下，特别注意一下，我们在使用Integer时，要注意传参问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">10</span>);   <span class="comment">//添加Integer的值10</span></span><br><span class="line">    list.remove((Integer) <span class="number">10</span>);   <span class="comment">//注意，不能直接用10，默认情况下会认为传入的是int类型值，删除的是下标为10的元素，我们这里要删除的是刚刚传入的值为10的Integer对象</span></span><br><span class="line">    System.out.println(list);   <span class="comment">//可以看到，此时元素成功被移除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那要是这样写呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>));   <span class="comment">//添加的是一个对象</span></span><br><span class="line">    list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>));   <span class="comment">//删除的是另一个对象</span></span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，结果依然是删除成功，这是因为集合类在删除元素时，只会调用<code>equals</code>方法进行判断是否为指定元素，而不是进行等号判断，所以说一定要注意，如果两个对象使用<code>equals</code>方法相等，那么集合中就是相同的两个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList源码部分</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;   <span class="comment">//这里只是对两个对象进行equals判断</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//只要判断成功，直接认为就是要删除的对象，删除就完事</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>列表中允许存在相同元素，所以说我们可以添加两个一模一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;哟唉嘛干你&quot;</span>;</span><br><span class="line">    list.add(str);</span><br><span class="line">    list.add(str);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/01/paeKLsGntNVfHPT.png" alt="image-20221001231509926"></p><p>那要是此时我们删除对象呢，是一起删除还是只删除一个呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;哟唉嘛干你&quot;</span>;</span><br><span class="line">    list.add(str);</span><br><span class="line">    list.add(str);</span><br><span class="line">    list.remove(str);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/01/5HdFh74wlqbMoj6.png" alt="image-20221001231619391"></p><p>可以看到，这种情况下，只会删除排在前面的第一个元素。</p><p>集合类是支持嵌套使用的，一个集合中可以存放多个集合，套娃嘛，谁不会：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());   <span class="comment">//集合中的每一个元素就是一个集合，这个套娃是可以一直套下去的</span></span><br><span class="line">    System.out.println(list.get(<span class="number">0</span>).isEmpty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Arrays工具类中，我们可以快速生成一个只读的List：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);   <span class="comment">//非常方便</span></span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这个生成的List是只读的，不能进行修改操作，只能使用获取内容相关的方法，否则抛出 UnsupportedOperationException 异常。要生成正常使用的，我们可以将这个只读的列表作为参数传入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>));</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也可以利用静态代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() &#123;&#123;   <span class="comment">//使用匿名内部类（匿名内部类在Java8无法使用钻石运算符，但是之后的版本可以）</span></span><br><span class="line">            add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们接着介绍另一个列表实现类，LinkedList同样是List的实现类，只不过它是采用的链式实现，也就是我们之前讲解的链表，只不过它是一个双向链表，也就是同时保存两个方向：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用首结点</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用尾结点</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，很简单，直接创建就行了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;   <span class="comment">//内部使用的结点类</span></span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;   <span class="comment">//不仅保存指向下一个结点的引用，还保存指向上一个结点的引用</span></span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = element;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedList的使用和ArrayList的使用几乎相同，各项操作的结果也是一样的，在什么使用使用ArrayList和LinkedList，我们需要结合具体的场景来决定，尽可能的扬长避短。</p><p>只不过LinkedList不仅可以当做List来使用，也可以当做双端队列使用，我们会在后面进行详细介绍。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>我们接着来介绍迭代器，实际上我们的集合类都是支持使用<code>foreach</code>语法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : list) &#123;   <span class="comment">//集合类同样支持这种语法</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是由于仅仅是语法糖，实际上编译之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var2</span> <span class="operator">=</span> list.iterator();   <span class="comment">//这里使用的是List的迭代器在进行遍历操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String)var2.next();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个迭代器是一个什么东西呢？我们来研究一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">  <span class="comment">//通过调用iterator方法快速获取当前集合的迭代器</span></span><br><span class="line">  <span class="comment">//Iterator迭代器本身也是一个接口，由具体的集合实现类来根据情况实现</span></span><br><span class="line">    Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用迭代器，我们就可以实现对集合中的元素的进行遍历，就像我们遍历数组那样，它的运作机制大概是：</p><p><img src="https://s2.loli.net/2022/10/02/8KS5jbTv7LoAVOs.png" alt="image-20221002150914323"></p><p>一个新的迭代器就像上面这样，默认有一个指向集合中第一个元素的指针：</p><p><img src="https://s2.loli.net/2022/10/02/HxjfipVB9TlEbz5.png" alt="image-20221002151110991"></p><p>每一次<code>next</code>操作，都会将指针后移一位，直到完成每一个元素的遍历，此时再调用<code>next</code>将不能再得到下一个元素。至于为什么要这样设计，是因为集合类的实现方案有很多，可能是链式存储，也有可能是数组存储，不同的实现有着不同的遍历方式，而迭代器则可以将多种多样不同的集合类遍历方式进行统一，只需要各个集合类根据自己的情况进行对应实现就行了。</p><p>我们来看看这个接口的源码定义了哪些操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//看看是否还有下一个元素</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历当前元素，并将下一个元素作为待遍历元素</span></span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除上一个被遍历的元素（某些集合不支持这种操作）</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对剩下的元素进行自定义遍历操作</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ArrayList和LinkedList中，迭代器的实现也不同，比如ArrayList就是直接按下标访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    cursor = i + <span class="number">1</span>;   <span class="comment">//移动指针</span></span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];  <span class="comment">//直接返回指针所指元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedList就是不断向后寻找结点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    next = next.next;   <span class="comment">//向后继续寻找结点</span></span><br><span class="line">    nextIndex++;</span><br><span class="line">    <span class="keyword">return</span> lastReturned.item;  <span class="comment">//返回结点内部存放的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这两种列表的实现不同，遍历方式也不同，但是都是按照迭代器的标准进行了实现，所以说，我们想要遍历一个集合中所有的元素，那么就可以直接使用迭代器来完成，而不需要关心集合类是如何实现，我们该怎么去遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">    Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;    <span class="comment">//每次循环一定要判断是否还有元素剩余</span></span><br><span class="line">        System.out.println(iterator.next());  <span class="comment">//如果有就可以继续获取到下一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，迭代器的使用是一次性的，用了之后就不能用了，如果需要再次进行遍历操作，那么需要重新生成一个迭代器对象。为了简便，我们可以直接使用<code>foreach</code>语法来快速遍历集合类，效果是完全一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java8提供了一个支持Lambda表达式的forEach方法，这个方法接受一个Consumer，也就是对遍历的每一个元素进行的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个效果跟上面的写法是完全一样的，因为forEach方法内部本质上也是迭代器在处理，这个方法是在Iterable接口中定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="built_in">this</span>) &#123;   <span class="comment">//foreach语法遍历每一个元素</span></span><br><span class="line">        action.accept(t);   <span class="comment">//调用Consumer的accept来对每一个元素进行消费</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们来看一下，Iterable这个接口又是是什么东西？</p><p><img src="https://s2.loli.net/2022/10/02/4ShtiO6kdIcwZ85.png" alt="image-20221002152713622"></p><p>我们来看看定义了哪些内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意这个接口是集合接口的父接口，不要跟之前的迭代器接口搞混了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//生成当前集合的迭代器，在Collection接口中重复定义了一次</span></span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Java8新增方法，因为是在顶层接口中定义的，因此所有的集合类都有这个方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="built_in">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法会在多线程部分中进行介绍，暂时不做讲解</span></span><br><span class="line">    <span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得益于Iterable提供的迭代器生成方法，实际上只要是实现了迭代器接口的类（我们自己写的都行），都可以使用<code>foreach</code>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;String&gt;&#123;   <span class="comment">//这里我们随便写一个类，让其实现Iterable接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;String&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;String&gt;() &#123;   <span class="comment">//生成一个匿名的Iterator对象</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;   <span class="comment">//这里随便写的，直接返回true，这将会导致无限循环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123;   <span class="comment">//每次就直接返回一个字符串吧</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;测试&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，直接就支持这种语法了，虽然我们这个是自己写的，并不是集合类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    <span class="keyword">for</span> (String s : test) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/02/KejcFB8TChE5z4o.png" alt="image-20221002154018319"></p><p>是不是感觉集合类的设计非常巧妙？</p><p>我们这里再来介绍一下ListIterator，这个迭代器是针对于List的强化版本，增加了更多方便的操作，因为List是有序集合，所以它支持两种方向的遍历操作，不仅能从前向后，也可以从后向前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ListIterator</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//原本就有的</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原本就有的</span></span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看前面是否有已经遍历的元素</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跟next相反，这里是倒着往回遍历</span></span><br><span class="line">    E <span class="title function_">previous</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回下一个待遍历元素的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回上一个已遍历元素的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原本就有的</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将上一个已遍历元素修改为新的元素</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在遍历过程中，插入新的元素到当前待遍历元素之前</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>));</span><br><span class="line">    ListIterator&lt;String&gt; iterator = list.listIterator();</span><br><span class="line">    iterator.next();   <span class="comment">//此时得到A</span></span><br><span class="line">    iterator.set(<span class="string">&quot;X&quot;</span>);  <span class="comment">//将A原本位置的上的元素设定为成新的</span></span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/02/C3xNDTEWGaPLfO6.png" alt="image-20221002154844743"></p><p>这种迭代器因为能够双向遍历，所以说可以反复使用。</p><h3 id="Queue和Deque"><a href="#Queue和Deque" class="headerlink" title="Queue和Deque"></a>Queue和Deque</h3><p>通过前面的学习，我们已经了解了List的使用，其中LinkedList除了可以直接当做列表使用之外，还可以当做其他的数据结构使用，可以看到它不仅仅实现了List接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p>这个Deque接口是干嘛的呢？我们先来看看它的继承结构：</p><p><img src="https://s2.loli.net/2022/10/02/sCMgv9rl5b743BE.png" alt="image-20221002162108279"></p><p>我们先来看看队列接口，它扩展了大量队列相关操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//队列的添加操作，是在队尾进行插入（只不过List也是一样的，默认都是尾插）</span></span><br><span class="line">  <span class="comment">//如果插入失败，会直接抛出异常</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同样是添加操作，但是插入失败不会抛出异常</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除队首元素，但是如果队列已经为空，那么会抛出异常</span></span><br><span class="line">    E <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//同样是移除队首元素，但是如果队列为空，会返回null</span></span><br><span class="line">    E <span class="title function_">poll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//仅获取队首元素，不进行出队操作，但是如果队列已经为空，那么会抛出异常</span></span><br><span class="line">    E <span class="title function_">element</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同样是仅获取队首元素，但是如果队列为空，会返回null</span></span><br><span class="line">    E <span class="title function_">peek</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以直接将一个LinkedList当做一个队列来使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();   <span class="comment">//当做队列使用，还是很方便的</span></span><br><span class="line">    queue.offer(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    queue.offer(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/02/veHxlUkKyVYErgm.png" alt="image-20221002163512442"></p><p>我们接着来看双端队列，实际上双端队列就是队列的升级版，我们一个普通的队列就是：</p><p><img src="https://s2.loli.net/2022/07/25/xBuZckTNtR54AEq.png" alt="image-20220725103600318"></p><p>普通队列中从队尾入队，队首出队，而双端队列允许在队列的两端进行入队和出队操作：</p><p><img src="https://s2.loli.net/2022/10/02/gn8i3teclAKbhQS.png" alt="image-20221002164302507"></p><p><img src="https://s2.loli.net/2022/10/02/in8IX3QkwtsLgWN.png" alt="image-20221002164431746"></p><p>利用这种特性，双端队列既可以当做普通队列使用，也可以当做栈来使用，我们来看看Java中是如何定义的Deque双端队列接口的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在双端队列中，所有的操作都有分别对应队首和队尾的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Deque</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Queue</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//在队首进行插入操作</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在队尾进行插入操作</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//不用多说了吧？</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在队首进行移除操作</span></span><br><span class="line">    E <span class="title function_">removeFirst</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在队尾进行移除操作</span></span><br><span class="line">    E <span class="title function_">removeLast</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不用多说了吧？</span></span><br><span class="line">    E <span class="title function_">pollFirst</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">pollLast</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队首元素</span></span><br><span class="line">    E <span class="title function_">getFirst</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队尾元素</span></span><br><span class="line">    E <span class="title function_">getLast</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不用多说了吧？</span></span><br><span class="line">    E <span class="title function_">peekFirst</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">peekLast</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中删除第一个出现的指定元素</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeFirstOccurrence</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中删除最后一个出现的指定元素</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeLastOccurrence</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** 队列中继承下来的方法操作是一样的，这里就不列出了 ***</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** 栈相关操作已经帮助我们定义好了 ***</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将元素推向栈顶</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将元素从栈顶出栈</span></span><br><span class="line">    E <span class="title function_">pop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** 集合类中继承的方法这里也不多种介绍了 ***</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成反向迭代器，这个迭代器也是单向的，但是是next方法是从后往前进行遍历的</span></span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">descendingIterator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以来测试一下，比如我们可以直接当做栈来进行使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Deque&lt;String&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    deque.push(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    deque.push(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">    System.out.println(deque.pop());</span><br><span class="line">    System.out.println(deque.pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/02/92woGL5MiBsTcKe.png" alt="image-20221002165618791"></p><p>可以看到，得到的顺序和插入顺序是完全相反的，其实只要各位理解了前面讲解的数据结构，就很简单了。我们来测试一下反向迭代器和正向迭代器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Deque&lt;String&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    deque.addLast(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    deque.addLast(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;String&gt; descendingIterator = deque.descendingIterator();</span><br><span class="line">    System.out.println(descendingIterator.next());</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; iterator = deque.iterator();</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，正向迭代器和反向迭代器的方向是完全相反的。</p><p>当然，除了LinkedList实现了队列接口之外，还有其他的实现类，但是并不是很常用，这里做了解就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Deque&lt;String&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();   <span class="comment">//数组实现的栈和队列</span></span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();  <span class="comment">//优先级队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要介绍一下优先级队列，优先级队列可以根据每一个元素的优先级，对出队顺序进行调整，默认情况按照自然顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    queue.offer(<span class="number">10</span>);</span><br><span class="line">    queue.offer(<span class="number">4</span>);</span><br><span class="line">    queue.offer(<span class="number">5</span>);</span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/bmEP9fgCS1Ksaqw.png" alt="image-20221003210253093"></p><p>可以看到，我们的插入顺序虽然是10/4/5，但是出队顺序是按照优先级来的，类似于VIP用户可以优先结束排队。我们也可以自定义比较规则，同样需要给一个Comparator的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);   <span class="comment">//按照从大到小顺序出队</span></span><br><span class="line">    queue.offer(<span class="number">10</span>);</span><br><span class="line">    queue.offer(<span class="number">4</span>);</span><br><span class="line">    queue.offer(<span class="number">5</span>);</span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">    System.out.println(queue.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/G5SZgKxvUJyPABD.png" alt="image-20221003210436684"></p><p>只不过需要注意的是，优先级队列并不是队列中所有的元素都是按照优先级排放的，优先级队列<strong>只能保证出队顺序是按照优先级</strong>进行的，我们可以打印一下：</p><p><img src="https://s2.loli.net/2022/10/03/9dSheG4xqFoXB5i.png" alt="image-20221003210545678"></p><p>想要了解优先级队列的具体是原理，可以在《数据结构与算法》篇视频教程中学习大顶堆和小顶堆。</p><h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p>前面我们已经介绍了列表，我们接着来看Set集合，这种集合类型比较特殊，我们先来看看Set的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Set</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// Set集合中基本都是从Collection直接继承过来的方法，只不过对这些方法有更加特殊的定义</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>;</span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    Object[] toArray();</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素只有在当前Set集合中不存在此元素时才会成功，如果插入重复元素，那么会失败</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个同样是删除指定元素</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同样是只能插入那些不重复的元素</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法我们同样会放到多线程中进行介绍</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(<span class="built_in">this</span>, Spliterator.DISTINCT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现接口中定义的方法都是Collection中直接继承的，因此，Set支持的功能其实也就和Collection中定义的差不多，只不过：</p><ul><li>不允许出现重复元素</li><li>不支持随机访问（不允许通过下标访问）</li></ul><p>首先认识一下HashSet，它的底层就是采用哈希表实现的（我们在这里先不去探讨实现原理，因为底层实质上是借用的一个HashMap在实现，这个需要我们学习了Map之后再来讨论）我们可以非常高效的从HashSet中存取元素，我们先来测试一下它的特性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    System.out.println(set.add(<span class="string">&quot;AAA&quot;</span>));   <span class="comment">//这里我们连续插入两个同样的字符串</span></span><br><span class="line">    System.out.println(set.add(<span class="string">&quot;AAA&quot;</span>));</span><br><span class="line">    System.out.println(set);   <span class="comment">//可以看到，最后实际上只有一个成功插入了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/y5AoUG1iuWzhOSj.png" alt="image-20221003211330129"></p><p>在Set接口中并没有定义支持指定下标位置访问的添加和删除操作，我们只能简单的删除Set中的某个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    System.out.println(set.add(<span class="string">&quot;AAA&quot;</span>));</span><br><span class="line">    System.out.println(set.remove(<span class="string">&quot;AAA&quot;</span>));</span><br><span class="line">    System.out.println(set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于底层采用哈希表实现，所以说无法维持插入元素的顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    set.addAll(Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;+&quot;</span>));</span><br><span class="line">    System.out.println(set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/OekDqMlpVbxImsK.png" alt="image-20221003211635759"></p><p>那要是我们就是想要使用维持顺序的Set集合呢？我们可以使用LinkedHashSet，LinkedHashSet底层维护的不再是一个HashMap，而是LinkedHashMap，它能够在插入数据时利用链表自动维护顺序，因此这样就能够保证我们插入顺序和最后的迭代顺序一致了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    set.addAll(Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;+&quot;</span>));</span><br><span class="line">    System.out.println(set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/TpczL2Zi1OkaHWI.png" alt="image-20221003212147700"></p><p>还有一种Set叫做TreeSet，它会在元素插入时进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">    set.add(<span class="number">1</span>);</span><br><span class="line">    set.add(<span class="number">3</span>);</span><br><span class="line">    set.add(<span class="number">2</span>);</span><br><span class="line">    System.out.println(set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/3VwDQzRxUTGrOZb.png" alt="image-20221003212233263"></p><p>可以看到最后得到的结果并不是我们插入顺序，而是按照数字的大小进行排列。当然，我们也可以自定义排序规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((a, b) -&gt; b - a);  <span class="comment">//同样是一个Comparator</span></span><br><span class="line">    set.add(<span class="number">1</span>);</span><br><span class="line">    set.add(<span class="number">3</span>);</span><br><span class="line">    set.add(<span class="number">2</span>);</span><br><span class="line">    System.out.println(set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前，Set集合只是粗略的进行了讲解，但是学习Map之后，我们还会回来看我们Set的底层实现，所以说最重要的还是Map。本节只需要记住Set的性质、使用即可。</p><h3 id="Map映射"><a href="#Map映射" class="headerlink" title="Map映射"></a>Map映射</h3><p>什么是映射？我们在高中阶段其实已经学习过映射（Mapping）了，映射指两个元素的之间相互“对应”的关系，也就是说，我们的元素之间是两两对应的，是以键值对的形式存在。</p><p><img src="https://s2.loli.net/2022/10/03/QSxqJLwiNM1nZlO.jpg" alt="39e19f3e-04e8-4c43-8fb5-6d5288a7cdf8"></p><p>而Map就是为了实现这种数据结构而存在的，我们通过保存键值对的形式来存储映射关系，就可以轻松地通过键找到对应的映射值，比如现在我们要保存很多学生的信息，而这些学生都有自己的ID，我们可以将其以映射的形式保存，将ID作为键，学生详细信息作为值，这样我们就可以通过学生的ID快速找到对应学生的信息了。</p><p><img src="https://s2.loli.net/2022/10/03/i2x6m3hzFC5GIAd.png" alt="image-20221003213157956"></p><p>在Map中，这些映射关系被存储为键值对，我们先来看看Map接口中定义了哪些操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Map并不是Collection体系下的接口，而是单独的一个体系，因为操作特殊</span></span><br><span class="line"><span class="comment">//这里需要填写两个泛型参数，其中K就是键的类型，V就是值的类型，比如上面的学生信息，ID一般是int，那么键就是Integer类型的，而值就是学生信息，所以说值是学生对象类型的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">//-------- 查询相关操作 --------</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//获取当前存储的键值对数量</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否为空</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看Map中是否包含指定的键</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看Map中是否包含指定的值</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过给定的键，返回其映射的值</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(Object key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------- 修改相关操作 --------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向Map中添加新的映射关系，也就是新的键值对</span></span><br><span class="line">    V <span class="title function_">put</span><span class="params">(K key, V value)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据给定的键，移除其映射关系，也就是移除对应的键值对</span></span><br><span class="line">    V <span class="title function_">remove</span><span class="params">(Object key)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------- 批量操作 --------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将另一个Map中的所有键值对添加到当前Map中</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空整个Map</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------- 其他视图操作 --------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回Map中存放的所有键，以Set形式返回</span></span><br><span class="line">    Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回Map中存放的所有值</span></span><br><span class="line">    Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回所有的键值对，这里用的是内部类Entry在表示</span></span><br><span class="line">    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个是内部接口Entry，表示一个键值对</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Entry</span>&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="comment">//获取键值对的键</span></span><br><span class="line">        K <span class="title function_">getKey</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取键值对的值</span></span><br><span class="line">        V <span class="title function_">getValue</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改键值对的值</span></span><br><span class="line">        V <span class="title function_">setValue</span><span class="params">(V value)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断两个键值对是否相等</span></span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回当前键值对的哈希值</span></span><br><span class="line">        <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，Map中定义了非常多的方法，尤其是在Java 8之后新增的大量方法，我们会在后面逐步介绍的。</p><p>我们可以来尝试使用一下Map，实际上非常简单，这里我们使用最常见的HashMap，它的底层采用哈希表实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;小明&quot;</span>);   <span class="comment">//使用put方法添加键值对，返回值我们会在后面讨论</span></span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;小红&quot;</span>);</span><br><span class="line">    System.out.println(map.get(<span class="number">2</span>)); <span class="comment">//使用get方法根据键获取对应的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/8Fl6YizINQP9dmX.png" alt="image-20221003214807048"></p><p>注意，Map中无法添加相同的键，同样的键只能存在一个，即使值不同。如果出现键相同的情况，那么会覆盖掉之前的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;小红&quot;</span>);   <span class="comment">//这里的键跟之前的是一样的，这样会导致将之前的键值对覆盖掉</span></span><br><span class="line">    System.out.println(map.get(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/8Fl6YizINQP9dmX.png" alt="image-20221003214807048"></p><p>为了防止意外将之前的键值对覆盖掉，我们可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    map.putIfAbsent(<span class="number">1</span>, <span class="string">&quot;小红&quot;</span>);   <span class="comment">//Java8新增操作，只有在不存在相同键的键值对时才会存放</span></span><br><span class="line">    System.out.println(map.get(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有，我们在获取一个不存在的映射时，默认会返回null作为结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;小明&quot;</span>);   <span class="comment">//Map中只有键为1的映射</span></span><br><span class="line">    System.out.println(map.get(<span class="number">3</span>));  <span class="comment">//此时获取键为3的值，那肯定是没有的，所以说返回null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以为这种情况添加一个预备方案，当Map中不存在时，可以返回一个备选的返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    System.out.println(map.getOrDefault(<span class="number">3</span>, <span class="string">&quot;备胎&quot;</span>));   <span class="comment">//Java8新增操作，当不存在对应的键值对时，返回备选方案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，因为HashMap底层采用哈希表实现，所以不维护顺序，我们在获取所有键和所有值时，可能会是乱序的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String , String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;0&quot;</span>, <span class="string">&quot;十七张&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;+&quot;</span>, <span class="string">&quot;牌&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;P&quot;</span>, <span class="string">&quot;你能秒我&quot;</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">    System.out.println(map.keySet());</span><br><span class="line">    System.out.println(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/DNXqwk3UOPnMmlc.png" alt="image-20221003220156062"></p><p>如果需要维护顺序，我们同样可以使用LinkedHashMap，它的内部对插入顺序进行了维护：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String , String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;0&quot;</span>, <span class="string">&quot;十七张&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;+&quot;</span>, <span class="string">&quot;牌&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;P&quot;</span>, <span class="string">&quot;你能秒我&quot;</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">    System.out.println(map.keySet());</span><br><span class="line">    System.out.println(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/QHkWZsFvzASpxqL.png" alt="image-20221003220458539"></p><p>实际上Map的使用还是挺简单的，我们接着来看看Map的底层是如何实现的，首先是最简单的HashMap，我们前面已经说过了，它的底层采用的是哈希表，首先回顾我们之前学习的哈希表，我们当时说了，哈希表可能会出现哈希冲突，这样保存的元素数量就会存在限制，而我们可以通过连地址法解决这种问题，最后哈希表就长这样了：</p><p><img src="https://s2.loli.net/2022/09/30/kr4CcVEwI72AiDU.png" alt="image-20220820221104298"></p><p>实际上这个表就是一个存放头结点的数组+若干结点，而HashMap也是这样的，我们来看看这里面是怎么定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;   <span class="comment">//内部使用结点，实际上就是存放的映射关系</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;   <span class="comment">//跟我们之前不一样，我们之前一个结点只有键，而这里的结点既存放键也存放值，当然计算哈希还是使用键</span></span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;   <span class="comment">//这个就是哈希表本体了，可以看到跟我们之前的写法是一样的，也是头结点数组，只不过HashMap中没有设计头结点（相当于没有头结点的链表）</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> <span class="type">float</span> loadFactor;   <span class="comment">//负载因子，这个东西决定了HashMap的扩容效果</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">//当我们创建对象时，会使用默认的负载因子，值为0.75</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  ...     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，实际上底层大致结构跟我们之前学习的差不多，只不过多了一些特殊的东西：</p><ul><li>HashMap支持自动扩容，哈希表的大小并不是一直不变的，否则太过死板</li><li>HashMap并不是只使用简单的链地址法，当链表长度到达一定限制时，会转变为效率更高的红黑树结构</li></ul><p>我们来研究一下它的put方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">  <span class="comment">//这里计算完键的哈希值之后，调用的另一个方法进行映射关系存放</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)  <span class="comment">//如果底层哈希表没初始化，先初始化</span></span><br><span class="line">        n = (tab = resize()).length;   <span class="comment">//通过resize方法初始化底层哈希表，初始容量为16，后续会根据情况扩容，底层哈希表的长度永远是2的n次方</span></span><br><span class="line">  <span class="comment">//因为传入的哈希值可能会很大，这里同样是进行取余操作</span></span><br><span class="line">  <span class="comment">//(n - 1) &amp; hash 等价于 hash % n 这里的i就是最终得到的下标位置了</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);   <span class="comment">//如果这个位置上什么都没有，那就直接放一个新的结点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;   <span class="comment">//这种情况就是哈希冲突了</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;   <span class="comment">//如果上来第一个结点的键的哈希值跟当前插入的键的哈希值相同，键也相同，说明已经存放了相同键的键值对了，那就执行覆盖操作</span></span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;   <span class="comment">//这里直接将待插入结点等于原本冲突的结点，一会直接覆盖</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)   <span class="comment">//如果第一个结点是TreeNode类型的，说明这个链表已经升级为红黑树了</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);  <span class="comment">//在红黑树中插入新的结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;  <span class="comment">//普通链表就直接在链表尾部插入</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);  <span class="comment">//找到尾部，直接创建新的结点连在后面</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">//如果当前链表的长度已经很长了，达到了阈值</span></span><br><span class="line">                        treeifyBin(tab, hash);<span class="comment">//那么就转换为红黑树来存放</span></span><br><span class="line">                    <span class="keyword">break</span>;   <span class="comment">//直接结束</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))  <span class="comment">//同样的，如果在向下找的过程中发现已经存在相同键的键值对了，直接结束，让p等于e一会覆盖就行了</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// 如果e不为空，只有可能是前面出现了相同键的情况，其他情况e都是null，所有直接覆盖就行</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;   <span class="comment">//覆盖之后，会返回原本的被覆盖值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)   <span class="comment">//键值对size计数自增，如果超过阈值，会对底层哈希表数组进行扩容</span></span><br><span class="line">        resize();   <span class="comment">//调用resize进行扩容</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">//正常插入键值对返回值为null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉只要前面的数据结构听懂了，这里简直太简单。根据上面的推导，我们在正常插入一个键值对时，会得到null返回值，而冲突时会得到一个被覆盖的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String , String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    System.out.println(map.put(<span class="string">&quot;0&quot;</span>, <span class="string">&quot;十七张&quot;</span>));</span><br><span class="line">    System.out.println(map.put(<span class="string">&quot;0&quot;</span>, <span class="string">&quot;慈善家&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/A2rXocbU9StlDOC.png" alt="image-20221003224137177"></p><p>现在我们知道，当HashMap的一个链表长度过大时，会自动转换为红黑树：</p><p><img src="https://s2.loli.net/2022/10/03/E7GnIVjPAwf8Fol.jpg" alt="710c1c38-95a8-493d-8645-067b991af908"></p><p>但是这样始终治标不治本，受限制的始终是底层哈希表的长度，我们还需要进一步对底层的这个哈希表进行扩容才可以从根本上解决问题，我们来看看<code>resize()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;   <span class="comment">//先把下面这几个旧的东西保存一下</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;  <span class="comment">//这些是新的容量和扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;  <span class="comment">//如果旧容量大于0，那么就开始扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;  <span class="comment">//如果旧的容量已经大于最大限制了，那么直接给到 Integer.MAX_VALUE</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;  <span class="comment">//这种情况不用扩了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)   <span class="comment">//新的容量等于旧容量的2倍，同样不能超过最大值</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">//新的阈值也提升到原来的两倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 旧容量不大于0只可能是还没初始化，这个时候如果阈值大于0，直接将新的容量变成旧的阈值</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// 默认情况下阈值也是0，也就是我们刚刚无参new出来的时候</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;   <span class="comment">//新的容量直接等于默认容量16</span></span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="comment">//阈值为负载因子乘以默认容量，负载因子默认为0.75，也就是说只要整个哈希表用了75%的容量，那么就进行扩容，至于为什么默认是0.75，原因很多，这里就不解释了，反正作为新手，这些都是大佬写出来的，我们用就完事。</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;   <span class="comment">//将底层数组变成新的扩容之后的数组</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;  <span class="comment">//如果旧的数组不为空，那么还需要将旧的数组中所有元素全部搬到新的里面去</span></span><br><span class="line">      ...   <span class="comment">//详细过程就不介绍了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉自己有点了解HashMap的运作机制了，其实并不是想象中的那么难，因为这些东西再怎么都是人写的。</p><p>而LinkedHashMap是直接继承自HashMap，具有HashMap的全部性质，同时得益于每一个节点都是一个双向链表，在插入键值对时，同时保存了插入顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;   <span class="comment">//LinkedHashMap中的结点实现</span></span><br><span class="line">    Entry&lt;K,V&gt; before, after;   <span class="comment">//这里多了一个指向前一个结点和后一个结点的引用</span></span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们在遍历LinkedHashMap时，顺序就同我们的插入顺序一致。当然，也可以使用访问顺序，也就是说对于刚访问过的元素，会被排到最后一位。</p><p>当然还有一种比较特殊的Map叫做TreeMap，就像它的名字一样，就是一个Tree，它的内部直接维护了一个红黑树（没有使用哈希表）因为它会将我们插入的结点按照规则进行排序，所以说直接采用红黑树会更好，我们在创建时，直接给予一个比较规则即可，跟之前的TreeSet是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;Integer , String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">    map.put(<span class="number">0</span>, <span class="string">&quot;单走&quot;</span>);</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;一个六&quot;</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">&quot;**&quot;</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/2oJXBui5aD8q1Gh.png" alt="image-20221003231135805"></p><p>现在我们倒回来看之前讲解的HashSet集合，实际上它的底层很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;   <span class="comment">//对，你没看错，底层直接用map来做事</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为Set只需要存储Key就行了，所以说这个对象当做每一个键值对的共享Value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接构造一个默认大小为16负载因子0.75的HashMap</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//你会发现所有的方法全是替身攻击</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过观察HashSet的源码发现，HashSet几乎都在操作内部维护的一个HashMap，也就是说，HashSet只是一个表壳，而内部维护的HashMap才是灵魂！就像你进了公司，在外面花钱请别人帮你写公司的业务，你只需要坐着等别人写好然后你自己拿去交差就行了。所以说，HashSet利用了HashMap内部的数据结构，轻松地就实现了Set定义的全部功能！</p><p>再来看TreeSet，实际上用的就是我们的TreeMap：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//底层需要一个NavigableMap，就是自动排序的Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不用我说了吧</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接使用TreeMap解决问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，这里就不多做阐述了。</p><p>我们接着来看看Map中定义的哪些杂七杂八的方法，首先来看看<code>compute</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">    map.compute(<span class="number">1</span>, (k, v) -&gt; &#123;   <span class="comment">//compute会将指定Key的值进行重新计算，若Key不存在，v会返回null</span></span><br><span class="line">        <span class="keyword">return</span> v+<span class="string">&quot;M&quot;</span>;     <span class="comment">//这里返回原来的value+M</span></span><br><span class="line">    &#125;);</span><br><span class="line">  map.computeIfPresent(<span class="number">1</span>, (k, v) -&gt; &#123;   <span class="comment">//当Key存在时存在则计算并赋予新的值</span></span><br><span class="line">      <span class="keyword">return</span> v+<span class="string">&quot;M&quot;</span>;     <span class="comment">//这里返回原来的value+M</span></span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用<code>computeIfAbsent</code>，当不存在Key时，计算并将键值对放入Map中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">    map.computeIfAbsent(<span class="number">0</span>, (k) -&gt; &#123;   <span class="comment">//若不存在则计算并插入新的值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;M&quot;</span>;     <span class="comment">//这里返回M</span></span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>merge方法用于处理数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Student&gt; students = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;yoni&quot;</span>, <span class="string">&quot;English&quot;</span>, <span class="number">80</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;yoni&quot;</span>, <span class="string">&quot;Chiness&quot;</span>, <span class="number">98</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;yoni&quot;</span>, <span class="string">&quot;Math&quot;</span>, <span class="number">95</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;taohai.wang&quot;</span>, <span class="string">&quot;English&quot;</span>, <span class="number">50</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;taohai.wang&quot;</span>, <span class="string">&quot;Chiness&quot;</span>, <span class="number">72</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;taohai.wang&quot;</span>, <span class="string">&quot;Math&quot;</span>, <span class="number">41</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Seely&quot;</span>, <span class="string">&quot;English&quot;</span>, <span class="number">88</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Seely&quot;</span>, <span class="string">&quot;Chiness&quot;</span>, <span class="number">89</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Seely&quot;</span>, <span class="string">&quot;Math&quot;</span>, <span class="number">92</span>)</span><br><span class="line">    );</span><br><span class="line">    Map&lt;String, Integer&gt; scoreMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">//merge方法可以对重复键的值进行特殊操作，比如我们想计算某个学生的所有科目分数之后，那么就可以像这样：</span></span><br><span class="line">    students.forEach(student -&gt; scoreMap.merge(student.getName(), student.getScore(), Integer::sum));</span><br><span class="line">    scoreMap.forEach((k, v) -&gt; System.out.println(<span class="string">&quot;key:&quot;</span> + k + <span class="string">&quot;总分&quot;</span> + <span class="string">&quot;value:&quot;</span> + v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, String type, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>replace</code>方法可以快速替换某个映射的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;Integer , String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>, <span class="string">&quot;单走&quot;</span>);</span><br><span class="line">    map.replace(<span class="number">0</span>, <span class="string">&quot;&gt;&gt;&gt;&quot;</span>);   <span class="comment">//直接替换为新的</span></span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以精准匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;Integer , String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>, <span class="string">&quot;单走&quot;</span>);</span><br><span class="line">    map.replace(<span class="number">0</span>, <span class="string">&quot;巴卡&quot;</span>, <span class="string">&quot;玛卡&quot;</span>);   <span class="comment">//只有键和值都匹配时，才进行替换</span></span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包括remove方法，也支持键值同时匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;Integer , String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>, <span class="string">&quot;单走&quot;</span>);</span><br><span class="line">    map.remove(<span class="number">0</span>, <span class="string">&quot;单走&quot;</span>);  <span class="comment">//只有同时匹配时才移除</span></span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉学习了Map之后，涨了不少姿势？</p><h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p><p><img src="https://s2.loli.net/2022/10/03/r4AtmVRZ51y7uxd.png" alt="image-20221003232832897"></p><p>它看起来就像一个工厂的流水线一样！我们就可以把一个Stream当做流水线处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//移除为B的元素</span></span><br><span class="line">  Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="keyword">if</span>(iterator.next().equals(<span class="string">&quot;B&quot;</span>)) iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Stream操作</span></span><br><span class="line">    list = list     <span class="comment">//链式调用</span></span><br><span class="line">            .stream()    <span class="comment">//获取流</span></span><br><span class="line">            .filter(e -&gt; !e.equals(<span class="string">&quot;B&quot;</span>))   <span class="comment">//只允许所有不是B的元素通过流水线</span></span><br><span class="line">            .collect(Collectors.toList());   <span class="comment">//将流水线中的元素重新收集起来，变回List</span></span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能从上述例子中还不能感受到流处理带来的便捷，我们通过下面这个例子来感受一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">  list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    list = list</span><br><span class="line">            .stream()</span><br><span class="line">      .distinct()   <span class="comment">//去重（使用equals判断）</span></span><br><span class="line">            .sorted((a, b) -&gt; b - a)    <span class="comment">//进行倒序排列</span></span><br><span class="line">            .map(e -&gt; e+<span class="number">1</span>)    <span class="comment">//每个元素都要执行+1操作</span></span><br><span class="line">            .limit(<span class="number">2</span>)    <span class="comment">//只放行前两个元素</span></span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当遇到大量的复杂操作时，我们就可以使用Stream来快速编写代码，这样不仅代码量大幅度减少，而且逻辑也更加清晰明了（如果你学习过SQL的话，你会发现它更像一个Sql语句）</p><p><strong>注意</strong>：不能认为每一步是直接依次执行的！我们可以断点测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">list = list</span><br><span class="line">        .stream()</span><br><span class="line">        .distinct()   <span class="comment">//断点</span></span><br><span class="line">        .sorted((a, b) -&gt; b - a)</span><br><span class="line">        .map(e -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>+e);   <span class="comment">//断点</span></span><br><span class="line">            <span class="keyword">return</span> e+<span class="number">1</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .limit(<span class="number">2</span>)   <span class="comment">//断点</span></span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>实际上，stream会先记录每一步操作，而不是直接开始执行内容，当整个链式调用完成后，才会依次进行，也就是说需要的时候，工厂的机器才会按照预定的流程启动。</p><p>接下来，我们用一堆随机数来进行更多流操作的演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();  <span class="comment">//没想到吧，Random支持直接生成随机数的流</span></span><br><span class="line">    random</span><br><span class="line">            .ints(-<span class="number">100</span>, <span class="number">100</span>)   <span class="comment">//生成-100~100之间的，随机int型数字（本质上是一个IntStream）</span></span><br><span class="line">            .limit(<span class="number">10</span>)   <span class="comment">//只获取前10个数字（这是一个无限制的流，如果不加以限制，将会无限进行下去！）</span></span><br><span class="line">            .filter(i -&gt; i &lt; <span class="number">0</span>)   <span class="comment">//只保留小于0的数字</span></span><br><span class="line">            .sorted()    <span class="comment">//默认从小到大排序</span></span><br><span class="line">            .forEach(System.out::println);   <span class="comment">//依次打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以生成一个统计实例来帮助我们快速进行统计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();  <span class="comment">//Random是一个随机数工具类</span></span><br><span class="line">    <span class="type">IntSummaryStatistics</span> <span class="variable">statistics</span> <span class="operator">=</span> random</span><br><span class="line">            .ints(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">            .limit(<span class="number">100</span>)</span><br><span class="line">            .summaryStatistics();    <span class="comment">//获取语法统计实例</span></span><br><span class="line">    System.out.println(statistics.getMax());  <span class="comment">//快速获取最大值</span></span><br><span class="line">    System.out.println(statistics.getCount());  <span class="comment">//获取数量</span></span><br><span class="line">    System.out.println(statistics.getAverage());   <span class="comment">//获取平均值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通的List只需要一个方法就可以直接转换到方便好用的IntStream了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    list.add(<span class="number">4</span>);</span><br><span class="line">    list.stream()</span><br><span class="line">            .mapToInt(i -&gt; i)    <span class="comment">//将每一个元素映射为Integer类型（这里因为本来就是Integer）</span></span><br><span class="line">            .summaryStatistics();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以通过<code>flat</code>来对整个流进行进一步细分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;A,B&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;C,D&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;E,F&quot;</span>);   <span class="comment">//我们想让每一个元素通过,进行分割，变成独立的6个元素</span></span><br><span class="line">    list = list</span><br><span class="line">            .stream()    <span class="comment">//生成流</span></span><br><span class="line">            .flatMap(e -&gt; Arrays.stream(e.split(<span class="string">&quot;,&quot;</span>)))    <span class="comment">//分割字符串并生成新的流</span></span><br><span class="line">            .collect(Collectors.toList());   <span class="comment">//汇成新的List</span></span><br><span class="line">    System.out.println(list);   <span class="comment">//得到结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以只通过Stream来完成所有数字的和，使用<code>reduce</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> list</span><br><span class="line">            .stream()</span><br><span class="line">            .reduce((a, b) -&gt; a + b)   <span class="comment">//计算规则为：a是上一次计算的值，b是当前要计算的参数，这里是求和</span></span><br><span class="line">            .get();    <span class="comment">//我们发现得到的是一个Optional类实例，通过get方法返回得到的值</span></span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能，作为新手来说，一次性无法接受这么多内容，但是在各位以后的开发中，就会慢慢使用到这些东西了。</p><h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><p>我们在前面介绍了Arrays，它是一个用于操作数组的工具类，它给我们提供了大量的工具方法。</p><p>既然数组操作都这么方便了，集合操作能不能也安排点高级的玩法呢？那必须的，JDK为我们准备的Collocations类就是专用于集合的工具类，比如我们想快速求得List中的最大值和最小值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.max(list);</span><br><span class="line">    Collections.min(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，我们可以对一个集合进行二分搜索（注意，集合的具体类型，必须是实现Comparable接口的类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">13</span>);</span><br><span class="line">    System.out.println(Collections.binarySearch(list, <span class="number">8</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以对集合的元素进行快速填充，注意这个填充是对集合中已有的元素进行覆盖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">    Collections.fill(list, <span class="number">6</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果集合中本身没有元素，那么<code>fill</code>操作不会生效。</p><p>有些时候我们可能需要生成一个空的集合类返回，那么我们可以使用<code>emptyXXX</code>来快速生成一个只读的空集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = Collections.emptyList();</span><br><span class="line">  <span class="comment">//Collections.singletonList() 会生成一个只有一个元素的List</span></span><br><span class="line">    list.add(<span class="number">10</span>);   <span class="comment">//不支持，会直接抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以将一个可修改的集合变成只读的集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">    List&lt;Integer&gt; newList = Collections.unmodifiableList(list);</span><br><span class="line">    newList.add(<span class="number">10</span>);   <span class="comment">//不支持，会直接抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以寻找子集合的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">    System.out.println(Collections.indexOfSubList(list, Arrays.asList(<span class="number">4</span>, <span class="number">5</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得益于泛型的类型擦除机制，实际上最后只要是Object的实现类都可以保存到集合类中，那么就会出现这种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//使用原始类型接收一个Integer类型的ArrayList</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">    list.add(<span class="string">&quot;aaa&quot;</span>);   <span class="comment">//我们惊奇地发现，这玩意居然能存字符串进去</span></span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/04/FP5z3X8SEMkGYtT.png" alt="image-20221004001007854"></p><p>没错，由于泛型机制上的一些漏洞，实际上对应类型的集合类有可能会存放其他类型的值，泛型的类型检查只存在于编译阶段，只要我们绕过这个阶段，在实际运行时，并不会真的进行类型检查，要解决这种问题很简单，就是在运行时进行类型检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">    list = Collections.checkedList(list, Integer.class);   <span class="comment">//这里的.class关键字我们会在后面反射中介绍，表示Integer这个类型</span></span><br><span class="line">  list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>checkedXXX</code>可以将给定集合类进行包装，在运行时同样会进行类型检查，如果通过上面的漏洞插入一个本不应该是当前类型集合支持的类型，那么会直接抛出类型转换异常：</p><p><img src="https://s2.loli.net/2022/10/04/5BHq1u9JU3bhdI6.png" alt="image-20221004001409799"></p><p>是不是感觉这个工具类好像还挺好用的？实际上在我们的开发中，这个工具类也经常被使用到。</p><hr><h2 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I/O"></a>Java I/O</h2><p><strong>注意：</strong>这块会涉及到<strong>操作系统</strong>和<strong>计算机组成原理</strong>相关内容。</p><p>I/O简而言之，就是输入输出，那么为什么会有I/O呢？其实I/O无时无刻都在我们的身边，比如读取硬盘上的文件，网络文件传输，鼠标键盘输入，也可以是接受单片机发回的数据，而能够支持这些操作的设备就是I/O设备。</p><p>我们可以大致看一下整个计算机的总线结构：</p><p><img src="https://s2.loli.net/2022/10/04/Q8JGeMprkgHsnPY.png" alt="image-20221004002405375"></p><p>常见的I/O设备一般是鼠标、键盘这类通过USB进行传输的外设或者是通过Sata接口或是M.2连接的硬盘。一般情况下，这些设备是由CPU发出指令通过南桥芯片间接进行控制，而不是由CPU直接操作。</p><p>而我们在程序中，想要读取这些外部连接的I/O设备中的内容，就需要将数据传输到内存中。而需要实现这样的操作，单单凭借一个小的程序是无法做到的，而操作系统（如：Windows/Linux/MacOS）就是专门用于控制和管理计算机硬件和软件资源的软件，我们需要读取一个IO设备的内容时，就可以向操作系统发出请求，由操作系统帮助我们来和底层的硬件交互以完成我们的读取/写入请求。</p><p>从读取硬盘文件的角度来说，不同的操作系统有着不同的文件系统（也就是文件在硬盘中的存储排列方式，如Windows就是NTFS、MacOS就是APFS），硬盘只能存储一个个0和1这样的二进制数据，至于0和1如何排列，各自又代表什么意思，就是由操作系统的文件系统来决定的。从网络通信角度来说，网络信号通过网卡等设备翻译为二进制信号，再交给系统进行读取，最后再由操作系统来给到程序。</p><p><img src="https://s2.loli.net/2022/10/04/13h7yTekm2FfnRw.png" alt="image-20221004002733950"></p><p>（传统的SATA硬盘就是通过SATA线与电脑主板相连，这样才可以读取到数据）</p><p>JDK提供了一套用于IO操作的框架，为了方便我们开发者使用，就定义了一个像水流一样，根据流的传输方向和读取单位，分为字节流InputStream和OutputStream以及字符流Reader和Writer的IO框架，当然，这里的Stream并不是前面集合框架认识的Stream，这里的流指的是数据流，通过流，我们就可以一直从流中读取数据，直到读取到尽头，或是不断向其中写入数据，直到我们写入完成，而这类IO就是我们所说的BIO，</p><p>字节流一次读取一个字节，也就是一个<code>byte</code>的大小，而字符流顾名思义，就是一次读取一个字符，也就是一个<code>char</code>的大小（在读取纯文本文件的时候更加适合），有关这两种流，会在后面详细介绍，这个章节我们需要学习16个关键的流。</p><h3 id="文件字节流"><a href="#文件字节流" class="headerlink" title="文件字节流"></a>文件字节流</h3><p>要学习和使用IO，首先就要从最易于理解的读取文件开始说起。</p><p>首先介绍一下FileInputStream，我们可以通过它来获取文件的输入流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;   <span class="comment">//注意，IO相关操作会有很多影响因素，有可能出现异常，所以需要明确进行处理</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;路径&quot;</span>);</span><br><span class="line">        <span class="comment">//路径支持相对路径和绝对路径</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对路径是在当前运行目录（就是你在哪个目录运行java命令启动Java程序的）的路径下寻找文件，而绝对路径，是从根目录开始寻找。路径分割符支持使用<code>/</code>或是<code>\\</code>，但是不能写为<code>\</code>因为它是转义字符！比如在Windows下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C://User/lbw/nb    这个就是一个绝对路径，因为是从盘符开始的</span><br><span class="line">test/test          这个就是一个相对路径，因为并不是从盘符开始的，而是一个直接的路径</span><br></pre></td></tr></table></figure><p>在Linux和MacOS下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/root/tmp       这个就是一个绝对路径，绝对路径以/开头</span><br><span class="line">test/test       这个就是一个相对路径，不是以/开头的</span><br></pre></td></tr></table></figure><p>当然，这个其实还是很好理解的，我们在使用时注意一下就行了。</p><p>在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">//定义可以先放在try外部</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;路径&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;    <span class="comment">//建议在finally中进行，因为关闭流是任何情况都必须要执行的！</span></span><br><span class="line">            <span class="keyword">if</span>(inputStream != <span class="literal">null</span>) inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这样的写法才是最保险的，但是显得过于繁琐了，尤其是finally中再次嵌套了一个try-catch块，因此在JDK1.7新增了try-with-resource语法，用于简化这样的写法（本质上还是和这样的操作一致，只是换了个写法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意，这种语法只支持实现了AutoCloseable接口的类！</span></span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;路径&quot;</span>)) &#123;   <span class="comment">//直接在try()中定义要在完成之后释放的资源</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;   <span class="comment">//这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无需再编写finally语句块，因为在最后自动帮我们调用了close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后为了方便，我们都使用此语法进行教学。</p><p>现在我们拿到了文件的输入流，那么怎么才能读取文件里面的内容呢？我们可以使用<code>read</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//test.txt：a</span></span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//使用read()方法进行字符读取</span></span><br><span class="line">        System.out.println((<span class="type">char</span>) inputStream.read());  <span class="comment">//读取一个字节的数据（英文字母只占1字节，中文占2字节）</span></span><br><span class="line">        System.out.println(inputStream.read());   <span class="comment">//唯一一个字节的内容已经读完了，再次读取返回-1表示没有内容了</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用read可以直接读取一个字节的数据，注意，流的内容是有限的，读取一个少一个。我们如果想一次性全部读取的话，可以直接使用一个while循环来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//test.txt：abcd</span></span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        <span class="keyword">while</span> ((tmp = inputStream.read()) != -<span class="number">1</span>)&#123;   <span class="comment">//通过while循环来一次性读完内容</span></span><br><span class="line">            System.out.println((<span class="type">char</span>)tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>available</code>方法能查看当前可读的剩余字节数量（注意：并不一定真实的数据量就是这么多，尤其是在网络I/O操作时，这个方法只能进行一个预估也可以说是暂时能一次性可以读取的数量，当然在磁盘IO下，一般情况都是真实的数据量）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">    System.out.println(inputStream.available());  <span class="comment">//查看剩余数量</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，一个一个读取效率太低了，那能否一次性全部读取呢？我们可以预置一个合适容量的byte[]数组来存放：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//test.txt：abcd</span></span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[inputStream.available()];   <span class="comment">//我们可以提前准备好合适容量的byte数组来存放</span></span><br><span class="line">        System.out.println(inputStream.read(bytes));   <span class="comment">//一次性读取全部内容（返回值是读取的字节数）</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes));   <span class="comment">//通过String(byte[])构造方法得到字符串</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以控制要读取数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(inputStream.read(bytes, <span class="number">1</span>, <span class="number">2</span>));   <span class="comment">//第二个参数是从给定数组的哪个位置开始放入内容，第三个参数是读取流中的字节数</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：一次性读取同单个读取一样，当没有任何数据可读时，依然会返回-1</p><p>通过<code>skip()</code>方法可以跳过指定数量的字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//test.txt：abcd</span></span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">        System.out.println(inputStream.skip(<span class="number">1</span>));</span><br><span class="line">        System.out.println((<span class="type">char</span>) inputStream.read());   <span class="comment">//跳过了一个字节</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：FileInputStream是不支持<code>reset()</code>的，虽然有这个方法，但是这里先不提及。</p><p>既然有输入流，那么文件输出流也是必不可少的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//输出流也需要在最后调用close()方法，并且同样支持try-with-resource</span></span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//注意：若此文件不存在，会直接创建这个文件！</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出流没有<code>read()</code>操作而是<code>write()</code>操作，使用方法同输入流一样，只不过现在的方向变为我们向文件里写入内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">        outputStream.write(<span class="string">&#x27;c&#x27;</span>);   <span class="comment">//同read一样，可以直接写入内容</span></span><br><span class="line">      outputStream.write(<span class="string">&quot;lbwnb&quot;</span>.getBytes());   <span class="comment">//也可以直接写入byte[]</span></span><br><span class="line">      outputStream.write(<span class="string">&quot;lbwnb&quot;</span>.getBytes(), <span class="number">0</span>, <span class="number">1</span>);  <span class="comment">//同上输入流</span></span><br><span class="line">      outputStream.flush();  <span class="comment">//建议在最后执行一次刷新操作（强制写入）来保证数据正确写入到硬盘文件中</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如果是我只想在文件尾部进行追加写入数据呢？我们可以调用另一个构造方法来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="literal">true</span>)) &#123;  <span class="comment">//true表示开启追加模式</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;lb&quot;</span>.getBytes());   <span class="comment">//现在只会进行追加写入，而不是直接替换原文件内容</span></span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用输入流和输出流，就可以轻松实现文件的拷贝了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>)) &#123;   <span class="comment">//可以写入多个</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span>];    <span class="comment">//使用长度为10的byte[]做传输媒介</span></span><br><span class="line">        <span class="type">int</span> tmp;   <span class="comment">//存储本地读取字节数</span></span><br><span class="line">        <span class="keyword">while</span> ((tmp = inputStream.read(bytes)) != -<span class="number">1</span>)&#123;   <span class="comment">//直到读取完成为止</span></span><br><span class="line">            outputStream.write(bytes, <span class="number">0</span>, tmp);    <span class="comment">//写入对应长度的数据到输出流</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件字符流"><a href="#文件字符流" class="headerlink" title="文件字符流"></a>文件字符流</h3><p>字符流不同于字节，字符流是以一个具体的字符进行读取，因此它只适合读纯文本的文件，如果是其他类型的文件不适用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;test.txt&quot;</span>))&#123;</span><br><span class="line">      reader.skip(<span class="number">1</span>);   <span class="comment">//现在跳过的是一个字符</span></span><br><span class="line">        System.out.println((<span class="type">char</span>) reader.read());   <span class="comment">//现在是按字符进行读取，而不是字节，因此可以直接读取到中文字符</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，字符流只支持<code>char[]</code>类型作为存储：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;test.txt&quot;</span>))&#123;</span><br><span class="line">        <span class="type">char</span>[] str = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">10</span>];</span><br><span class="line">        reader.read(str);</span><br><span class="line">        System.out.println(str);   <span class="comment">//直接读取到char[]中</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然有了Reader肯定也有Writer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>))&#123;</span><br><span class="line">      writer.getEncoding();   <span class="comment">//支持获取编码（不同的文本文件可能会有不同的编码类型）</span></span><br><span class="line">       writer.write(<span class="string">&#x27;牛&#x27;</span>);</span><br><span class="line">       writer.append(<span class="string">&#x27;牛&#x27;</span>);   <span class="comment">//其实功能和write一样</span></span><br><span class="line">      writer.flush();   <span class="comment">//刷新</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现不仅有<code>write()</code>方法，还有一个<code>append()</code>方法，但是实际上他们效果是一样的，看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Writer <span class="title function_">append</span><span class="params">(<span class="type">char</span> c)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    write(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>append支持像StringBuilder那样的链式调用，返回的是Writer对象本身。</p><p><strong>练习</strong>：尝试一下用Reader和Writer来拷贝纯文本文件。</p><p>这里需要额外介绍一下File类，它是专门用于表示一个文件或文件夹，只不过它只是代表这个文件，但并不是这个文件本身。通过File对象，可以更好地管理和操作硬盘上的文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>);   <span class="comment">//直接创建文件对象，可以是相对路径，也可以是绝对路径</span></span><br><span class="line">    System.out.println(file.exists());   <span class="comment">//此文件是否存在</span></span><br><span class="line">    System.out.println(file.length());   <span class="comment">//获取文件的大小</span></span><br><span class="line">    System.out.println(file.isDirectory());   <span class="comment">//是否为一个文件夹</span></span><br><span class="line">    System.out.println(file.canRead());   <span class="comment">//是否可读</span></span><br><span class="line">    System.out.println(file.canWrite());   <span class="comment">//是否可写</span></span><br><span class="line">    System.out.println(file.canExecute());   <span class="comment">//是否可执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过File对象，我们就能快速得到文件的所有信息，如果是文件夹，还可以获取文件夹内部的文件列表等内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(file.list()));   <span class="comment">//快速获取文件夹下的文件名称列表</span></span><br><span class="line"><span class="keyword">for</span> (File f : file.listFiles())&#123;   <span class="comment">//所有子文件的File对象</span></span><br><span class="line">    System.out.println(f.getAbsolutePath());   <span class="comment">//获取文件的绝对路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们希望读取某个文件的内容，可以直接将File作为参数传入字节流或是字符流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file))&#123;   <span class="comment">//直接做参数</span></span><br><span class="line">    System.out.println(inputStream.available());</span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>练习</strong>：尝试拷贝文件夹下的所有文件到另一个文件夹</p><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>虽然普通的文件流读取文件数据非常便捷，但是每次都需要从外部I/O设备去获取数据，由于外部I/O设备的速度一般都达不到内存的读取速度，很有可能造成程序反应迟钝，因此性能还不够高，而缓冲流正如其名称一样，它能够提供一个缓冲，提前将部分内容存入内存（缓冲区）在下次读取时，如果缓冲区中存在此数据，则无需再去请求外部设备。同理，当向外部设备写入数据时，也是由缓冲区处理，而不是直接向外部设备写入。</p><p><img src="https://s2.loli.net/2022/10/04/S8O61JP2lqKTzjd.png" alt="image-20221004125755217"></p><p>要创建一个缓冲字节流，只需要将原本的流作为构造参数传入BufferedInputStream即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>)))&#123;   <span class="comment">//传入FileInputStream</span></span><br><span class="line">        System.out.println((<span class="type">char</span>) bufferedInputStream.read());   <span class="comment">//操作和原来的流是一样的</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上进行I/O操作的并不是BufferedInputStream，而是我们传入的FileInputStream，而BufferedInputStream虽然有着同样的方法，但是进行了一些额外的处理然后再调用FileInputStream的同名方法，这样的写法称为<code>装饰者模式</code>，我们会在设计模式篇中详细介绍。我们可以来观察一下它的<code>close</code>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer;</span><br><span class="line">    <span class="keyword">while</span> ( (buffer = buf) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bufUpdater.compareAndSet(<span class="built_in">this</span>, buffer, <span class="literal">null</span>)) &#123;  <span class="comment">//CAS无锁算法，并发会用到，暂时不需要了解</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> in;</span><br><span class="line">            in = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (input != <span class="literal">null</span>)</span><br><span class="line">                input.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Else retry in case a new buf was CASed in fill()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这种模式是父类FilterInputStream提供的规范，后面我们还会讲到更多FilterInputStream的子类。</p><p>我们可以发现在BufferedInputStream中还存在一个专门用于缓存的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The internal buffer array where the data is stored. When necessary,</span></span><br><span class="line"><span class="comment"> * it may be replaced by another array of</span></span><br><span class="line"><span class="comment"> * a different size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="type">byte</span> buf[];</span><br></pre></td></tr></table></figure><p>I/O操作一般不能重复读取内容（比如键盘发送的信号，主机接收了就没了），而缓冲流提供了缓冲机制，一部分内容可以被暂时保存，BufferedInputStream支持<code>reset()</code>和<code>mark()</code>操作，首先我们来看看<code>mark()</code>方法的介绍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Marks the current position in this input stream. A subsequent</span></span><br><span class="line"><span class="comment"> * call to the &lt;code&gt;reset&lt;/code&gt; method repositions this stream at</span></span><br><span class="line"><span class="comment"> * the last marked position so that subsequent reads re-read the same bytes.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The &lt;code&gt;readlimit&lt;/code&gt; argument tells this input stream to</span></span><br><span class="line"><span class="comment"> * allow that many bytes to be read before the mark position gets</span></span><br><span class="line"><span class="comment"> * invalidated.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This method simply performs &lt;code&gt;in.mark(readlimit)&lt;/code&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   readlimit   the maximum limit of bytes that can be read before</span></span><br><span class="line"><span class="comment"> *                      the mark position becomes invalid.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.io.FilterInputStream#in</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.io.FilterInputStream#reset()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">mark</span><span class="params">(<span class="type">int</span> readlimit)</span> &#123;</span><br><span class="line">    in.mark(readlimit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用<code>mark()</code>之后，输入流会以某种方式保留之后读取的<code>readlimit</code>数量的内容，当读取的内容数量超过<code>readlimit</code>则之后的内容不会被保留，当调用<code>reset()</code>之后，会使得当前的读取位置回到<code>mark()</code>调用时的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>)))&#123;</span><br><span class="line">        bufferedInputStream.mark(<span class="number">1</span>);   <span class="comment">//只保留之后的1个字符</span></span><br><span class="line">        System.out.println((<span class="type">char</span>) bufferedInputStream.read());</span><br><span class="line">        System.out.println((<span class="type">char</span>) bufferedInputStream.read());</span><br><span class="line">        bufferedInputStream.reset();   <span class="comment">//回到mark时的位置</span></span><br><span class="line">        System.out.println((<span class="type">char</span>) bufferedInputStream.read());</span><br><span class="line">        System.out.println((<span class="type">char</span>) bufferedInputStream.read());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现虽然后面的部分没有保存，但是依然能够正常读取，其实<code>mark()</code>后保存的读取内容是取<code>readlimit</code>和BufferedInputStream类的缓冲区大小两者中的最大值，而并非完全由<code>readlimit</code>确定。因此我们限制一下缓冲区大小，再来观察一下结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>), <span class="number">1</span>))&#123;  <span class="comment">//将缓冲区大小设置为1</span></span><br><span class="line">        bufferedInputStream.mark(<span class="number">1</span>);   <span class="comment">//只保留之后的1个字符</span></span><br><span class="line">        System.out.println((<span class="type">char</span>) bufferedInputStream.read());</span><br><span class="line">        System.out.println((<span class="type">char</span>) bufferedInputStream.read());   <span class="comment">//已经超过了readlimit，继续读取会导致mark失效</span></span><br><span class="line">        bufferedInputStream.reset();   <span class="comment">//mark已经失效，无法reset()</span></span><br><span class="line">        System.out.println((<span class="type">char</span>) bufferedInputStream.read());</span><br><span class="line">        System.out.println((<span class="type">char</span>) bufferedInputStream.read());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解完了BufferedInputStream之后，我们再来看看BufferedOutputStream，其实和BufferedInputStream原理差不多，只是反向操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>)))&#123;</span><br><span class="line">        outputStream.write(<span class="string">&quot;lbwnb&quot;</span>.getBytes());</span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作和FileOutputStream一致，这里就不多做介绍了。</p><p>既然有缓冲字节流，那么肯定也有缓冲字符流，缓冲字符流和缓冲字节流一样，也有一个专门的缓冲区，BufferedReader构造时需要传入一个Reader对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;test.txt&quot;</span>)))&#123;</span><br><span class="line">        System.out.println((<span class="type">char</span>) reader.read());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用和reader也是一样的，内部也包含一个缓存数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">char</span> cb[];</span><br></pre></td></tr></table></figure><p>相比Reader更方便的是，它支持按行读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;test.txt&quot;</span>)))&#123;</span><br><span class="line">        System.out.println(reader.readLine());   <span class="comment">//按行读取</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取后直接得到一个字符串，当然，它还能把每一行内容依次转换为集合类提到的Stream流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;test.txt&quot;</span>)))&#123;</span><br><span class="line">        reader</span><br><span class="line">                .lines()</span><br><span class="line">                .limit(<span class="number">2</span>)</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted()</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它同样也支持<code>mark()</code>和<code>reset()</code>操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;test.txt&quot;</span>)))&#123;</span><br><span class="line">        reader.mark(<span class="number">1</span>);</span><br><span class="line">        System.out.println((<span class="type">char</span>) reader.read());</span><br><span class="line">        reader.reset();</span><br><span class="line">        System.out.println((<span class="type">char</span>) reader.read());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BufferedReader处理纯文本文件时就更加方便了，BufferedWriter在处理时也同样方便：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedWriter</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>)))&#123;</span><br><span class="line">        reader.newLine();   <span class="comment">//使用newLine进行换行</span></span><br><span class="line">        reader.write(<span class="string">&quot;汉堡做滴彳亍不彳亍&quot;</span>);   <span class="comment">//可以直接写入一个字符串</span></span><br><span class="line">      reader.flush();   <span class="comment">//清空缓冲区</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合理使用缓冲流，可以大大提高我们程序的运行效率，只不过现在初学阶段，很少会有机会接触到实际的应用场景。</p><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p>有时会遇到这样一个很麻烦的问题：我这里读取的是一个字符串或是一个个字符，但是我只能往一个OutputStream里输出，但是OutputStream又只支持byte类型，如果要往里面写入内容，进行数据转换就会很麻烦，那么能否有更加简便的方式来做这样的事情呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">OutputStreamWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.txt&quot;</span>)))&#123;  <span class="comment">//虽然给定的是FileOutputStream，但是现在支持以Writer的方式进行写入</span></span><br><span class="line">        writer.write(<span class="string">&quot;lbwnb&quot;</span>);   <span class="comment">//以操作Writer的样子写入OutputStream</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，我们现在只拿到了一个InputStream，但是我们希望能够按字符的方式读取，我们就可以使用InputStreamReader来帮助我们实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">InputStreamReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>)))&#123;  <span class="comment">//虽然给定的是FileInputStream，但是现在支持以Reader的方式进行读取</span></span><br><span class="line">        System.out.println((<span class="type">char</span>) reader.read());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InputStreamReader和OutputStreamWriter本质也是Reader和Writer，因此可以直接放入BufferedReader来实现更加方便的操作。</p><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p>打印流其实我们从一开始就在使用了，比如<code>System.out</code>就是一个PrintStream，PrintStream也继承自FilterOutputStream类因此依然是装饰我们传入的输出流，但是它存在自动刷新机制，例如当向PrintStream流中写入一个字节数组后自动调用<code>flush()</code>方法。PrintStream也永远不会抛出异常，而是使用内部检查机制<code>checkError()</code>方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>可以看到<code>System.out</code>也是PrintStream，不过默认是向控制台打印，我们也可以让它向文件中打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">PrintStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.txt&quot;</span>)))&#123;</span><br><span class="line">        stream.println(<span class="string">&quot;lbwnb&quot;</span>);   <span class="comment">//其实System.out就是一个PrintStream</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们平时使用的<code>println</code>方法就是PrintStream中的方法，它会直接打印基本数据类型或是调用对象的<code>toString()</code>方法得到一个字符串，并将字符串转换为字符，放入缓冲区再经过转换流输出到给定的输出流上。</p><p><img src="https://s2.loli.net/2022/10/04/w8RKJxLm6Ik5usn.png" alt="img"></p><p>因此实际上内部还包含这两个内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Track both the text- and character-output streams, so that their buffers</span></span><br><span class="line"><span class="comment"> * can be flushed without flushing the entire stream.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> BufferedWriter textOut;</span><br><span class="line"><span class="keyword">private</span> OutputStreamWriter charOut;</span><br></pre></td></tr></table></figure><p>与此相同的还有一个PrintWriter，不过他们的功能基本一致，PrintWriter的构造方法可以接受一个Writer作为参数，这里就不再做过多阐述了。</p><p>而我们之前使用的Scanner，使用的是系统提供的输入流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);   <span class="comment">//系统输入流，默认是接收控制台输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以使用Scanner来扫描其他的输入流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;秘制小汉堡.txt&quot;</span>));  <span class="comment">//将文件内容作为输入流进行扫描</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于直接扫描文件中编写的内容，同样可以读取。</p><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>数据流DataInputStream也是FilterInputStream的子类，同样采用装饰者模式，最大的不同是它支持基本数据类型的直接读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">DataInputStream</span> <span class="variable">dataInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>)))&#123;</span><br><span class="line">        System.out.println(dataInputStream.readBoolean());   <span class="comment">//直接将数据读取为任意基本数据类型</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于写入基本数据类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">DataOutputStream</span> <span class="variable">dataOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>)))&#123;</span><br><span class="line">        dataOutputStream.writeBoolean(<span class="literal">false</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，写入的是二进制数据，并不是写入的字符串，使用DataInputStream可以读取，一般他们是配合一起使用的。</p><h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><p>既然基本数据类型能够读取和写入基本数据类型，那么能否将对象也支持呢？ObjectOutputStream不仅支持基本数据类型，通过对对象的序列化操作，以某种格式保存对象，来支持对象类型的IO，注意：它不是继承自FilterInputStream的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>));</span><br><span class="line">         <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;output.txt&quot;</span>)))&#123;</span><br><span class="line">        <span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;lbw&quot;</span>);</span><br><span class="line">        outputStream.writeObject(people);</span><br><span class="line">      outputStream.flush();</span><br><span class="line">        people = (People) inputStream.readObject();</span><br><span class="line">        System.out.println(people.name);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;   <span class="comment">//必须实现Serializable接口才能被序列化</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">People</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们后续的操作中，有可能会使得这个类的一些结构发生变化，而原来保存的数据只适用于之前版本的这个类，因此我们需要一种方法来区分类的不同版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">123456</span>;   <span class="comment">//在序列化时，会被自动添加这个属性，它代表当前类的版本，我们也可以手动指定版本。</span></span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">People</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当发生版本不匹配时，会无法反序列化为对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException: com.test.Main$People; local <span class="keyword">class</span> <span class="title class_">incompatible</span>: stream <span class="type">classdesc</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">123456</span>, local <span class="keyword">class</span> <span class="title class_">serialVersionUID</span> = <span class="number">1234567</span></span><br><span class="line">at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:<span class="number">699</span>)</span><br><span class="line">at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:<span class="number">2003</span>)</span><br><span class="line">at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:<span class="number">1850</span>)</span><br><span class="line">at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class="number">2160</span>)</span><br><span class="line">at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class="number">1667</span>)</span><br><span class="line">at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="number">503</span>)</span><br><span class="line">at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="number">461</span>)</span><br><span class="line">at com.test.Main.main(Main.java:<span class="number">27</span>)</span><br></pre></td></tr></table></figure><p>如果我们不希望某些属性参与到序列化中进行保存，我们可以添加<code>transient</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>));</span><br><span class="line">         <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;output.txt&quot;</span>)))&#123;</span><br><span class="line">        <span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;lbw&quot;</span>);</span><br><span class="line">        outputStream.writeObject(people);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        people = (People) inputStream.readObject();</span><br><span class="line">        System.out.println(people.name);  <span class="comment">//虽然能得到对象，但是name属性并没有保存，因此为null</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1234567</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">People</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我们可以看到，在一些JDK内部的源码中，也存在大量的transient关键字，使得某些属性不参与序列化，取消这些不必要保存的属性，可以节省数据空间占用以及减少序列化时间。</p><hr><h2 id="实战：图书管理系统"><a href="#实战：图书管理系统" class="headerlink" title="实战：图书管理系统"></a>实战：图书管理系统</h2><p>要求实现一个图书管理系统（控制台），支持以下功能：保存书籍信息（要求持久化），查询、添加、删除、修改书籍信息。</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="java" scheme="https://www.hoveco.top/categories/java/"/>
    
    
    <category term="JavaSE" scheme="https://www.hoveco.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-学习笔记-多线程与反射（七）</title>
    <link href="https://www.hoveco.top/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89/"/>
    <id>https://www.hoveco.top/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89/</id>
    <published>2023-10-12T00:30:00.000Z</published>
    <updated>2023-10-12T14:49:22.612Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/10/04/aRsN9WoS7BcC3uY.png" alt="image-20221004132312588"></p><h1 id="多线程与反射"><a href="#多线程与反射" class="headerlink" title="多线程与反射"></a>多线程与反射</h1><p>前面我们已经讲解了JavaSE的大部分核心内容，最后一章，我们还将继续学习JavaSE中提供的各种高级特性。这些高级特性对于我们之后的学习，会有着举足轻重的作用。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><strong>注意：</strong>本章节会涉及到 <strong>操作系统</strong> 相关知识。</p><p>在了解多线程之前，让我们回顾一下<code>操作系统</code>中提到的进程概念：</p><p><img src="https://s2.loli.net/2022/10/04/GhrSTfNRsc2jFZM.jpg" alt="b040eadb-8aa1-4b2a-b587-2c0a6b4efa0b"></p><p>进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当出现多个进程需要同时运行时，CPU一般通过<code>时间片轮转调度</code>算法，来实现多个进程的同时运行。</p><p><img src="https://s2.loli.net/2022/10/04/hUkGafu7vztB4qR.png" alt="image-20221004132729868"></p><p>在早期的计算机中，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。但是，如果我希望两个任务同时进行，就必须运行两个进程，由于每个进程都有一个自己的内存空间，进程之间的通信就变得非常麻烦（比如要共享某些数据）而且执行不同进程会产生上下文切换，非常耗时，那么能否实现在一个进程中就能够执行多个任务呢？</p><p><img src="https://s2.loli.net/2022/10/04/okgq3HEKGn6jBVw.png" alt="image-20221004132700554"></p><p>后来，线程横空出世，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。</p><p>在Java中，我们从开始，一直以来编写的都是单线程应用程序（运行<code>main()</code>方法的内容），也就是说只能同时执行一个任务（无论你是调用方法、还是进行计算，始终都是依次进行的，也就是同步的），而如果我们希望同时执行多个任务（两个方法<strong>同时</strong>在运行或者是两个计算同时在进行，也就是异步的），就需要用到Java多线程框架。实际上一个Java程序启动后，会创建很多线程，不仅仅只运行一个主线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ThreadMXBean</span> <span class="variable">bean</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line">    <span class="type">long</span>[] ids = bean.getAllThreadIds();</span><br><span class="line">    ThreadInfo[] infos = bean.getThreadInfo(ids);</span><br><span class="line">    <span class="keyword">for</span> (ThreadInfo info : infos) &#123;</span><br><span class="line">        System.out.println(info.getThreadName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于除了main线程默认以外的线程，涉及到JVM相关底层原理，在这里不做讲解，了解就行。</p><h3 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a>线程的创建和启动</h3><p>通过创建Thread对象来创建一个新的线程，Thread构造方法中需要传入一个Runnable接口的实现（其实就是编写要在另一个线程执行的内容逻辑）同时Runnable只有一个未实现方法，因此可以直接使用lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建好后，通过调用<code>start()</code>方法来运行此线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;    <span class="comment">//直接编写逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我是另一个线程！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();   <span class="comment">//调用此方法来开始执行此线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能上面的例子看起来和普通的单线程没两样，那我们先来看看下面这段代码的运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是线程：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;我正在计算 0-10000 之间所有数的和...&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结果：&quot;</span>+sum);</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    System.out.println(<span class="string">&quot;我是主线程！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，这段代码执行输出结果并不是按照从上往下的顺序了，因为他们分别位于两个线程，他们是同时进行的！如果你还是觉得很疑惑，我们接着来看下面的代码运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是一号线程：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是二号线程：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到打印实际上是在交替进行的，也证明了他们是在同时运行！</p><p><strong>注意</strong>：我们发现还有一个run方法，也能执行线程里面定义的内容，但是run是直接在当前线程执行，并不是创建一个线程执行！</p><p><img src="https://s2.loli.net/2022/10/04/Srx4H8YyRWqXofc.png" alt="image-20221004133119997"></p><p>实际上，线程和进程差不多，也会等待获取CPU资源，一旦获取到，就开始按顺序执行我们给定的程序，当需要等待外部IO操作（比如Scanner获取输入的文本），就会暂时处于休眠状态，等待通知，或是调用<code>sleep()</code>方法来让当前线程休眠一段时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;l&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);    <span class="comment">//休眠时间，以毫秒为单位，1000ms = 1s</span></span><br><span class="line">    System.out.println(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;nb!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以使用<code>stop()</code>方法来强行终止此线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">me</span> <span class="operator">=</span> Thread.currentThread();   <span class="comment">//获取当前线程对象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;打印:&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">20</span>) me.stop();  <span class="comment">//此方法会直接终止此线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然<code>stop()</code>方法能够终止此线程，但是并不是所推荐的做法，有关线程中断相关问题，我们会在后面继续了解。</p><p><strong>思考</strong>：猜猜以下程序输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) value++;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1完成&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) value++;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2完成&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);  <span class="comment">//主线程停止1秒，保证两个线程执行完成</span></span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，value最后的值并不是我们理想的结果，有关为什么会出现这种问题，在我们学习到线程锁的时候，再来探讨。</p><h3 id="线程的休眠和中断"><a href="#线程的休眠和中断" class="headerlink" title="线程的休眠和中断"></a>线程的休眠和中断</h3><p>我们前面提到，一个线程处于运行状态下，线程的下一个状态会出现以下情况：</p><ul><li>当CPU给予的运行时间结束时，会从运行状态回到就绪（可运行）状态，等待下一次获得CPU资源。</li><li>当线程进入休眠 / 阻塞(如等待IO请求) / 手动调用<code>wait()</code>方法时，会使得线程处于等待状态，当等待状态结束后会回到就绪状态。</li><li>当线程出现异常或错误 / 被<code>stop()</code> 方法强行停止 / 所有代码执行结束时，会使得线程的运行终止。</li></ul><p>而这个部分我们着重了解一下线程的休眠和中断，首先我们来了解一下如何使得线程进如休眠状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;l&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);   <span class="comment">//sleep方法是Thread的静态方法，它只作用于当前线程（它知道当前线程是哪个）</span></span><br><span class="line">            System.out.println(<span class="string">&quot;b&quot;</span>);    <span class="comment">//调用sleep后，线程会直接进入到等待状态，直到时间结束</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用<code>sleep()</code>方法来将当前线程进入休眠，使得线程处于等待状态一段时间。我们发现，此方法显示声明了会抛出一个InterruptedException异常，那么这个异常在什么时候会发生呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);  <span class="comment">//休眠10秒</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);   <span class="comment">//休眠3秒，一定比线程t先醒来</span></span><br><span class="line">        t.interrupt();   <span class="comment">//调用t的interrupt方法</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，每一个Thread对象中，都有一个<code>interrupt()</code>方法，调用此方法后，会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作，由线程来响应此中断并进行相应的处理，我们前面提到的<code>stop()</code>方法是强制终止线程，这样的做法虽然简单粗暴，但是很有可能导致资源不能完全释放，而类似这样的发送通知来告知线程需要中断，让线程自行处理后续，会更加合理一些，也是更加推荐的做法。我们来看看interrupt的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程开始运行！&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;   <span class="comment">//无限循环</span></span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;   <span class="comment">//判断是否存在中断标志</span></span><br><span class="line">                <span class="keyword">break</span>;   <span class="comment">//响应中断</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程被中断了！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);   <span class="comment">//休眠3秒，一定比线程t先醒来</span></span><br><span class="line">        t.interrupt();   <span class="comment">//调用t的interrupt方法</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>isInterrupted()</code>可以判断线程是否存在中断标志，如果存在，说明外部希望当前线程立即停止，也有可能是给当前线程发送一个其他的信号，如果我们并不是希望收到中断信号就是结束程序，而是通知程序做其他事情，我们可以在收到中断信号后，复位中断标记，然后继续做我们的事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程开始运行！&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;   <span class="comment">//判断是否存在中断标志</span></span><br><span class="line">                System.out.println(<span class="string">&quot;发现中断信号，复位，继续运行...&quot;</span>);</span><br><span class="line">                Thread.interrupted();  <span class="comment">//复位中断标记（返回值是当前是否有中断标记，这里不用管）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);   <span class="comment">//休眠3秒，一定比线程t先醒来</span></span><br><span class="line">        t.interrupt();   <span class="comment">//调用t的interrupt方法</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复位中断标记后，会立即清除中断标记。那么，如果现在我们想暂停线程呢？我们希望线程暂时停下，比如等待其他线程执行完成后，再继续运行，那这样的操作怎么实现呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程开始运行！&quot;</span>);</span><br><span class="line">        Thread.currentThread().suspend();   <span class="comment">//暂停此线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程继续运行！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);   <span class="comment">//休眠3秒，一定比线程t先醒来</span></span><br><span class="line">        t.resume();   <span class="comment">//恢复此线程</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这样很方便地控制了线程的暂停状态，但是这两个方法我们发现实际上也是不推荐的做法，它很容易导致死锁！有关为什么被弃用的原因，我们会在线程锁继续探讨。</p><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>实际上，Java程序中的每个线程并不是平均分配CPU时间的，为了使得线程资源分配更加合理，Java采用的是抢占式调度方式，优先级越高的线程，优先使用CPU资源！我们希望CPU花费更多的时间去处理更重要的任务，而不太重要的任务，则可以先让出一部分资源。线程的优先级一般分为以下三种：</p><ul><li>MIN_PRIORITY  最低优先级</li><li>MAX_PRIORITY  最高优先级</li><li>NOM_PRIORITY  常规优先级</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程开始运行！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    t.setPriority(Thread.MIN_PRIORITY);  <span class="comment">//通过使用setPriority方法来设定优先级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优先级越高的线程，获得CPU资源的概率会越大，并不是说一定优先级越高的线程越先执行！</p><h3 id="线程的礼让和加入"><a href="#线程的礼让和加入" class="headerlink" title="线程的礼让和加入"></a>线程的礼让和加入</h3><p>我们还可以在当前线程的工作不重要时，将CPU资源让位给其他线程，通过使用<code>yield()</code>方法来将当前资源让位给其他同优先级线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1开始运行！&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;让位！&quot;</span>);</span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;1打印：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1结束！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2开始运行！&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;2打印：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察结果，我们发现，在让位之后，尽可能多的在执行线程2的内容。</p><p>当我们希望一个线程等待另一个线程执行完成后再继续进行，我们可以使用<code>join()</code>方法来实现线程的加入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1开始运行！&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;1打印：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1结束！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2开始运行！&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;2打印：&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1加入到此线程！&quot;</span>);</span><br><span class="line">                    t1.join();    <span class="comment">//在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，线程1加入后，线程2等待线程1待执行的内容全部执行完成之后，再继续执行的线程2内容。注意，线程的加入只是等待另一个线程的完成，并不是将另一个线程和当前线程合并！我们来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;开始运行！&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;打印：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1结束！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2开始运行！&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;2打印：&quot;</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1加入到此线程！&quot;</span>);</span><br><span class="line">                    t1.join();    <span class="comment">//在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，t2线程只是暂时处于等待状态，当t1执行结束时，t2才开始继续执行，只是在效果上看起来好像是两个线程合并为一个线程在执行而已。</p><h3 id="线程锁和线程同步"><a href="#线程锁和线程同步" class="headerlink" title="线程锁和线程同步"></a>线程锁和线程同步</h3><p>在开始讲解线程同步之前，我们需要先了解一下多线程情况下Java的内存管理：</p><p><img src="https://s2.loli.net/2022/10/04/ZvI8neF3tdGJwS4.png" alt="image-20221004203914215"></p><p>线程之间的共享变量（比如之前悬念中的value变量）存储在主内存（main memory）中，每个线程都有一个私有的工作内存（本地内存），工作内存中存储了该线程以读/写共享变量的副本。它类似于我们在<code>计算机组成原理</code>中学习的多核心处理器高速缓存机制：</p><p><img src="https://s2.loli.net/2022/10/04/SKlbIZyvxMnauLJ.png" alt="image-20221004204209038"></p><p>高速缓存通过保存内存中数据的副本来提供更加快速的数据访问，但是如果多个处理器的运算任务都涉及同一块内存区域，就可能导致各自的高速缓存数据不一致，在写回主内存时就会发生冲突，这就是引入高速缓存引发的新问题，称之为：缓存一致性。</p><p>实际上，Java的内存模型也是这样类似设计的，当我们同时去操作一个共享变量时，如果仅仅是读取还好，但是如果同时写入内容，就会出现问题！好比说一个银行，如果我和我的朋友同时在银行取我账户里面的钱，难道取1000还可能吐2000出来吗？我们需要一种更加安全的机制来维持秩序，保证数据的安全性！</p><p>比如我们可以来看看下面这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) value++;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1完成&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) value++;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2完成&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);  <span class="comment">//主线程停止1秒，保证两个线程执行完成</span></span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，当两个线程同时读取value的时候，可能会同时拿到同样的值，而进行自增操作之后，也是同样的值，再写回主内存后，本来应该进行2次自增操作，实际上只执行了一次！</p><p><img src="https://s2.loli.net/2022/10/04/T2l3xfIP17Gr5dw.png" alt="image-20221004204439553"></p><p>通过synchronized关键字来创造一个线程锁，首先我们来认识一下synchronized代码块，它需要在括号中填入一个内容，必须是一个对象或是一个类，我们在value自增操作外套上同步代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Main.class)&#123;  <span class="comment">//使用synchronized关键字创建同步代码块</span></span><br><span class="line">                value++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1完成&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Main.class)&#123;</span><br><span class="line">                value++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2完成&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);  <span class="comment">//主线程停止1秒，保证两个线程执行完成</span></span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，现在得到的结果就是我们想要的内容了，因为在同步代码块执行过程中，拿到了我们传入对象或类的锁（传入的如果是对象，就是对象锁，不同的对象代表不同的对象锁，如果是类，就是类锁，类锁只有一个，实际上类锁也是对象锁，是Class类实例，但是Class类实例同样的类无论怎么获取都是同一个），但是注意两个线程必须使用同一把锁！</p><p>当一个线程进入到同步代码块时，会获取到当前的锁，而这时如果其他使用同样的锁的同步代码块也想执行内容，就必须等待当前同步代码块的内容执行完毕，在执行完毕后会自动释放这把锁，而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容（实际上synchronized是一种悲观锁，随时都认为有其他线程在对数据进行修改，后面在JUC篇视频教程中我们还会讲到乐观锁，如CAS算法）</p><p>那么我们来看看，如果使用的是不同对象的锁，那么还能顺利进行吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Main</span> <span class="variable">main1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">    <span class="type">Main</span> <span class="variable">main2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (main1)&#123;</span><br><span class="line">                value++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1完成&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (main2)&#123;</span><br><span class="line">                value++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2完成&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);  <span class="comment">//主线程停止1秒，保证两个线程执行完成</span></span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当对象不同时，获取到的是不同的锁，因此并不能保证自增操作的原子性，最后也得不到我们想要的结果。</p><p>synchronized关键字也可以作用于方法上，调用此方法时也会获取锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">    value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) add();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1完成&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) add();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2完成&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);  <span class="comment">//主线程停止1秒，保证两个线程执行完成</span></span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现实际上效果是相同的，只不过这个锁不用你去给，如果是静态方法，就是使用的类锁，而如果是普通成员方法，就是使用的对象锁。通过灵活的使用synchronized就能很好地解决我们之前提到的问题了。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>其实死锁的概念在<code>操作系统</code>中也有提及，它是指两个线程相互持有对方需要的锁，但是又迟迟不释放，导致程序卡住：</p><p><img src="https://s2.loli.net/2022/10/04/Ja6TPO23wCI8pvn.png" alt="image-20221004205058223"></p><p>我们发现，线程A和线程B都需要对方的锁，但是又被对方牢牢把握，由于线程被无限期地阻塞，因此程序不可能正常终止。我们来看看以下这段代码会得到什么结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，我们在编写程序时，一定要注意，不要出现这种死锁的情况。那么我们如何去检测死锁呢？我们可以利用jstack命令来检测死锁，首先利用jps找到我们的java进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">nagocoler@NagodeMacBook-Pro ~ % jps</span><br><span class="line">51592 Launcher</span><br><span class="line">51690 Jps</span><br><span class="line">14955 </span><br><span class="line">51693 Main</span><br><span class="line">nagocoler@NagodeMacBook-Pro ~ % jstack 51693</span><br><span class="line">...</span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">at com.test.Main.lambda$main$1(Main.java:46)</span><br><span class="line">- waiting to lock &lt;0x000000076ad27fc0&gt; (a java.lang.Object)</span><br><span class="line">- locked &lt;0x000000076ad27fd0&gt; (a java.lang.Object)</span><br><span class="line">at com.test.Main$$Lambda$2/1867750575.run(Unknown Source)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">at com.test.Main.lambda$main$0(Main.java:34)</span><br><span class="line">- waiting to lock &lt;0x000000076ad27fd0&gt; (a java.lang.Object)</span><br><span class="line">- locked &lt;0x000000076ad27fc0&gt; (a java.lang.Object)</span><br><span class="line">at com.test.Main$$Lambda$1/396873410.run(Unknown Source)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure><p>jstack自动帮助我们找到了一个死锁，并打印出了相关线程的栈追踪信息，同样的，使用<code>jconsole</code>也可以进行监测。</p><p>因此，前面说不推荐使用 <code>suspend()</code>去挂起线程的原因，是因为<code>suspend()</code>在使线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行<code>resume()</code>方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。但是，如果<code>resume()</code>操作出现在<code>suspend()</code>之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。</p><h3 id="wait和notify方法"><a href="#wait和notify方法" class="headerlink" title="wait和notify方法"></a>wait和notify方法</h3><p>其实我们之前可能就发现了，Object类还有三个方法我们从来没有使用过，分别是<code>wait()</code>、<code>notify()</code>以及<code>notifyAll()</code>，他们其实是需要配合synchronized来使用的（实际上锁就是依附于对象存在的，每个对象都应该有针对于锁的一些操作，所以说就这样设计了）当然，只有在同步代码块中才能使用这些方法，正常情况下会报错，我们来看看他们的作用是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始等待&quot;</span>);</span><br><span class="line">                o1.wait();     <span class="comment">//进入等待状态并释放锁</span></span><br><span class="line">                System.out.println(<span class="string">&quot;等待结束！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;开始唤醒！&quot;</span>);</span><br><span class="line">            o1.notify();     <span class="comment">//唤醒处于等待状态的线程</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">               System.out.println(i);   </span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//唤醒后依然需要等待这里的锁释放之前等待的线程才能继续</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现，对象的<code>wait()</code>方法会暂时使得此线程进入等待状态，同时会释放当前代码块持有的锁，这时其他线程可以获取到此对象的锁，当其他线程调用对象的<code>notify()</code>方法后，会唤醒刚才变成等待状态的线程（这时并没有立即释放锁）。注意，必须是在持有锁（同步代码块内部）的情况下使用，否则会抛出异常！</p><p>notifyAll其实和notify一样，也是用于唤醒，但是前者是唤醒所有调用<code>wait()</code>后处于等待的线程，而后者是看运气随机选择一个。</p><h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><p>既然每个线程都有一个自己的工作内存，那么能否只在自己的工作内存中创建变量仅供线程自己使用呢？</p><p><img src="https://img2018.cnblogs.com/blog/1368768/201906/1368768-20190613220434628-1803630402.png" alt="img"></p><p>我们可以使用ThreadLocal类，来创建工作内存中的变量，它将我们的变量值存储在内部（只能存储一个变量），不同的线程访问到ThreadLocal对象时，都只能获取到当前线程所属的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    ThreadLocal&lt;String&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();  <span class="comment">//注意这是一个泛型类，存储类型为我们要存放的变量类型</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        local.set(<span class="string">&quot;lbwnb&quot;</span>);   <span class="comment">//将变量的值给予ThreadLocal</span></span><br><span class="line">        System.out.println(<span class="string">&quot;变量值已设定！&quot;</span>);</span><br><span class="line">        System.out.println(local.get());   <span class="comment">//尝试获取ThreadLocal中存放的变量</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(local.get());   <span class="comment">//尝试获取ThreadLocal中存放的变量</span></span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);    <span class="comment">//间隔三秒</span></span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，我们开启两个线程分别去访问ThreadLocal对象，我们发现，第一个线程存放的内容，第一个线程可以获取，但是第二个线程无法获取，我们再来看看第一个线程存入后，第二个线程也存放，是否会覆盖第一个线程存放的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    ThreadLocal&lt;String&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();  <span class="comment">//注意这是一个泛型类，存储类型为我们要存放的变量类型</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        local.set(<span class="string">&quot;lbwnb&quot;</span>);   <span class="comment">//将变量的值给予ThreadLocal</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程1变量值已设定！&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);    <span class="comment">//间隔2秒</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1读取变量值：&quot;</span>);</span><br><span class="line">        System.out.println(local.get());   <span class="comment">//尝试获取ThreadLocal中存放的变量</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        local.set(<span class="string">&quot;yyds&quot;</span>);   <span class="comment">//将变量的值给予ThreadLocal</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程2变量值已设定！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);    <span class="comment">//间隔1秒</span></span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，即使线程2重新设定了值，也没有影响到线程1存放的值，所以说，不同线程向ThreadLocal存放数据，只会存放在线程自己的工作空间中，而不会直接存放到主内存中，因此各个线程直接存放的内容互不干扰。</p><p>我们发现在线程中创建的子线程，无法获得父线程工作内存中的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ThreadLocal&lt;String&gt; local = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">       local.set(<span class="string">&quot;lbwnb&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(local.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用InheritableThreadLocal来解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ThreadLocal&lt;String&gt; local = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">       local.set(<span class="string">&quot;lbwnb&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(local.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在InheritableThreadLocal存放的内容，会自动向子线程传递。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>我们有时候会有这样的需求，我希望定时执行任务，比如3秒后执行，其实我们可以通过使用<code>Thread.sleep()</code>来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TimerTask</span>(() -&gt; System.out.println(<span class="string">&quot;我是定时任务！&quot;</span>), <span class="number">3000</span>).start();   <span class="comment">//创建并启动此定时任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TimerTask</span>&#123;</span><br><span class="line">    Runnable task;</span><br><span class="line">    <span class="type">long</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TimerTask</span><span class="params">(Runnable runnable, <span class="type">long</span> time)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.task = runnable;</span><br><span class="line">        <span class="built_in">this</span>.time = time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(time);</span><br><span class="line">                task.run();   <span class="comment">//休眠后再运行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过自行封装一个TimerTask类，并在启动时，先休眠3秒钟，再执行我们传入的内容。那么现在我们希望，能否循环执行一个任务呢？比如我希望每隔1秒钟执行一次代码，这样该怎么做呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TimerLoopTask</span>(() -&gt; System.out.println(<span class="string">&quot;我是定时任务！&quot;</span>), <span class="number">3000</span>).start();   <span class="comment">//创建并启动此定时任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TimerLoopTask</span>&#123;</span><br><span class="line">    Runnable task;</span><br><span class="line">    <span class="type">long</span> loopTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TimerLoopTask</span><span class="params">(Runnable runnable, <span class="type">long</span> loopTime)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.task = runnable;</span><br><span class="line">        <span class="built_in">this</span>.loopTime = loopTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)&#123;   <span class="comment">//无限循环执行</span></span><br><span class="line">                    Thread.sleep(loopTime);</span><br><span class="line">                    task.run();   <span class="comment">//休眠后再运行</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们将单次执行放入到一个无限循环中，这样就能一直执行了，并且按照我们的间隔时间进行。</p><p>但是终究是我们自己实现，可能很多方面还没考虑到，Java也为我们提供了一套自己的框架用于处理定时任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();    <span class="comment">//创建定时器对象</span></span><br><span class="line">    timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;   <span class="comment">//注意这个是一个抽象类，不是接口，无法使用lambda表达式简化，只能使用匿名内部类</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());    <span class="comment">//打印当前线程名称</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);    <span class="comment">//执行一个延时任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过创建一个Timer类来让它进行定时任务调度，我们可以通过此对象来创建任意类型的定时任务，包延时任务、循环定时任务等。我们发现，虽然任务执行完成了，但是我们的程序并没有停止，这是因为Timer内存维护了一个任务队列和一个工作线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The timer task queue.  This data structure is shared with the timer</span></span><br><span class="line"><span class="comment">     * thread.  The timer produces tasks, via its various schedule calls,</span></span><br><span class="line"><span class="comment">     * and the timer thread consumes, executing timer tasks as appropriate,</span></span><br><span class="line"><span class="comment">     * and removing them from the queue when they&#x27;re obsolete.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">TaskQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The timer thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">TimerThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerThread</span>(queue);</span><br><span class="line">  </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TimerThread继承自Thread，是一个新创建的线程，在构造时自动启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Timer</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    thread.setName(name);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而它的run方法会循环地读取队列中是否还有任务，如果有任务依次执行，没有的话就暂时处于休眠状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mainLoop();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Someone killed this Thread, behave as if Timer cancelled</span></span><br><span class="line">        <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">            newTasksMayBeScheduled = <span class="literal">false</span>;</span><br><span class="line">            queue.clear();  <span class="comment">// Eliminate obsolete references</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The main timer loop.  (See class comment.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mainLoop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">       TimerTask task;</span><br><span class="line">       <span class="type">boolean</span> taskFired;</span><br><span class="line">       <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">         <span class="comment">// Wait for queue to become non-empty</span></span><br><span class="line">          <span class="keyword">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)   <span class="comment">//当队列为空同时没有被关闭时，会调用wait()方法暂时处于等待状态，当有新的任务时，会被唤醒。</span></span><br><span class="line">                queue.wait();</span><br><span class="line">          <span class="keyword">if</span> (queue.isEmpty())</span><br><span class="line">             <span class="keyword">break</span>;    <span class="comment">//当被唤醒后都没有任务时，就会结束循环，也就是结束工作线程</span></span><br><span class="line">                      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>newTasksMayBeScheduled</code>实际上就是标记当前定时器是否关闭，当它为false时，表示已经不会再有新的任务到来，也就是关闭，我们可以通过调用<code>cancel()</code>方法来关闭它的工作线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">        thread.newTasksMayBeScheduled = <span class="literal">false</span>;</span><br><span class="line">        queue.clear();</span><br><span class="line">        queue.notify();  <span class="comment">//唤醒wait使得工作线程结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们可以在使用完成后，调用Timer的<code>cancel()</code>方法以正常退出我们的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">    timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            timer.cancel();  <span class="comment">//结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>不要把操作系统重的守护进程和守护线程相提并论！</p><p>守护进程在后台运行运行，不需要和用户交互，本质和普通进程类似。而守护线程就不一样了，当其他所有的非守护线程结束之后，守护线程自动结束，也就是说，Java中所有的线程都执行完毕后，守护线程自动结束，因此守护线程不适合进行IO操作，只适合打打杂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;程序正常运行中...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.setDaemon(<span class="literal">true</span>);   <span class="comment">//设置为守护线程（必须在开始之前，中途是不允许转换的）</span></span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在守护线程中产生的新线程也是守护的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;程序正常运行中...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        it.start();</span><br><span class="line">    &#125;);</span><br><span class="line">    t.setDaemon(<span class="literal">true</span>);   <span class="comment">//设置为守护线程（必须在开始之前，中途是不允许转换的）</span></span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="再谈集合类"><a href="#再谈集合类" class="headerlink" title="再谈集合类"></a>再谈集合类</h3><p>集合类中有一个东西是Java8新增的Spliterator接口，翻译过来就是：可拆分迭代器（Splitable Iterator）和Iterator一样，Spliterator也用于遍历数据源中的元素，但它是为了并行执行而设计的。Java 8已经为集合框架中包含的所有数据结构提供了一个默认的Spliterator实现。在集合跟接口Collection中提供了一个<code>spliterator()</code>方法用于获取可拆分迭代器。</p><p>其实我们之前在讲解集合类的根接口时，就发现有这样一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">true</span>); <span class="comment">//parallelStream就是利用了可拆分迭代器进行多线程操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并行流，其实就是一个多线程执行的流，它通过默认的ForkJoinPool实现（这里不讲解原理），它可以提高你的多线程任务的速度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">0</span>));</span><br><span class="line">    list</span><br><span class="line">            .parallelStream()    <span class="comment">//获得并行流</span></span><br><span class="line">            .forEach(i -&gt; System.out.println(Thread.currentThread().getName()+<span class="string">&quot; -&gt; &quot;</span>+i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，forEach操作的顺序，并不是我们实际List中的顺序，同时每次打印也是不同的线程在执行！我们可以通过调用<code>forEachOrdered()</code>方法来使用单线程维持原本的顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">0</span>));</span><br><span class="line">    list</span><br><span class="line">            .parallelStream()    <span class="comment">//获得并行流</span></span><br><span class="line">            .forEachOrdered(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们之前还发现，在Arrays数组工具类中，也包含大量的并行方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    Arrays.parallelSort(arr);   <span class="comment">//使用多线程进行并行排序，效率更高</span></span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多地使用并行方法，可以更加充分地发挥现代计算机多核心的优势，但是同时需要注意多线程产生的异步问题！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    Arrays.parallelSetAll(arr, i -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> arr[i];</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为多线程的加入，我们之前认识的集合类都废掉了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            list.add(i);   <span class="comment">//两个线程同时操作集合类进行插入操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1000</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    System.out.println(list.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，有些时候运气不好，得到的结果并不是2000个元素，而是：</p><p><img src="https://s2.loli.net/2022/10/04/m1nZfG4wPCOQx8V.png" alt="image-20221004212332535"></p><p>因为之前的集合类，并没有考虑到多线程运行的情况，如果两个线程同时执行，那么有可能两个线程同一时间都执行同一个方法，这种情况下就很容易出问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// 当数组容量更好还差一个满的时候，这个时候两个线程同时走到了这里，因为都判断为没满，所以说没有进行扩容，但是实际上两个线程都要插入一个元素进来</span></span><br><span class="line">    elementData[size++] = e;   <span class="comment">//当两个线程同时在这里插入元素，直接导致越界访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，在Java早期的时候，还有一些老的集合类，这些集合类都是线程安全的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Vector&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();   <span class="comment">//我们可以使用Vector代替List使用</span></span><br><span class="line">  <span class="comment">//Hashtable&lt;Integer, String&gt;   也可以使用Hashtable来代替Map</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1000</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(list.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这些集合类中的每一个方法都加了锁，所以说不会出现多线程问题，但是这些老的集合类现在已经不再使用了，我们会在JUC篇视频教程中介绍专用于并发编程的集合类。</p><p>通过对Java多线程的了解，我们就具备了利用多线程解决问题的思维！</p><h3 id="实战：生产者与消费者"><a href="#实战：生产者与消费者" class="headerlink" title="实战：生产者与消费者"></a>实战：生产者与消费者</h3><p>所谓的生产者消费者模型，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架有货物的时候，消费者可以从货架上拿走商品，生产者此时等待货架出现空位，进而补货，这样不断的循环。</p><p>通过多线程编程，来模拟一个餐厅的2个厨师和3个顾客，假设厨师炒出一个菜的时间为3秒，顾客吃掉菜品的时间为4秒。</p><hr><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p><strong>注意：</strong>本章节涉及到JVM相关底层原理，难度会有一些大。</p><p>反射就是把Java类中的各个成分映射成一个个的Java对象。即在运行状态中，对于任意一个类，都能够知道这个类所有的属性和方法，对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制。</p><p>简而言之，我们可以通过反射机制，获取到类的一些属性，包括类里面有哪些字段，有哪些方法，继承自哪个类，甚至还能获取到泛型！它的权限非常高，慎重使用！</p><h3 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h3><p>在学习Java的反射机制之前，我们需要先了解一下类的加载机制，一个类是如何被加载和使用的：</p><p><img src="https://s2.loli.net/2022/10/04/vZ4onhuJWcALHNP.png" alt="image-20221004213335479"></p><p>在Java程序启动时，JVM会将一部分类（class文件）先加载（并不是所有的类都会在一开始加载），通过ClassLoader将类加载，在加载过程中，会将类的信息提取出来（存放在元空间中，JDK1.8之前存放在永久代），同时也会生成一个Class对象存放在内存（堆内存），注意此Class对象只会存在一个，与加载的类唯一对应！</p><p>为了方便各位小伙伴理解，你们就直接理解为默认情况下（仅使用默认类加载器）每个类都有且只有一个唯一的Class对象存放在JVM中，我们无论通过什么方式访问，都是始终是那一个对象。Class对象中包含我们类的一些信息，包括类里面有哪些方法、哪些变量等等。</p><h3 id="Class类详解"><a href="#Class类详解" class="headerlink" title="Class类详解"></a>Class类详解</h3><p>通过前面，我们了解了类的加载，同时会提取一个类的信息生成Class对象存放在内存中，而反射机制其实就是利用这些存放的类信息，来获取类的信息和操作类。那么如何获取到每个类对应的Class对象呢，我们可以通过以下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;String&gt; clazz = String.class;   <span class="comment">//使用class关键字，通过类名获取</span></span><br><span class="line">    Class&lt;?&gt; clazz2 = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);   <span class="comment">//使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class&lt;?&gt;</span></span><br><span class="line">    Class&lt;?&gt; clazz3 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;cpdd&quot;</span>).getClass();  <span class="comment">//通过实例对象获取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意Class类也是一个泛型类，只有第一种方法，能够直接获取到对应类型的Class对象，而以下两种方法使用了<code>?</code>通配符作为返回值，但是实际上都和第一个返回的是同一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;String&gt; clazz = String.class;   <span class="comment">//使用class关键字，通过类名获取</span></span><br><span class="line">Class&lt;?&gt; clazz2 = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);   <span class="comment">//使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class&lt;?&gt;</span></span><br><span class="line">Class&lt;?&gt; clazz3 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;cpdd&quot;</span>).getClass();</span><br><span class="line"></span><br><span class="line">System.out.println(clazz == clazz2);</span><br><span class="line">System.out.println(clazz == clazz3);</span><br></pre></td></tr></table></figure><p>通过比较，验证了我们一开始的结论，在JVM中每个类始终只存在一个Class对象，无论通过什么方法获取，都是一样的。现在我们再来看看这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = <span class="type">int</span>.class;   <span class="comment">//基本数据类型有Class对象吗？</span></span><br><span class="line">    System.out.println(clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迷了，不是每个类才有Class对象吗，基本数据类型又不是类，这也行吗？实际上，基本数据类型也有对应的Class对象（反射操作可能需要用到），而且我们不仅可以通过class关键字获取，其实本质上是定义在对应的包装类中的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@code</span> Class&#125; instance representing the primitive type</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> int&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   JDK1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;Integer&gt;  TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(<span class="string">&quot;int&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return the Virtual Machine&#x27;s Class object for the named</span></span><br><span class="line"><span class="comment"> * primitive type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; getPrimitiveClass(String name);   <span class="comment">//C++实现，并非Java定义</span></span><br></pre></td></tr></table></figure><p>每个包装类中（包括Void），都有一个获取原始类型Class方法，注意，getPrimitiveClass获取的是原始类型，并不是包装类型，只是可以使用包装类来表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = <span class="type">int</span>.class;</span><br><span class="line">    System.out.println(Integer.TYPE == <span class="type">int</span>.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对比，我们发现实际上包装类型都有一个TYPE，其实也就是基本类型的Class，那么包装类的Class和基本类的Class一样吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(Integer.TYPE == Integer.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，包装类型的Class对象并不是基本类型Class对象。数组类型也是一种类型，只是编程不可见，因此我们可以直接获取数组的Class对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Class&lt;String[]&gt; clazz = String[].class;</span><br><span class="line">    System.out.println(clazz.getName());  <span class="comment">//获取类名称（得到的是包名+类名的完整名称）</span></span><br><span class="line">    System.out.println(clazz.getSimpleName());</span><br><span class="line">    System.out.println(clazz.getTypeName());</span><br><span class="line">    System.out.println(clazz.getClassLoader());   <span class="comment">//获取它的类加载器</span></span><br><span class="line">    System.out.println(clazz.cast(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;10&quot;</span>)));   <span class="comment">//强制类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下节课，我们将开始对Class对象的使用进行讲解。</p><h3 id="Class对象与多态"><a href="#Class对象与多态" class="headerlink" title="Class对象与多态"></a>Class对象与多态</h3><p>正常情况下，我们使用instanceof进行类型比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    System.out.println(str <span class="keyword">instanceof</span> String);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以判断一个对象是否为此接口或是类的实现或是子类，而现在我们有了更多的方式去判断类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    System.out.println(str.getClass() == String.class);   <span class="comment">//直接判断是否为这个类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要判断是否为子类或是接口/抽象类的实现，我们可以使用<code>asSubClass()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    i.getClass().asSubclass(Number.class);   <span class="comment">//当Integer不是Number的子类时，会产生异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>getSuperclass()</code>方法，我们可以获取到父类的Class对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    System.out.println(i.getClass().getSuperclass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过<code>getGenericSuperclass()</code>获取父类的原始类型的Type：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> i.getClass().getGenericSuperclass();</span><br><span class="line">    System.out.println(type);</span><br><span class="line">    System.out.println(type <span class="keyword">instanceof</span> Class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现Type实际上是Class类的父接口，但是获取到的Type的实现并不一定是Class。</p><p>同理，我们也可以像上面这样获取父接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; anInterface : i.getClass().getInterfaces()) &#123;</span><br><span class="line">        System.out.println(anInterface.getName());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (Type genericInterface : i.getClass().getGenericInterfaces()) &#123;</span><br><span class="line">        System.out.println(genericInterface.getTypeName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉反射功能很强大？几乎类的所有信息都可以通过反射获得。</p><h3 id="创建类对象"><a href="#创建类对象" class="headerlink" title="创建类对象"></a>创建类对象</h3><p>既然我们拿到了类的定义，那么是否可以通过Class对象来创建对象、调用方法、修改变量呢？当然是可以的，那我们首先来探讨一下如何创建一个类的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    Class&lt;Student&gt; clazz = Student.class;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">    student.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;萨日朗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用<code>newInstance()</code>方法来创建对应类型的实例，返回泛型T，注意它会抛出InstantiationException和IllegalAccessException异常，那么什么情况下会出现异常呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    Class&lt;Student&gt; clazz = Student.class;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">    student.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String text)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;萨日朗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当类默认的构造方法被带参构造覆盖时，会出现InstantiationException异常，因为<code>newInstance()</code>只适用于默认无参构造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    Class&lt;Student&gt; clazz = Student.class;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">    student.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;萨日朗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当默认无参构造的权限不是<code>public</code>时，会出现IllegalAccessException异常，表示我们无权去调用默认构造方法。在JDK9之后，不再推荐使用<code>newInstance()</code>方法了，而是使用我们接下来要介绍到的，通过获取构造器，来实例化对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    Class&lt;Student&gt; clazz = Student.class;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> clazz.getConstructor(String.class).newInstance(<span class="string">&quot;what&#x27;s up&quot;</span>);</span><br><span class="line">    student.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String str)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;萨日朗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过获取类的构造方法（构造器）来创建对象实例，会更加合理，我们可以使用<code>getConstructor()</code>方法来获取类的构造方法，同时我们需要向其中填入参数，也就是构造方法需要的类型，当然我们这里只演示了。那么，当访问权限不是public的时候呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    Class&lt;Student&gt; clazz = Student.class;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> clazz.getConstructor(String.class).newInstance(<span class="string">&quot;what&#x27;s up&quot;</span>);</span><br><span class="line">    student.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">(String str)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;萨日朗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，当访问权限不足时，会无法找到此构造方法，那么如何找到非public的构造方法呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Student&gt; clazz = Student.class;</span><br><span class="line">Constructor&lt;Student&gt; constructor = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);   <span class="comment">//修改访问权限</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;what&#x27;s up&quot;</span>);</span><br><span class="line">student.test();</span><br></pre></td></tr></table></figure><p>使用<code>getDeclaredConstructor()</code>方法可以找到类中的非public构造方法，但是在使用之前，我们需要先修改访问权限，在修改访问权限之后，就可以使用非public方法了（这意味着，反射可以无视权限修饰符访问类的内容）</p><h3 id="调用类方法"><a href="#调用类方法" class="headerlink" title="调用类方法"></a>调用类方法</h3><p>我们可以通过反射来调用类的方法（本质上还是类的实例进行调用）只是利用反射机制实现了方法的调用，我们在包下创建一个新的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;萨日朗&quot;</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次我们通过<code>forName(String)</code>来找到这个类并创建一个新的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ReflectiveOperationException &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.test.Student&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();   <span class="comment">//创建出学生对象</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;test&quot;</span>, String.class);   <span class="comment">//通过方法名和形参类型获取类中的方法</span></span><br><span class="line">    </span><br><span class="line">    method.invoke(instance, <span class="string">&quot;what&#x27;s up&quot;</span>);   <span class="comment">//通过Method对象的invoke方法来调用方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用<code>getMethod()</code>方法，我们可以获取到类中所有声明为public的方法，得到一个Method对象，我们可以通过Method对象的<code>invoke()</code>方法（返回值就是方法的返回值，因为这里是void，返回值为null）来调用已经获取到的方法，注意传参。</p><p>我们发现，利用反射之后，在一个对象从构造到方法调用，没有任何一处需要引用到对象的实际类型，我们也没有导入Student类，整个过程都是反射在代替进行操作，使得整个过程被模糊了，过多的使用反射，会极大地降低后期维护性。</p><p>同构造方法一样，当出现非public方法时，我们可以通过反射来无视权限修饰符，获取非public方法并调用，现在我们将<code>test()</code>方法的权限修饰符改为private：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ReflectiveOperationException &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.test.Student&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();   <span class="comment">//创建出学生对象</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;test&quot;</span>, String.class);   <span class="comment">//通过方法名和形参类型获取类中的方法</span></span><br><span class="line">    method.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    method.invoke(instance, <span class="string">&quot;what&#x27;s up&quot;</span>);   <span class="comment">//通过Method对象的invoke方法来调用方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Method和Constructor都和Class一样，他们存储了方法的信息，包括方法的形式参数列表，返回值，方法的名称等内容，我们可以直接通过Method对象来获取这些信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ReflectiveOperationException &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.test.Student&quot;</span>);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;test&quot;</span>, String.class);   <span class="comment">//通过方法名和形参类型获取类中的方法</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(method.getName());   <span class="comment">//获取方法名称</span></span><br><span class="line">    System.out.println(method.getReturnType());   <span class="comment">//获取返回值类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当方法的参数为可变参数时，我们该如何获取方法呢？实际上，我们在之前就已经提到过，可变参数实际上就是一个数组，因此我们可以直接使用数组的class对象表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;test&quot;</span>, String[].class);</span><br></pre></td></tr></table></figure><p>反射非常强大，尤其是我们提到的越权访问，但是请一定谨慎使用，别人将某个方法设置为private一定有他的理由，如果实在是需要使用别人定义为private的方法，就必须确保这样做是安全的，在没有了解别人代码的整个过程就强行越权访问，可能会出现无法预知的错误。</p><h3 id="修改类的属性"><a href="#修改类的属性" class="headerlink" title="修改类的属性"></a>修改类的属性</h3><p>我们还可以通过反射访问一个类中定义的成员字段也可以修改一个类的对象中的成员字段值，通过<code>getField()</code>方法来获取一个类定义的指定字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ReflectiveOperationException &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.test.Student&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;i&quot;</span>);   <span class="comment">//获取类的成员字段i</span></span><br><span class="line">    field.set(instance, <span class="number">100</span>);   <span class="comment">//将类实例instance的成员字段i设置为100</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    method.invoke(instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在得到Field之后，我们就可以直接通过<code>set()</code>方法为某个对象，设定此属性的值，比如上面，我们就为instance对象设定值为100，当访问private字段时，同样可以按照上面的操作进行越权访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ReflectiveOperationException &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.test.Student&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;i&quot;</span>);   <span class="comment">//获取类的成员字段i</span></span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    field.set(instance, <span class="number">100</span>);   <span class="comment">//将类实例instance的成员字段i设置为100</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    method.invoke(instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经知道，反射几乎可以把一个类的老底都给扒出来，任何属性，任何内容，都可以被反射修改，无论权限修饰符是什么，那么，如果我的字段被标记为final呢？现在在字段<code>i</code>前面添加<code>final</code>关键字，我们再来看看效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这时，当字段为final时，就修改失败了！当然，通过反射可以直接将final修饰符直接去除，去除后，就可以随意修改内容了，我们来尝试修改Integer的value值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ReflectiveOperationException &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Integer.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">modifiersField</span> <span class="operator">=</span> Field.class.getDeclaredField(<span class="string">&quot;modifiers&quot;</span>);  <span class="comment">//这里要获取Field类的modifiers字段进行修改</span></span><br><span class="line">    modifiersField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    modifiersField.setInt(field,field.getModifiers()&amp;~Modifier.FINAL);  <span class="comment">//去除final标记</span></span><br><span class="line"></span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    field.set(i, <span class="number">100</span>);   <span class="comment">//强行设置值</span></span><br><span class="line"></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现，反射非常暴力，就连被定义为final字段的值都能强行修改，几乎能够无视一切阻拦。我们来试试看修改一些其他的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ReflectiveOperationException &#123;</span><br><span class="line">    List&lt;String&gt; i = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> ArrayList.class.getDeclaredField(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    field.set(i, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    i.add(<span class="string">&quot;测试&quot;</span>);   <span class="comment">//只添加一个元素</span></span><br><span class="line">    System.out.println(i.size());  <span class="comment">//大小直接变成11</span></span><br><span class="line">    i.remove(<span class="number">10</span>);   <span class="comment">//瞎移除都不带报错的，淦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，整个ArrayList体系由于我们的反射操作，导致被破坏，因此它已经无法正常工作了！</p><p>再次强调，在进行反射操作时，必须注意是否安全，虽然拥有了创世主的能力，但是我们不能滥用，我们只能把它当做一个不得已才去使用的工具！</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>我们接着来介绍一下类加载器，实际上类加载器就是用于加载一个类的，但是类加载器并不是只有一个。</p><p><strong>思考：</strong>既然说Class对象和加载的类唯一对应，那如果我们手动创建一个与JDK包名一样，同时类名也保持一致，JVM会加载这个类吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;    <span class="comment">//JDK提供的String类也是</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我姓🐴，我叫🐴nb&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，会出现以下报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br></pre></td></tr></table></figure><p>但是我们明明在自己写的String类中定义了main方法啊，为什么会找不到此方法呢？实际上这是ClassLoader的<code>双亲委派机制</code>在保护Java程序的正常运行：</p><p><img src="https://s2.loli.net/2022/10/04/5p6jdXDA8VtCEfN.png" alt="img"></p><p>实际上类最开始是由BootstarpClassLoader进行加载，BootstarpClassLoader用于加载JDK提供的类，而我们自己编写的类实际上是AppClassLoader加载的，只有BootstarpClassLoader都没有加载的类，才会让AppClassLoader来加载，因此我们自己编写的同名包同名类不会被加载，而实际要去启动的是真正的String类，也就自然找不到<code>main</code>方法了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Main.class.getClassLoader());   <span class="comment">//查看当前类的类加载器</span></span><br><span class="line">        System.out.println(Main.class.getClassLoader().getParent());  <span class="comment">//父加载器</span></span><br><span class="line">        System.out.println(Main.class.getClassLoader().getParent().getParent());  <span class="comment">//爷爷加载器</span></span><br><span class="line">        System.out.println(String.class.getClassLoader());   <span class="comment">//String类的加载器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于BootstarpClassLoader是C++编写的，我们在Java中是获取不到的。</p><p>既然通过ClassLoader就可以加载类，那么我们可以自己手动将class文件加载到JVM中吗？先写好我们定义的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        System.out.println(text+<span class="string">&quot; &gt; 我是测试方法！&quot;</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过javac命令，手动编译一个.class文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nagocoler<span class="meta">@NagodeMacBook</span>-Pro HelloWorld % javac src/main/java/com/test/Test.java</span><br></pre></td></tr></table></figure><p>编译后，得到一个class文件，我们把它放到根目录下，然后编写一个我们自己的ClassLoader，因为普通的ClassLoader无法加载二进制文件，因此我们编写一个自定义的来让它支持：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个自己的ClassLoader</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b)&#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);   <span class="comment">//调用protected方法，支持载入外部class文件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">MyClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Test.class&quot;</span>);</span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[stream.available()];</span><br><span class="line">    stream.read(bytes);</span><br><span class="line">    Class&lt;?&gt; clazz = classLoader.defineClass(<span class="string">&quot;com.test.Test&quot;</span>, bytes);   <span class="comment">//类名必须和我们定义的保持一致</span></span><br><span class="line">    System.out.println(clazz.getName());   <span class="comment">//成功加载外部class文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们就将此class文件读取并解析为Class了，现在我们就可以对此类进行操作了（注意，我们无法在代码中直接使用此类型，因为它是我们直接加载的），我们来试试看创建一个此类的对象并调用其方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;test&quot;</span>, String.class);   <span class="comment">//获取我们定义的test(String str)方法</span></span><br><span class="line">    method.invoke(obj, <span class="string">&quot;哥们这瓜多少钱一斤？&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来试试看修改成员字段之后，再来调用此方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;text&quot;</span>);   <span class="comment">//获取成员变量 String text;</span></span><br><span class="line">    field.set(obj, <span class="string">&quot;华强&quot;</span>);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;test&quot;</span>, String.class);   <span class="comment">//获取我们定义的test(String str)方法</span></span><br><span class="line">    method.invoke(obj, <span class="string">&quot;哥们这瓜多少钱一斤？&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，我们就可以实现外部加载甚至是网络加载一个类，只需要把类文件传递即可，这样就无需再将代码写在本地，而是动态进行传递，不仅可以一定程度上防止源代码被反编译（只是一定程度上，想破解你代码有的是方法），而且在更多情况下，我们还可以对byte[]进行加密，保证在传输过程中的安全性。</p><hr><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><strong>注意：</strong>注解跟我们之前讲解的注释完全不是一个概念，不要搞混了。</p><p>其实我们在之前就接触到注解了，比如<code>@Override</code>表示重写父类方法（当然不加效果也是一样的，此注解在编译时会被自动丢弃）注解本质上也是一个类，只不过它的用法比较特殊。</p><p>注解可以被标注在任意地方，包括方法上、类名上、参数上、成员属性上、注解定义上等，就像注释一样，它相当于我们对某样东西的一个标记。而与注释不同的是，注解可以通过反射在运行时获取，注解也可以选择是否保留到运行时。</p><h3 id="预设注解"><a href="#预设注解" class="headerlink" title="预设注解"></a>预设注解</h3><p>JDK预设了以下注解，作用于代码：</p><ul><li><a href="">@Override </a>- 检查（仅仅是检查，不保留到运行时）该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 </li><li><a href="">@Deprecated </a>- 标记过时方法。如果使用该方法，会报编译警告。 </li><li><a href="">@SuppressWarnings </a>- 指示编译器去忽略注解中声明的警告（仅仅编译器阶段，不保留到运行时） </li><li><a href="">@FunctionalInterface </a>- Java 8 开始支持，标识一个匿名函数或函数式接口。 </li><li><a href="">@SafeVarargs </a>- Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 </li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解是作用于注解上的注解，用于我们编写自定义的注解：</p><ul><li><a href="">@Retention </a>- 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。 </li><li><a href="">@Documented </a>- 标记这些注解是否包含在用户文档中。 </li><li><a href="">@Target </a>- 标记这个注解应该是哪种 Java 成员。 </li><li><a href="">@Inherited </a>- 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类) </li><li><a href="">@Repeatable </a>- Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 </li></ul><p>看了这么多预设的注解，你们肯定眼花缭乱了，那我们来看看<code>@Override</code>是如何定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解由<code>@Target</code>限定为只能作用于方法上，ElementType是一个枚举类型，用于表示此枚举的作用域，一个注解可以有很多个作用域。<code>@Retention</code>表示此注解的保留策略，包括三种策略，在上述中有写到，而这里定义为只在代码中。一般情况下，自定义的注解需要定义1个<code>@Retention</code>和1-n个<code>@Target</code>。</p><p>既然了解了元注解的使用和注解的定义方式，我们就来尝试定义一个自己的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们定义一个Test注解，并将其保留到运行时，同时此注解可以作用于方法或是类上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个最简单的注解就被我们创建了。</p><h3 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h3><p>我们还可以在注解中定义一些属性，注解的属性也叫做成员变量，注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认只有一个属性时，我们可以将其名字设定为value，否则，我们需要在使用时手动指定注解的属性名称，使用value则无需填入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">    String <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="meta">@Test(test = &quot;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以使用default关键字来为这些属性指定默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;都看到这里了，给个三连吧！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当属性存在默认值时，使用注解的时候可以不用传入属性值。当属性为数组时呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当属性为数组，我们在使用注解传参时，如果数组里面只有一个内容，我们可以直接传入一个值，而不是创建一个数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test(&quot;关注点了吗&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="meta">@Test(&#123;&quot;value1&quot;, &quot;value2&quot;&#125;)</span>   <span class="comment">//多个值时就使用花括号括起来</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射获取注解"><a href="#反射获取注解" class="headerlink" title="反射获取注解"></a>反射获取注解</h3><p>既然我们的注解可以保留到运行时，那么我们来看看，如何获取我们编写的注解，我们需要用到反射机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Class&lt;Student&gt; clazz = Student.class;</span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : clazz.getAnnotations()) &#123;</span><br><span class="line">        System.out.println(annotation.annotationType());   <span class="comment">//获取类型</span></span><br><span class="line">        System.out.println(annotation <span class="keyword">instanceof</span> Test);   <span class="comment">//直接判断是否为Test</span></span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> (Test) annotation;</span><br><span class="line">        System.out.println(test.value());   <span class="comment">//获取我们在注解中写入的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射机制，我们可以快速获取到我们标记的注解，同时还能获取到注解中填入的值，那么我们来看看，方法上的标记是不是也可以通过这种方式获取注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">    Class&lt;Student&gt; clazz = Student.class;</span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : clazz.getMethod(<span class="string">&quot;test&quot;</span>).getAnnotations()) &#123;</span><br><span class="line">        System.out.println(annotation.annotationType());   <span class="comment">//获取类型</span></span><br><span class="line">        System.out.println(annotation <span class="keyword">instanceof</span> Test);   <span class="comment">//直接判断是否为Test</span></span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> (Test) annotation;</span><br><span class="line">        System.out.println(test.value());   <span class="comment">//获取我们在注解中写入的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是方法、类、还是字段，都可以使用<code>getAnnotations()</code>方法（还有几个同名的）来快速获取我们标记的注解。</p><p>所以说呢，这玩意学来有啥用？丝毫get不到这玩意的用处。其实不是，现阶段作为初学者，还体会不到注解带来的快乐，在接触到Spring和SpringBoot等大型框架后，相信各位就能感受到注解带来的魅力了。</p><hr><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>Java的学习对你来说可能是枯燥的，可能是漫长的，也有可能是有趣的，无论如何，你终于是完成了全部内容的学习，可喜可贺。</p><p>实际上很多人一开始跟着你们一起在进行学习，但是他们因为各种原因，最后还是没有走完这条路。坚持不一定会成功，但坚持到别人坚持不下去，那么你至少已经成功了一半了，坚持到最后的人运气往往都不会太差。</p><p>希望各位小伙伴能够在之后的学习中砥砺前行！</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="java" scheme="https://www.hoveco.top/categories/java/"/>
    
    
    <category term="JavaSE" scheme="https://www.hoveco.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE-学习笔记-GUI程序开发（八）</title>
    <link href="https://www.hoveco.top/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89GUI%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    <id>https://www.hoveco.top/2023/10/12/JavaSE%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89GUI%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</id>
    <published>2023-10-12T00:30:00.000Z</published>
    <updated>2023-10-12T14:49:22.837Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/10/26/Mu6qwoA9fc7THbQ.png" alt="image-20221026154454258"></p><h1 id="GUI程序开发"><a href="#GUI程序开发" class="headerlink" title="GUI程序开发"></a>GUI程序开发</h1><p>注意：开始学习之前请确保你完成了《Java SE》篇视频教程。</p><p>前面我们已经完成了JavaSE部分的全部内容学习，只不过我们在初学阶段一直都是开发的控制台程序，也就是最原始的命令窗口形式的程序，而Java也可以开发桌面图形化程序，所以我们接着来学习一下Java的图形化界面的开发。</p><h2 id="AWT组件介绍"><a href="#AWT组件介绍" class="headerlink" title="AWT组件介绍"></a>AWT组件介绍</h2><p>在Java正式推出的时候，它还包含一个用于基本GUI程序设计的类库，名字叫 Abstract Window Toolkit，简称AWT，抽象窗口工具包，我们可以直接使用Java为我们提供的工具包来进行桌面应用程序的开发。只不过这套工具包依附于操作系统提供的UI，具体样式会根据不同操作系统提供的界面元素进行展示。</p><p>实际上我们现代操作系统都是图形化界面，应用程序都是以一个窗口的形式展示出来的，我们可以直接使用鼠标点击窗口内的元素来使用应用程序，相比传统的命令行形式，可方便太多了，比如在Windows和MacOS这两种操作系统下：</p><p><img src="https://s2.loli.net/2022/10/26/fMQDFCmyqIvJeTl.png" alt="image-20221026164200924"></p><p>可以看到，不同的操作系统的窗口样式稍微有一些不一样，但是大致的使用方式是差不多的，我们接着来看一下如何使用Java编写简单的桌面图形化程序。</p><h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><p>既然我们要编写一个桌面程序，那么肯定是需要窗口来展示我们程序的内容的，所以说，我们可以使用AWT为我们提供的组件来创建窗口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Frame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Frame</span>();   <span class="comment">//Frame是窗体，我们只需要创建这样一个对象就可以了，这样就会直接创建一个新的窗口</span></span><br><span class="line">    frame.setSize(<span class="number">500</span>, <span class="number">300</span>);   <span class="comment">//可以使用setSize方法设定窗体大小</span></span><br><span class="line">    frame.setVisible(<span class="literal">true</span>);    <span class="comment">//默认情况下窗体是不可见的，我们如果要展示出来，还需要设置窗体可见性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，桌面的左上角已经展示出我们的窗口了：</p><p><img src="https://s2.loli.net/2022/10/26/ZSQs1NhWlJeyMmi.png" alt="image-20221026165600076"></p><p>在不同的操作系统下，窗口的样式会不同。</p><p>我们可以通过Frame的各种方法来设置窗口的各项属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Frame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Frame</span>();</span><br><span class="line">    frame.setTitle(<span class="string">&quot;我是标题&quot;</span>);   <span class="comment">//设置窗口标题</span></span><br><span class="line">    frame.setSize(<span class="number">500</span>, <span class="number">300</span>);    <span class="comment">//设置窗口大小</span></span><br><span class="line">    frame.setBackground(Color.BLACK);   <span class="comment">//设置窗口背景颜色</span></span><br><span class="line">  frame.setResizable(<span class="literal">false</span>);    <span class="comment">//设置窗口大小是否固定</span></span><br><span class="line">  frame.setAlwaysOnTop(<span class="literal">true</span>);    <span class="comment">//设置窗口是否始终展示在最前面</span></span><br><span class="line">    frame.setVisible(<span class="literal">true</span>);    <span class="comment">//注意，只有将可见性变为true时才会展示出这个窗口，否则窗口是隐藏的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上当我们创建一个窗口之后，会在其他线程中进行处理，包括窗口的绘制、窗口事件的监听等，所以说我们的主线程不会卡住。</p><p>实际上我们的程序打开都是默认居中显示的，所以说我们可以调整一下窗口的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame.setLocation(<span class="number">100</span>, <span class="number">200</span>);   <span class="comment">//setLocation可以调整窗口位置</span></span><br></pre></td></tr></table></figure><p>注意，这里的窗口位置以及窗口大小都是以像素为单位。整个屏幕有多少个像素，是根据各位小伙伴电脑的显示器屏幕分辨率来决定的，比如我们的电脑显示器屏幕分辨率为 1920 x 1080，那么我们显示器就可以显示长为1920个像素，宽1080个像素的矩形，只要是在这个范围内的窗口，都可以显示到屏幕上：</p><p><img src="https://s2.loli.net/2022/10/26/CknumyFjpz659Ya.png" alt="image-20221026170449235"></p><p>那么问题就来了，如果现在我们希望将这个窗口居中，就需要手动调整位置，但我们是要去适配各种分辨率的显示器才可以，不然到其他分辨率下，就无法居中了，我们可以动态获取分辨率来进行位置计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Frame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Frame</span>(<span class="string">&quot;我是标题&quot;</span>);</span><br><span class="line">    frame.setSize(<span class="number">500</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Dimension</span> <span class="variable">screenSize</span> <span class="operator">=</span> Toolkit.getDefaultToolkit().getScreenSize();  <span class="comment">//获取到屏幕尺寸</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) ((screenSize.getWidth() - frame.getWidth()) / <span class="number">2</span>);   <span class="comment">//居中位置就是：屏幕尺寸/2 - 窗口尺寸/2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) ((screenSize.getHeight() - frame.getHeight()) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    frame.setLocation(x, y);   <span class="comment">//位置设置好了之后再展示出来</span></span><br><span class="line">    frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们的窗口打开之后默认就是居中放置的了，是不是感觉用Java开发图形界面好像也不是那么难？</p><p>得益于Java已经为我们封装好了各种方法，所以说要实现什么功能直接调用对应的方法即可，比如我们想要个性化光标，我们可以使用<code>setCursor</code>方法来实现，JDK已经为我们提供了一些预设的光标样式：</p><p><img src="https://s2.loli.net/2022/10/27/drC1nx2NSK9Ewaf.png" alt="image-20221027151713661"></p><p>设定光标样式后，当我们的鼠标移动到这个窗口内部时，就会变成我们设定好的光标样式了。</p><p>有关其他方法，这里暂时不进行介绍。</p><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>我们可以为窗口添加一系列的监听器，监听器会监听窗口中发生的一些事件，比如我们点击关闭窗口、移动鼠标、鼠标点击等，当发生对应的事件时，就会通知到对应的监听器进行处理，从而我们能够在发生对应事件时进行对应处理。</p><p><img src="https://s2.loli.net/2022/10/27/DAz1hnUekV6RNqd.png" alt="image-20221027161611050"></p><p>比如我们现在希望点击关闭按钮关闭当前的窗口，但是我们发现默认情况下实际上是关不掉的，因为我们并没有对关闭事件进行处理，默认情况下对于这种点击时没有设定任何动作的，万一我们点了之后并不是要关闭窗口呢。要实现关闭窗口，我们可以使用<code>addXXXListener</code>来添加对应的事件监听器，比如窗口相关的操作那么就是WindowListener：</p><p><img src="https://s2.loli.net/2022/10/27/IiwomHF7YWe8Vuh.png" alt="image-20221027155830335"></p><p>这里我们可以给一个接口实现，或是使用对应的适配器（适配器模式是设计模式中的一种写法，因为接口中要实现的方法太多，但是实际上我们并不需要实现那么多，只需要实现对应的即可，所以说就可以使用适配器）我们只需要重写对应的方法，当发生对应事件时就会自动调用我们已经实现好的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">frame.addWindowListener(<span class="keyword">new</span> <span class="title class_">WindowAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosing</span><span class="params">(WindowEvent e)</span> &#123;   <span class="comment">//windowClosing方法对应的就是窗口关闭事件</span></span><br><span class="line">        frame.dispose();    <span class="comment">//当我们点击X号关闭窗口时，就会自动执行此方法了</span></span><br><span class="line">        <span class="comment">//使用dispose方法来关闭当前窗口</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosed</span><span class="params">(WindowEvent e)</span> &#123;   <span class="comment">//对应窗口已关闭事件</span></span><br><span class="line">        System.out.println(<span class="string">&quot;窗口已关闭！&quot;</span>);   <span class="comment">//当窗口成功关闭后，会执行这里重写的内容</span></span><br><span class="line">      System.exit(<span class="number">0</span>);    <span class="comment">//窗口关闭后退出当前Java程序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们可以来看看效果，现在我们点击X号关闭窗口就可以成功执行了，并且窗口关闭后我们的Java程序就结束了。当然，监听器可以添加多个，并不是只能有一个。</p><p>这里总结一下窗口常用的事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WindowListener</span> <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowOpened</span><span class="params">(WindowEvent e)</span>;   <span class="comment">//当窗口的可见性首次变成true时会被调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosing</span><span class="params">(WindowEvent e)</span>;   <span class="comment">//当以后企图关闭窗口（也就是点击X号）时被调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosed</span><span class="params">(WindowEvent e)</span>;   <span class="comment">//窗口被我们成功关闭之后被调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowIconified</span><span class="params">(WindowEvent e)</span>;    <span class="comment">//窗口最小化时被调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowDeiconified</span><span class="params">(WindowEvent e)</span>;   <span class="comment">//窗口从最小化状态变成普通状态时调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowActivated</span><span class="params">(WindowEvent e)</span>;    <span class="comment">//当窗口变成活跃状态时被调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowDeactivated</span><span class="params">(WindowEvent e)</span>;   <span class="comment">//当窗口变成不活跃时被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了监听窗口相关的动作之外，我们也可以监听鼠标、键盘等操作的事件，比如键盘事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frame.addKeyListener(<span class="keyword">new</span> <span class="title class_">KeyAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyTyped</span><span class="params">(KeyEvent e)</span> &#123;    <span class="comment">//监听键盘输入事件，当我们在窗口中敲击键盘输入时会触发</span></span><br><span class="line">        System.out.print(e.getKeyChar());   <span class="comment">//可以通过KeyEvent对象来获取当前事件输入的对应字符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>键盘事件甚至可以细致到键盘按键的几种状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">KeyListener</span> <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyTyped</span><span class="params">(KeyEvent e)</span>;   <span class="comment">//当一个按键按下之后触发（感觉跟下面这个没啥区别）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyPressed</span><span class="params">(KeyEvent e)</span>;   <span class="comment">//当一个按键按下后触发（按下之后如果不松开会连续触发此事件）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyReleased</span><span class="params">(KeyEvent e)</span>;   <span class="comment">//当一个按键按下然后松开后触发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以监听鼠标相关的事件，比如当鼠标点击我们界面上某一个位置时，我们就可以获取一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frame.addMouseListener(<span class="keyword">new</span> <span class="title class_">MouseAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseClicked</span><span class="params">(MouseEvent e)</span> &#123;   <span class="comment">//mouseClicked是监听鼠标点击事件（必须要用真的鼠标点击，不知道为啥，笔记本的触摸板不行，可能是MacOS的BUG吧）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;鼠标点击：&quot;</span>+e.getX()+<span class="string">&quot;,&quot;</span>+e.getY());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样，当我们点击窗口中的某个位置时，就可以获取对应的坐标并打印出来：</p><p><img src="https://s2.loli.net/2022/10/27/VQm7FjSNidLhI1r.png" alt="image-20221027164500070"></p><p>注意这里的坐标并不是按照我们在数学中学习的平面直角坐标系来的，它的X轴是从左往右，但是Y轴是从上往下，原点也不是整个屏幕开始，而是我们的窗口左上角。所以说当我们点击右下角时，就会得到一个接近于窗口大小的坐标了。</p><p>我们也可以获取鼠标是使用哪个键点击的，我们的鼠标一般情况下有三个按键：</p><ul><li>BUTTON1   -   鼠标左键，也是我们用的最多的键</li><li>BUTTON2   -   鼠标中键，一般是鼠标滚轮，也是是可以点击的（不会有人以为鼠标滚轮只能滚不能按吧）</li><li>BUTTON3   -   鼠标右键，右键一般就是辅助点按，展开各种选项等</li></ul><p>如果是游戏鼠标，也许能监听到一些其他的按键，这里我们就不测试了，我们来尝试监听一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frame.addMouseListener(<span class="keyword">new</span> <span class="title class_">MouseAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseClicked</span><span class="params">(MouseEvent e)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鼠标点击：&quot;</span>+e.getButton());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>鼠标滚动事件也可以进行监听：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frame.addMouseWheelListener(<span class="keyword">new</span> <span class="title class_">MouseAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseWheelMoved</span><span class="params">(MouseWheelEvent e)</span> &#123;</span><br><span class="line">        System.out.println(e.getScrollAmount());    <span class="comment">//获取滚动数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>MacOS下的鼠标滚动是平滑滚动，会触发很多次，不像Windows下是一格一格的僵硬滚动。</p><p>通过使用这些监听器，我们就可以更好的控制我们的GUI程序了。</p><h3 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h3><p>前面我们介绍了监听器，我们接着来看看常用的一些组件，那么什么是组件呢？</p><p>组件实际上是AWT为我们预设好的一些可以直接使用的界面元素，比如按钮、文本框、标签等等，我们可以使用这些已经帮我们写好的组件来快速拼凑出一个好看且功能强大的程序：</p><p><img src="https://s2.loli.net/2022/10/27/D6hslN2pHybmVdF.png" alt="image-20221027170224462"></p><p>在开始学习组件之前，我们先将布局设定为<code>null</code>（因为默认情况下会采用BorderLayout作为布局）有关布局我们会在下一部分中进行介绍，这节课我们先介绍没有布局的情况下如何使用这些组件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame.setLayout(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>首先我们来介绍一下最简单的组件，标签组件相当于一个普通的文本内容，我们可以将自己的标签添加到窗口中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Label</span> <span class="variable">label</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;我是标签&quot;</span>);   <span class="comment">//添加标签只需要创建一个Label对象即可</span></span><br><span class="line">label.setLocation(<span class="number">20</span>, <span class="number">50</span>);   <span class="comment">//注意，必须设定标签的位置和大小，否则无法展示出来</span></span><br><span class="line">label.setSize(<span class="number">100</span>, <span class="number">20</span>);</span><br><span class="line">frame.add(label);    <span class="comment">//使用add方法添加组件到窗口中</span></span><br></pre></td></tr></table></figure><p>注意，组件的位置是以整个窗口的左上角为原点开始的（整个窗口指的是包括标题栏在内）所以说我们如果想要设置组件的位置，我们还得注意加上标题栏的高度，否则会被标题栏遮挡：</p><p><img src="https://s2.loli.net/2022/10/27/VjCdNbAUIi5R61Z.png" alt="image-20221027175842110"></p><p>我们可以自由修改文本的字体和大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接构造并传入一个Font对象即可</span></span><br><span class="line">label.setFont(<span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;SimSong&quot;</span>, Font.BOLD, <span class="number">15</span>));   <span class="comment">//Font构造方法需要字体名称、字体样式（加粗、斜体）、字体大小</span></span><br></pre></td></tr></table></figure><p>注意必须是操作系统已经安装的字体才支持展示，如果各位小伙伴不知道操作系统有哪些字体，可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GraphicsEnvironment.getLocalGraphicsEnvironment().getAllFonts()</span><br></pre></td></tr></table></figure><p>来获取所有的系统字体：</p><p><img src="https://s2.loli.net/2022/10/27/Fsj8PqHryUYdgeC.png" alt="image-20221027181909908"></p><p>这里我们直接使用前面的<code>family</code>即可，比如我们要使用宋体，那么就输入其名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label.setFont(<span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;Songti SC&quot;</span>, Font.BOLD, <span class="number">15</span>));</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/27/zy4L2T67rGQe3HI.png" alt="image-20221027182010485"></p><p>可以看到字体已经成功修改了，当然，为了方便，如果我们的窗口中有很多的标签都想统一使用某一个字体，我们可以直接对窗口设定字体，那么只要是添加到窗口中的组件都会默认使用这个字体，除非单独指定组件字体。</p><p>要修改字体的颜色也很简单，我们可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">label.setBackground(Color.BLACK);    <span class="comment">//setBackground依然是背景颜色，注意背景填充就是我们之前设定的大小</span></span><br><span class="line">label.setForeground(Color.WHITE);    <span class="comment">//setForeground是设定字体颜色</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/27/R5cDrYxoKtpCJk6.png" alt="image-20221027183745934"></p><p>我们接着来认识一下下一个组件，这个组件的名字叫做按钮，实际上按钮也是我们经常会使用的一个组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;点击充值&quot;</span>);   <span class="comment">//Button是按钮组件</span></span><br><span class="line">button.setBounds(<span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">frame.add(button);</span><br></pre></td></tr></table></figure><p>这样就可以添加一个按钮到我们的窗口中了：</p><p><img src="https://s2.loli.net/2022/10/27/gArLdNTI1ClWh5K.png" alt="image-20221027182903783"></p><p>只不过，既然是按钮，那么肯定要添加一些点击动作才可以，比如点击按钮之后打印充值成功：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.addActionListener(e -&gt; System.out.println(<span class="string">&quot;充值成功&quot;</span>));  <span class="comment">//addActionListener就是按钮点击监听器</span></span><br></pre></td></tr></table></figure><p>是不是感觉还是很简单？当然，如果要修改按钮的字体或是颜色，依然使用之前的方式即可。</p><p>只不过光有按钮似乎太单调了一点，我们接着来认识下一个组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TextField</span> <span class="variable">field</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();   <span class="comment">//TextField是文本框</span></span><br><span class="line">field.setBounds(<span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">25</span>);</span><br><span class="line">frame.add(field);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/27/ZhpojvR6u5DTmVP.png" alt="image-20221027184138604"></p><p> 我们经常要在一些软件上登录，那么就要输入我们的用户名和密码，所以说文本框的作用还是非常明显的，我们也可以通过AWT组件来实现这些功能，我们可以来试试看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TextField</span> <span class="variable">field</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();</span><br><span class="line">field.setBounds(<span class="number">20</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">25</span>);</span><br><span class="line">frame.add(field);</span><br><span class="line"></span><br><span class="line"><span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;点击登录&quot;</span>);</span><br><span class="line">button.setBounds(<span class="number">20</span>, <span class="number">80</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">//点击按钮直接获取文本框中的文本内容，只需要调用getText方法即可</span></span><br><span class="line">button.addActionListener(e -&gt; System.out.println(<span class="string">&quot;输入的用户名是：&quot;</span>+field.getText()));</span><br><span class="line">frame.add(button);</span><br></pre></td></tr></table></figure><p>我们来试试看吧：</p><p><img src="https://s2.loli.net/2022/10/27/7re3aBis2jW9wvP.png" alt="image-20221027184618359"></p><p><img src="https://s2.loli.net/2022/10/27/Erb6npLZqsCPGzQ.png" alt="image-20221027184627653"></p><p>是不是感觉有内味了？当然，可能会有小伙伴觉得如果我们输入密码的话，不应该将展示的文字隐藏起来吗？我们可以这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">field.setEchoChar(<span class="string">&#x27;*&#x27;</span>);   <span class="comment">//setEchoChar设定展示字符，无论我们输入的是什么，最终展示出来的都是我们指定的字符</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/27/Er4wqYUNfAy2HBS.png" alt="image-20221027184814288"></p><p>当然，我们在获取输入的文本时还是输入的文本本身，不会变成展示的文本，只是一个视觉效果而已。这样，我们就可以将密码框做出来了。各位小伙伴可以尝试做一个登录界面。</p><p>但是肯定有小伙伴疑问，不是还有一个记住密码的勾选框吗？安排：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Checkbox</span> <span class="variable">checkbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Checkbox</span>(<span class="string">&quot;记住密码&quot;</span>);</span><br><span class="line">checkbox.setBounds(<span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">30</span>);   <span class="comment">//这个大小并不是勾选框的大小，具体的勾选框大小要根据操作系统决定，跟Label一样，是展示的空间大小</span></span><br><span class="line">frame.add(checkbox);</span><br></pre></td></tr></table></figure><p>最终展示出来的效果就是：</p><p><img src="https://s2.loli.net/2022/10/27/pErwuKAGOa3dQ5l.png" alt="image-20221027185748324"></p><p>效果还是挺不错的，我们也可以设定一个多选框：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CheckboxGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckboxGroup</span>();   <span class="comment">//创建勾选框组</span></span><br><span class="line"></span><br><span class="line"><span class="type">Checkbox</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Checkbox</span>(<span class="string">&quot;选我&quot;</span>);</span><br><span class="line">c1.setBounds(<span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br><span class="line">frame.add(c1);</span><br><span class="line"></span><br><span class="line"><span class="type">Checkbox</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Checkbox</span>(<span class="string">&quot;你干嘛&quot;</span>);</span><br><span class="line">c2.setBounds(<span class="number">20</span>, <span class="number">80</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br><span class="line">frame.add(c2);</span><br><span class="line"></span><br><span class="line">c1.setCheckboxGroup(group);    <span class="comment">//多个勾选框都可以添加到勾选框组中</span></span><br><span class="line">c2.setCheckboxGroup(group);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/27/y8713x9VBlCaQm6.png" alt="image-20221027190207441"></p><p>我们可以使用<code>getSelectedCheckbox</code>方法来获取已经被选中的勾选框：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(group.getSelectedCheckbox());</span><br></pre></td></tr></table></figure><p>常用组件就暂时介绍到这里。</p><h3 id="布局和面板"><a href="#布局和面板" class="headerlink" title="布局和面板"></a>布局和面板</h3><p>前面我们介绍了各种各样的组件，现在我们就可以利用这些组件来拼凑一个好看的程序了。</p><p>只不过，如果不使用布局，那么我们只能手动设置组件的位置以及大小，这就使得我们的程序在尺寸的设计上很有限，因为一旦窗口的大小发生变化，我们的组件依然是会放置在原本的位置上，要保证我们的设计不被破坏就只能固定窗口大小，但是很多应用都是支持放大和缩小的，并且在不同的大小下组件会自己调整位置：</p><p><img src="https://s2.loli.net/2022/10/28/ro7Cxi5Oe8wuALv.png" alt="image-20221028135701447"></p><p>可以看到窗口的大小可以自由移动并且组件的位置会根据窗口大小自己进行调整。</p><p>这正是因为使用了布局实现的，布局可以根据自己的一些性质，对容器（这里可以是我们的窗口）内部的组件自动进行调整，包括组件的位置、组件的大小等，Java为我们提供了各种各样的布局管理器，我们来看看吧。</p><p>默认情况下，我们的窗口采用的是边界布局（BorderLayout）这种布局方式支持将组件放置到五个区域：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frame.setLayout(<span class="keyword">new</span> <span class="title class_">BorderLayout</span>());   <span class="comment">//使用边界布局</span></span><br><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;1号按钮&quot;</span>), BorderLayout.WEST);  <span class="comment">//在添加组件时，可以在后面加入约束</span></span><br><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;2号按钮&quot;</span>), BorderLayout.EAST);</span><br><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;3号按钮&quot;</span>), BorderLayout.SOUTH);</span><br><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;4号按钮&quot;</span>), BorderLayout.NORTH);</span><br><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;5号按钮&quot;</span>), BorderLayout.CENTER);</span><br></pre></td></tr></table></figure><p>注意，约束只有在当前容器为对应布局时才可以使用。这里我们采用的是边界布局，边界布局可以将组件设定到五个区域：</p><p><img src="https://s2.loli.net/2022/10/28/ZigtAkDbrMVqjWz.png" alt="image-20221028140816161"></p><p>可以看到，分别在东、南、西、北、中心位置都可以添加组件，组件的大小会被自动调整，并且随着我们的窗口大小变化，组件的大小也会跟着自动调整，是不是感觉挺方便的？边界布局的性质：</p><ul><li> BorderLayout布局的容器某个位置的某个组件会直接充满整个区域。</li><li>如果在某个位置重复添加组件，只有最后一个添加的组件可见。</li><li>缺少某个位置的组件时，其他位置的组件会延伸到该位置。</li></ul><p>我们还可以调整组件之间的间距：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BorderLayout</span> <span class="variable">borderLayout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BorderLayout</span>();</span><br><span class="line">borderLayout.setHgap(<span class="number">50</span>);   <span class="comment">//Hgap是横向间距</span></span><br><span class="line">borderLayout.setVgap(<span class="number">50</span>);   <span class="comment">//Vgap是纵向间距</span></span><br></pre></td></tr></table></figure><p>调整之后，边距就非常明显了：</p><p><img src="https://s2.loli.net/2022/10/28/XQqnd6GHa7hVOtR.png" alt="image-20221028143042506"></p><p>我们接着来认识一下下一个布局，FlowLayout 流式布局，流式布局实际上就是按顺序排列的一种布局：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">frame.setLayout(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>());   <span class="comment">//采用流式布局</span></span><br><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;1号按钮&quot;</span>));</span><br><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;2号按钮&quot;</span>));</span><br><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;3号按钮&quot;</span>));</span><br></pre></td></tr></table></figure><p>采用流式布局后，按钮会根据内容大小，自动调整为对应的大小，并且他们之间是有间距的：</p><p><img src="https://s2.loli.net/2022/10/28/471ED3GaefjzHy8.png" alt="image-20221028142144585"></p><p>当我们对窗口大小进行调整时，流式布局也会进行自动调整：</p><p><img src="https://s2.loli.net/2022/10/28/hJrBtcVj7MDGqfw.png" alt="image-20221028142326191"></p><p>我们也可以在设定流式布局时指定对齐模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame.setLayout(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>(FlowLayout.RIGHT));   <span class="comment">//指定为右对齐</span></span><br></pre></td></tr></table></figure><p>对齐方式会直接决定组件的排列方式：</p><p><img src="https://s2.loli.net/2022/10/28/QlU8IPoVA2j4E6t.png" alt="image-20221028142506961"></p><p>我们同样可以使用Hgap和Vgap来调整组件之间的间距：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FlowLayout</span> <span class="variable">flowLayout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlowLayout</span>();</span><br><span class="line">flowLayout.setHgap(<span class="number">50</span>);</span><br><span class="line">flowLayout.setVgap(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/28/vVN4O8XynAdW5Jb.png" alt="image-20221028143230216"></p><p>我们接着来看卡片布局，CardLayout对象将卡片作为一个容器中的每个组件，这个卡片布局怎么说呢，有点像iOS14新出的叠放小组件（安卓应该也有）就像很多张卡片叠在一起，每次只能看到最顶上的这张卡片，但是我们可以将下层的卡片切到顶上来：</p><p><img src="https://s2.loli.net/2022/10/28/CqE9FkVSMJXOLY8.png" alt="image-20221028143949323"></p><p>卡片布局就是这样，我们可以添加多个组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CardLayout</span> <span class="variable">layout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CardLayout</span>();</span><br><span class="line">frame.setLayout(layout);</span><br><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;我是1号&quot;</span>));</span><br><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;我是2号&quot;</span>));</span><br><span class="line"></span><br><span class="line">frame.setVisible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    layout.next(frame);    <span class="comment">//我们需要使用CardLayout对象来进行切换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们每三秒钟切换一次卡片，可以看到我们添加的标签每三秒就会变化一次，实际上我们可以利用卡片布局来做一个类似跑马灯的效果，是不是感觉很神奇？</p><p>我们接着来看网格布局，GridLayout以矩形网格的形式对组件进行管理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frame.setLayout(<span class="keyword">new</span> <span class="title class_">GridLayout</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(i + <span class="string">&quot;号按钮&quot;</span>));</span><br></pre></td></tr></table></figure><p>这种布局就很好理解了，默认情况下会生成一行按格子划分的相等区域：</p><p><img src="https://s2.loli.net/2022/10/28/joR1s467rFzJqOE.png" alt="image-20221028145118733"></p><p>我们也可以手动指定行数和列数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GridLayout</span> <span class="variable">gridLayout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GridLayout</span>();</span><br><span class="line">gridLayout.setRows(<span class="number">2</span>);</span><br><span class="line">frame.setLayout(gridLayout);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(i + <span class="string">&quot;号按钮&quot;</span>));</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/28/DtnRaCJh7qzc4w3.png" alt="image-20221028145330522"></p><p>所有的组件都会整齐排列在网格中。</p><p>最后一种布局是GridBagLayout，是最灵活的布局管理器，它同样是按照网格进行划分，但是一个组件可以同时占据多个网格。这种情况其实也是经常会出现的，比如计算器上的按钮虽然看起来也是按照网格排列的，但是有些按钮同时占据了横向或是纵向的两个网格，这种情况使用GridBagLayout布局就可以很好的处理：</p><p><img src="https://s2.loli.net/2022/10/28/JNmjEVWIG2nkxbf.png" alt="image-20221028145752545"></p><p>虽然这个布局很强大，但是用起来也是很麻烦的，所以说这里就不做讲解了，感兴趣的小伙伴可以自行了解。</p><p>虽然认识了这么多的布局，但是我们发现，很多应用程序并不只是由单一的布局组成的，而是多种布局相互嵌套的结果，比如我们的IDEA界面，就不仅仅是一个布局完成的（这里只是举个例子）而是多种布局在嵌套使用：</p><p><img src="https://s2.loli.net/2022/10/28/9ZfvOxThctdPS6N.png" alt="image-20221028151242522"></p><p>但是只有我们的窗口才能设置布局啊，总不可能让多个窗口拼接在一起吧？实际上除了窗口可以作为容器之外，我们也可以使用其他的容器，这时，我们就需要用到面板。</p><p>类面板是最简单的容器类，它跟窗口一样，可以提供一个空间，同样可以随意添加组件到面板中，只不过面板本身也是一个组件，所以说面板是可以放到其他容器中的容器，就像：</p><p><img src="https://s2.loli.net/2022/10/28/jVGTNmd3i2ZRg5h.png" alt="image-20221028151701189"></p><p><img src="https://s2.loli.net/2022/10/28/6PGem8qMrV7NOZS.png" alt="image-20221028151845514"></p><p>面板本身也是容器，所以说也可以单独设置面板内部的布局，比如现在我们想要分两个区域，上半部分区域是流式布局，下半部分区域采用网格布局，那么我们就可以先将窗口采用网格布局，并在上下各添加一个面板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GridLayout</span> <span class="variable">layout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GridLayout</span>();   <span class="comment">//先设置整个窗口的布局</span></span><br><span class="line">layout.setRows(<span class="number">2</span>);     <span class="comment">//设置行数为2，一会就会分成两行了</span></span><br><span class="line">frame.setLayout(layout);</span><br><span class="line"></span><br><span class="line"><span class="type">Panel</span> <span class="variable">top</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Panel</span>();     <span class="comment">//接着我们创建一下上半部分的面板和下半部分的面板</span></span><br><span class="line">top.setBackground(Color.PINK);   <span class="comment">//添加一个背景颜色方便区分</span></span><br><span class="line">frame.add(top);</span><br><span class="line"></span><br><span class="line"><span class="type">Panel</span> <span class="variable">bottom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Panel</span>();</span><br><span class="line">bottom.setBackground(Color.ORANGE);</span><br><span class="line">frame.add(bottom);</span><br></pre></td></tr></table></figure><p>这样，我们的两个面板就按照网格布局，被分成了上下两部分：</p><p><img src="https://s2.loli.net/2022/10/28/agMjZkqrSGUm9Ld.png" alt="image-20221028152352861"></p><p>接着我们就可以分别在上半部分的面板和下半部分的面板中进行单独配置了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Panel</span> <span class="variable">top</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Panel</span>();</span><br><span class="line">top.setBackground(Color.PINK);</span><br><span class="line">top.setLayout(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>());    <span class="comment">//面板默认会采用FlowLayout，所以说这里指不指定都一样</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)    <span class="comment">//面板就像窗口一样，可以设定布局和添加组件</span></span><br><span class="line">    top.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;流式&quot;</span>+i));</span><br><span class="line">frame.add(top);</span><br><span class="line"></span><br><span class="line"><span class="type">Panel</span> <span class="variable">bottom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Panel</span>();</span><br><span class="line">bottom.setBackground(Color.ORANGE);</span><br><span class="line">bottom.setLayout(<span class="keyword">new</span> <span class="title class_">GridLayout</span>());   <span class="comment">//下半部分我们采用网格布局</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    bottom.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;网格&quot;</span>+i));</span><br><span class="line">frame.add(bottom);</span><br></pre></td></tr></table></figure><p>这里我们将上半部分面板设定为流式布局，下半部分面板设定为网格布局：</p><p><img src="https://s2.loli.net/2022/10/28/RbiFpTDCEaN5fPl.png" alt="image-20221028152617119"></p><p>利用面板，我们就可以实现各种布局的自由组合，当然，面板在后面还会有更多的用处。</p><h3 id="滚动面板和列表"><a href="#滚动面板和列表" class="headerlink" title="滚动面板和列表"></a>滚动面板和列表</h3><p>有些时候，我们的窗口大小可能并不能完全显示内部的内容，比如出现了一张很大的图片。</p><p><img src="https://s2.loli.net/2022/10/28/7mKakMLhz95VbIp.png" alt="image-20221028153201386"></p><p>此时就会出现滚动条来让我们进行拖拽，这样就可以向下滑动查看没有完全展示出来的内容了。而我们之前开发的程序都没办法做到这样的滚动，超出部分会直接无法显示。</p><p>AWT也为我们提供了滚动面板组件，滚动面板也是一个容器，但是我们无法修改它的布局，它只能容纳单个组件，比如展示一个图片、或者是列表等，我们也可以将其与Panel配合使用，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScrollPane</span> <span class="variable">scrollPane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollPane</span>();   <span class="comment">//创建滚动面板</span></span><br><span class="line">frame.add(scrollPane);</span><br><span class="line"></span><br><span class="line"><span class="type">GridLayout</span> <span class="variable">layout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GridLayout</span>();    <span class="comment">//创建滚动面板内部的要展示的面板</span></span><br><span class="line">layout.setRows(<span class="number">20</span>);</span><br><span class="line"><span class="type">Panel</span> <span class="variable">panel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Panel</span>();</span><br><span class="line">panel.setLayout(layout);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    panel.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;我是按钮&quot;</span>+i));   <span class="comment">//为面板添加按钮</span></span><br><span class="line">scrollPane.add(panel);</span><br></pre></td></tr></table></figure><p>可以看到，无法显示的部分会自动变成滚动面板，我们滑动就可以展示了：</p><p><img src="https://s2.loli.net/2022/10/28/ZDa92CJVf7TbGk4.png" alt="image-20221028155050727"></p><p>这里需要特别提一下，我们看到这里的按钮大小采用的是自动生成的大小，但是如果我们希望按钮的大小按照我们喜欢的来怎么办呢？我们知道，使用布局之后，组件的大小实际上是自动决定的，只有未使用布局的情况下才能自由更改组件大小，那么我们怎么才能干预呢？我们可以为组件设定一个建议的大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    <span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;我是按钮&quot;</span> + i);</span><br><span class="line">    button.setPreferredSize(<span class="keyword">new</span> <span class="title class_">Dimension</span>(<span class="number">100</span>, <span class="number">50</span>));   <span class="comment">//设置首选大小</span></span><br><span class="line">    panel.add(button);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当布局管理器在自动调整内部组件大小时，如果不是必须要按照布局大小来展示或者是高度或宽度不确定，那么就会采用我们建议的大小展示，比如这里只能确定宽度，而高度是不确定的，那么就可以使用我们建议的大小来展示：</p><p><img src="https://s2.loli.net/2022/10/28/SQZapDy6vdLkHNx.png" alt="image-20221028155443331"></p><p>当然，首选大小可能不太好理解，还需要各位小伙伴多多尝试才能理解。</p><p>实际上滚动面板的最佳搭档就是List列表（注意这里的列表不是我们集合类里面学习的列表，而是展示出来的列表组件）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">List</span>();   <span class="comment">//注意是awt包下的List，别导错了</span></span><br><span class="line">list.add(<span class="string">&quot;小糍粑&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;锅巴洋芋&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;手抓饼&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;凉面&quot;</span>);</span><br><span class="line">list.setMultipleMode(<span class="literal">true</span>);   <span class="comment">//是否开启多选模式</span></span><br></pre></td></tr></table></figure><p>列表组件就像是一个选择列表一样：</p><p><img src="https://s2.loli.net/2022/10/28/ieDtpQqdkBzhsKF.png" alt="image-20221028160340931"></p><p>列表会将元素依次展示出来，我们可以选择列表中的某一项：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.addItemListener(System.out::println);</span><br></pre></td></tr></table></figure><p>列表可以添加监听器，当我们选择某个物品时，就会自动触发：</p><p><img src="https://s2.loli.net/2022/10/28/LXIvYhnFVBlQTGt.png" alt="image-20221028160611113"></p><p>列表就很时候拿来做文件列表。</p><h3 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h3><p>前面我们认识了各种各样的组件，我们接着来看菜单，实际上各位小伙伴会发现我们的程序上方一般都会有一排菜单：</p><p><img src="https://s2.loli.net/2022/10/28/Konar26QHWMTwqd.png" alt="image-20221028161209224"></p><p>在MacOS下是整合到状态栏中的：</p><p><img src="https://s2.loli.net/2022/10/28/G3NiRaBMkJLneVl.png" alt="image-20221028161239672"></p><p>这些菜单一般都会包含我们程序中的一些基本操作，实际上我们的程序中很多地方都会使用到下拉菜单：</p><p><img src="https://s2.loli.net/2022/10/28/hc354p1ri6NmGgA.png" alt="image-20221028161118028"></p><p>而我们编写AWT程序也可以添加这样的菜单，只需要为窗口设定一个菜单栏即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MenuBar</span> <span class="variable">bar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MenuBar</span>();    <span class="comment">//创建菜单栏 </span></span><br><span class="line"><span class="type">Menu</span> <span class="variable">menu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Menu</span>(<span class="string">&quot;我是1号菜单&quot;</span>);</span><br><span class="line">menu.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;测试1&quot;</span>));</span><br><span class="line">menu.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;测试2&quot;</span>));</span><br><span class="line">bar.add(menu);</span><br><span class="line">frame.setMenuBar(bar);    <span class="comment">//为窗口设定刚刚定义好的菜单栏</span></span><br></pre></td></tr></table></figure><p>设定好MenuBar之后，我们的程序就有菜单了：</p><p><img src="https://s2.loli.net/2022/10/28/wIWdRo2velTj1VS.png" alt="image-20221028161741397"></p><p>虽然有点丑，但是确实是内味，不过还是MacOS下好看：</p><p><img src="https://s2.loli.net/2022/10/28/7Dq6L1hbreYIy39.png" alt="image-20221028161910928"></p><p>我们着重来看一下MenuItem，这是我们菜单的每一个选项，我们可以为其添加监听器来监听用户是否点击：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MenuItem</span> <span class="variable">item</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;测试1&quot;</span>);</span><br><span class="line">item.addActionListener(e -&gt; System.out.println(<span class="string">&quot;一号选项被点击了！&quot;</span>));</span><br><span class="line">menu.add(item);</span><br></pre></td></tr></table></figure><p>其实跟我们之前学习的按钮是差不多的：</p><p><img src="https://s2.loli.net/2022/10/28/KskDE9J2QdRtlvV.png" alt="image-20221028162602244"></p><p>我们还可以为菜单中的选项设定快捷键：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MenuItem</span> <span class="variable">item</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;测试1&quot;</span>);</span><br><span class="line">item.setShortcut(<span class="keyword">new</span> <span class="title class_">MenuShortcut</span>(<span class="string">&#x27;A&#x27;</span>));   <span class="comment">//MenuShortcut就是指定快捷键组合，默认情况下是Ctrl+指定按键</span></span><br><span class="line"><span class="comment">//item.setShortcut(new MenuShortcut(&#x27;A&#x27;, true));   //第二个参数指定为true表示需要Ctrl+Shift+指定按键</span></span><br></pre></td></tr></table></figure><p>这里的效果就是Ctrl+A触发快捷键：</p><p><img src="https://s2.loli.net/2022/10/30/lwrjgRxu46UXHZk.png" alt="image-20221030173320786"></p><p>当然，除了这种普通的菜单选项之外，还有可以勾选的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">menu.add(<span class="keyword">new</span> <span class="title class_">CheckboxMenuItem</span>(<span class="string">&quot;测试2&quot;</span>));</span><br></pre></td></tr></table></figure><p>CheckboxMenuItem是可以勾选的选项，它能够对状态进行记录，我们点击选项之后会变成勾选状态：</p><p><img src="https://s2.loli.net/2022/10/28/Q1RgUn7ejZXzH5E.png" alt="image-20221028162655033"></p><p>实际上要添加这样的菜单栏还是挺简单的的，我们接着来看弹出菜单，弹出菜单其实也经常出现，比如我们要新建一个类，我们就可以右键对应的包：</p><p><img src="https://s2.loli.net/2022/10/28/IKe1NL5wm834WdP.png" alt="image-20221028214019648"></p><p>弹出一个浮在窗口之上的，并且可以进行选择的菜单，这个就是弹出菜单。</p><p>比如我们想要实现右键窗口任意位置都弹出菜单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PopupMenu</span> <span class="variable">menu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PopupMenu</span>();    <span class="comment">//创建弹出菜单</span></span><br><span class="line">menu.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;选项1&quot;</span>));   <span class="comment">//每一个选项依然是使用MenuItem</span></span><br><span class="line">menu.add(<span class="keyword">new</span> <span class="title class_">MenuItem</span>(<span class="string">&quot;选项2&quot;</span>));</span><br><span class="line">frame.add(menu);    <span class="comment">//注意，弹出菜单也要作为组件加入到窗口中（但是默认情况下不显示）</span></span><br><span class="line"></span><br><span class="line">frame.addMouseListener(<span class="keyword">new</span> <span class="title class_">MouseAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mousePressed</span><span class="params">(MouseEvent e)</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (e.getButton() == MouseEvent.BUTTON3) &#123;  <span class="comment">//监听鼠标右键</span></span><br><span class="line">            menu.show(frame, e.getX(), e.getY());   <span class="comment">//要展示弹出菜单，我们只需要调用show方法即可</span></span><br><span class="line">          <span class="comment">//注意，第一个参数必须是弹出菜单所加入的窗口或是窗口中的任意一个组件</span></span><br><span class="line">          <span class="comment">//后面的坐标就是相对于这个窗口或是组件的原点（左上角）这个位置进行弹出</span></span><br><span class="line">          <span class="comment">//我们这里写的就是相对于当前窗口的左上角，鼠标点击位置的x、y位置弹出窗口</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们来看看实际效果吧：</p><p><img src="https://s2.loli.net/2022/10/28/tMRbdjE6ZhHuPaQ.png" alt="image-20221028215651667"></p><p>这样，我们就可以设计出更加高级的程序了。</p><h3 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h3><p>有些时候，我们点击关闭按钮之后，窗口并不会直接关闭，而是会弹出一个对话框询问我们是否要退出，比如我们使用记事本编辑完之后未保存就关闭记事本，就会提示我们：</p><p><img src="https://s2.loli.net/2022/10/28/VUshJzZXxC51gpb.png" alt="image-20221028220721666"></p><p>实际上像这样弹出的的一个对话框，在很多时候都很关键，我们也可以使用AWT为我们提供的对话框，比如我们现在希望在关闭窗口时询问我们是否真的要关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dialog</span> <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dialog</span>(frame, <span class="string">&quot;我是对话框&quot;</span>, <span class="literal">true</span>);   </span><br><span class="line"><span class="comment">//第一个参数是父窗口或是父对话框（没错，对话框也可以由对话框唤起）</span></span><br><span class="line"><span class="comment">//最后一个参数是当对话框展示时，是否让父窗口（对话框）无法点击</span></span><br><span class="line">dialog.setSize(<span class="number">200</span>, <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">frame.addWindowListener(<span class="keyword">new</span> <span class="title class_">WindowAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosing</span><span class="params">(WindowEvent e)</span> &#123;</span><br><span class="line">        dialog.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当我们点击关闭时：</p><p><img src="https://s2.loli.net/2022/10/28/VmajcUlSD6GPsrv.png" alt="image-20221028223431754"></p><p>可以看到这里确实弹出了一个对话框（这个对话框无法最小化到图标）也就是说我们只能通过操作对话框来关闭它。</p><p>只不过就单单是这样的一个对话框太过单调了，我们可以为其添加一些按钮之类的东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dialog</span> <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dialog</span>(frame, <span class="string">&quot;我是对话框&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">dialog.setResizable(<span class="literal">false</span>);</span><br><span class="line">dialog.add(<span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;确定是否要退出程序？&quot;</span>), BorderLayout.NORTH);   <span class="comment">//对话框默认采用的是边界布局</span></span><br><span class="line">dialog.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;取消&quot;</span>), BorderLayout.WEST);</span><br><span class="line">dialog.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;不退出&quot;</span>), BorderLayout.EAST);</span><br><span class="line">dialog.setSize(<span class="number">200</span>, <span class="number">80</span>);</span><br></pre></td></tr></table></figure><p>这样我们退出时，就有对应的提示了：</p><p><img src="https://s2.loli.net/2022/10/28/3v7ZJio9mMnK8zk.png" alt="image-20221028224410637"></p><p>对话框就像一个特殊的窗口一样，各位小伙伴可以自由发挥。</p><p>有些时候我们在使用应用程序的时候，可能需要我们去选择电脑上的一些文件，这个时候我们就可以使用文件对话框：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileDialog</span> <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileDialog</span>(frame, <span class="string">&quot;请选择一个文件&quot;</span>, FileDialog.LOAD);  <span class="comment">//选择文件对话框类型，可以是加载文件或是保存文件</span></span><br><span class="line"></span><br><span class="line">frame.addWindowListener(<span class="keyword">new</span> <span class="title class_">WindowAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosing</span><span class="params">(WindowEvent e)</span> &#123;</span><br><span class="line">        dialog.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>文件对话框是根据操作系统提供的文件选择器决定的：</p><p><img src="https://s2.loli.net/2022/10/28/TuHNLsmokZvMhIR.png" alt="image-20221028224815769"></p><p>我们可以通过文件对话框选择一个文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileDialog</span> <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileDialog</span>(frame, <span class="string">&quot;请选择一个文件&quot;</span>, FileDialog.LOAD);</span><br><span class="line"></span><br><span class="line">frame.addWindowListener(<span class="keyword">new</span> <span class="title class_">WindowAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosing</span><span class="params">(WindowEvent e)</span> &#123;</span><br><span class="line">        dialog.setVisible(<span class="literal">true</span>);   <span class="comment">//注意，需要将对话框展示出来之后，才能进行选择</span></span><br><span class="line">      <span class="comment">//选择完成之后getDirectory和getFile方法就可以返回结果了，否则会阻塞</span></span><br><span class="line">        System.out.println(<span class="string">&quot;选择的文件为：&quot;</span>+dialog.getDirectory() + dialog.getFile());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>选择文件之后，我们可以通过对话框直接获取到对应的文件：</p><p><img src="https://s2.loli.net/2022/10/28/uRjWKPgFxCcGUvr.png" alt="image-20221028225343739"></p><p>是不是感觉还是挺简单的？</p><h3 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h3><p>除了使用官方提供的这些组件之外，我们也可以自己创建一些组件来使用，比如官方没有提供图片组件，我们可以自己编写一个图片组件用于在窗口中展示我们的图片。</p><p>要自己编写一个组件，需要完成下面的步骤：</p><ul><li>必须继承自Component类，表示这是一个AWT组件。</li><li>需要自己实现<code>paintComponent</code>方法，这个方法就是组件的绘制方法，最终绘制出来的结果就是展示出来的结果了。</li></ul><p>首先我们先把最简单的事情做了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageView</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;   <span class="comment">//继承自Component表示是一个组件</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImageView</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;    <span class="comment">//重写paint方法，这个方法就是组件的绘制方法</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以先创建一个这个组件并放到我们的窗口中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame.add(<span class="keyword">new</span> <span class="title class_">ImageView</span>()); </span><br></pre></td></tr></table></figure><p>这里用的是边界布局，默认情况下组件会被添加到中心，占满整个窗口。但是由于我们并没有编写任何绘制内容，所以说组件是空白的一片。</p><p>我们来看看这个<code>paint</code>方法该如何重写，这个方法实际上是在窗口绘制时自动调用，那么到底什么是绘制呢？实际上绘制就是需要我们进行画图操作，当窗口首次展示或是修改大小时就会调用这个方法绘制组件（使用过OpenGL的小伙伴应该能够很容易上手）</p><p>这个方法给了我们一个Graphics对象，实际上这个对象就是我们用于绘制图形的工具，比如我们这个组件需要绘制的是一个矩形：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;   <span class="comment">//各位小伙伴可以将Graphics看做一只画笔，我们想让画笔做什么就做什么</span></span><br><span class="line">    g.setColor(Color.BLACK);      <span class="comment">//我们可以先将画笔切换为黑色</span></span><br><span class="line">    g.fillRect(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight());   <span class="comment">//drawRect就是绘制矩形区域，这里的x和y是相对于当前组件的位置来的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看最后会绘制成啥样：</p><p><img src="https://s2.loli.net/2022/10/28/qQweM6DprRJjCl7.png" alt="image-20221028232701565"></p><p>可以看到整个组件都被涂成了黑色，我们还可以绘制更多好玩的图形：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;</span><br><span class="line">    g.setColor(Color.BLACK);</span><br><span class="line">    g.fillRect(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight());</span><br><span class="line">    g.setColor(Color.RED);    <span class="comment">//画笔改成红色</span></span><br><span class="line">  <span class="comment">//在中间画个圆角矩形边框</span></span><br><span class="line">    g.drawRoundRect(getWidth() / <span class="number">4</span>, getHeight() / <span class="number">4</span>, getWidth() / <span class="number">2</span>, getHeight() / <span class="number">2</span>, <span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果就是这样了：</p><p><img src="https://s2.loli.net/2022/10/28/xBsuijLa6beOwJy.png" alt="image-20221028233307877"></p><p>是不是感觉还挺好玩的，就像我们在玩画画游戏一样。这里列一下Graphics接口提供的所有功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Graphics</span> &#123;</span><br><span class="line">   <span class="comment">//移动画笔原点到指定坐标，默认是(0,0)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">translate</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">    <span class="comment">//设定画笔颜色</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(Color c)</span>;</span><br><span class="line">    <span class="comment">//设置为普通绘画模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">setPaintMode</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//交替颜色模式，比较高级，小伙伴自行了解</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">setXORMode</span><span class="params">(Color c1)</span>;</span><br><span class="line">    <span class="comment">//设置字体，绘制文本内容时就按照这个字体来绘制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">setFont</span><span class="params">(Font font)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置裁剪区域，一旦设置裁剪区域，那么裁剪区域以外的地方即使绘制，也不会生效，绘制</span></span><br><span class="line">  <span class="comment">//只会在裁剪区域内生效（有点像图层蒙版？）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">setClip</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span>;</span><br><span class="line">    <span class="comment">//设定自定义形状的裁剪区域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">setClip</span><span class="params">(Shape clip)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝指定区域的内容到另一个位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">copyArea</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height,</span></span><br><span class="line"><span class="params">                                  <span class="type">int</span> dx, <span class="type">int</span> dy)</span>;</span><br><span class="line">    <span class="comment">//绘制直线</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">drawLine</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span>;</span><br><span class="line">    <span class="comment">//填充矩形区域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fillRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span>;</span><br><span class="line">    <span class="comment">//绘制矩形边框</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span>;</span><br><span class="line"><span class="comment">//绘制圆角矩形边框</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">drawRoundRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> arcWidth, <span class="type">int</span> arcHeight)</span>;</span><br><span class="line">    <span class="comment">//填充圆角矩形区域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fillRoundRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> arcWidth, <span class="type">int</span> arcHeight)</span>;</span><br><span class="line">    <span class="comment">//绘制3D矩形边框（其实就是加了个深色和浅色边框，有一个视觉效果罢了）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw3DRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> raised)</span>;</span><br><span class="line">    <span class="comment">//填充3D矩形区域（同上）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fill3DRect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> raised)</span>;</span><br><span class="line">    <span class="comment">//绘制椭圆形边框</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">drawOval</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span>;</span><br><span class="line">    <span class="comment">//填充椭圆形区域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fillOval</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span>;</span><br><span class="line">    <span class="comment">//绘制弧线边框</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">drawArc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height,</span></span><br><span class="line"><span class="params">                                 <span class="type">int</span> startAngle, <span class="type">int</span> arcAngle)</span>;</span><br><span class="line"><span class="comment">//填充扇形区域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fillArc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height,</span></span><br><span class="line"><span class="params">                                 <span class="type">int</span> startAngle, <span class="type">int</span> arcAngle)</span>;</span><br><span class="line">    <span class="comment">//绘制折线（需要提供多个坐标）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">drawPolyline</span><span class="params">(<span class="type">int</span> xPoints[], <span class="type">int</span> yPoints[],</span></span><br><span class="line"><span class="params">                                      <span class="type">int</span> nPoints)</span>;</span><br><span class="line"><span class="comment">//绘制多边形边框</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">drawPolygon</span><span class="params">(<span class="type">int</span> xPoints[], <span class="type">int</span> yPoints[],</span></span><br><span class="line"><span class="params">                                     <span class="type">int</span> nPoints)</span>;</span><br><span class="line">    <span class="comment">//填充多边形区域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fillPolygon</span><span class="params">(<span class="type">int</span> xPoints[], <span class="type">int</span> yPoints[],</span></span><br><span class="line"><span class="params">                                     <span class="type">int</span> nPoints)</span>;</span><br><span class="line">    <span class="comment">//绘制文本</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">drawString</span><span class="params">(String str, <span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">   <span class="comment">//绘制图片（绘制大小为图片原本大小）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">drawImage</span><span class="params">(Image img, <span class="type">int</span> x, <span class="type">int</span> y,</span></span><br><span class="line"><span class="params">                                      ImageObserver observer)</span>;</span><br><span class="line">   <span class="comment">//绘制按自定义大小缩放后的图片</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">drawImage</span><span class="params">(Image img, <span class="type">int</span> x, <span class="type">int</span> y,</span></span><br><span class="line"><span class="params">                                      <span class="type">int</span> width, <span class="type">int</span> height,</span></span><br><span class="line"><span class="params">                                      ImageObserver observer)</span>;</span><br><span class="line">    <span class="comment">//绘制图片时如果是透明部分则采用背景颜色填充</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">drawImage</span><span class="params">(Image img, <span class="type">int</span> x, <span class="type">int</span> y,</span></span><br><span class="line"><span class="params">                                      Color bgcolor,</span></span><br><span class="line"><span class="params">                                      ImageObserver observer)</span>;</span><br><span class="line">    <span class="comment">//绘制按自定义大小缩放后带背景颜色的图片</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">drawImage</span><span class="params">(Image img, <span class="type">int</span> x, <span class="type">int</span> y,</span></span><br><span class="line"><span class="params">                                      <span class="type">int</span> width, <span class="type">int</span> height,</span></span><br><span class="line"><span class="params">                                      Color bgcolor,</span></span><br><span class="line"><span class="params">                                      ImageObserver observer)</span>;</span><br><span class="line">    <span class="comment">//对原本的图片按照起始坐标和尺寸进行裁剪后，再以给定大小绘制到给定位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">drawImage</span><span class="params">(Image img,</span></span><br><span class="line"><span class="params">                                      <span class="type">int</span> dx1, <span class="type">int</span> dy1, <span class="type">int</span> dx2, <span class="type">int</span> dy2,</span></span><br><span class="line"><span class="params">                                      <span class="type">int</span> sx1, <span class="type">int</span> sy1, <span class="type">int</span> sx2, <span class="type">int</span> sy2,</span></span><br><span class="line"><span class="params">                                      ImageObserver observer)</span>;</span><br><span class="line">    <span class="comment">//累了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">drawImage</span><span class="params">(Image img,</span></span><br><span class="line"><span class="params">                                      <span class="type">int</span> dx1, <span class="type">int</span> dy1, <span class="type">int</span> dx2, <span class="type">int</span> dy2,</span></span><br><span class="line"><span class="params">                                      <span class="type">int</span> sx1, <span class="type">int</span> sy1, <span class="type">int</span> sx2, <span class="type">int</span> sy2,</span></span><br><span class="line"><span class="params">                                      Color bgcolor,</span></span><br><span class="line"><span class="params">                                      ImageObserver observer)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里要实现的时绘制一个图片，那么我们就可以像这样编写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageView</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Image image;   </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImageView</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filename);</span><br><span class="line">        image = ImageIO.read(file);   <span class="comment">//我们可以使用ImageIO类来快速将图片文件读取为Image对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;</span><br><span class="line">      <span class="comment">//绘制图片需要提供Image对象</span></span><br><span class="line">        g.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight(), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来试试看效果吧：</p><p><img src="https://s2.loli.net/2022/10/28/5adDsGr2iRxywCX.png" alt="image-20221028235756338"></p><p>可以看到图片成功绘制出来了，这样，我们就提供自己编写绘制逻辑，成功完成了一个简单的自定义组件。</p><p>当然，现在我们讲了如何加载图片，顺便把设定自定义的程序图标介绍一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> ImageIO.read(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.png&quot;</span>));</span><br><span class="line">frame.setIconImage(image);</span><br></pre></td></tr></table></figure><p>注意，在MacOS下这样写没用，得用专用的增强包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> ImageIO.read(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.png&quot;</span>));</span><br><span class="line">Application.getApplication().setDockIconImage(image);</span><br></pre></td></tr></table></figure><p>这样，我们的程序就会显示为我们自己定义的图标了。</p><h3 id="窗口修饰和自定义形状"><a href="#窗口修饰和自定义形状" class="headerlink" title="窗口修饰和自定义形状"></a>窗口修饰和自定义形状</h3><p>实际上我的窗口在默认情况下都是处于修饰状态，那么什么是修饰状态呢？</p><p>窗口修饰实际上就是我们窗口外面添加的边框：</p><p><img src="https://s2.loli.net/2022/10/26/fMQDFCmyqIvJeTl.png" alt="image-20221026164200924"></p><p>有些时候，可能我们并不需要系统为我们提供的窗口边框，我们希望能够自己编写窗口的边框，包括各种按钮等，此时我们就可以将窗口设定为非修饰状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Frame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Frame</span>(<span class="string">&quot;我是窗口&quot;</span>);</span><br><span class="line">    frame.setUndecorated(<span class="literal">true</span>);   <span class="comment">//将窗口设定为非修饰状态</span></span><br><span class="line">    frame.setSize(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">    frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非修饰状态下，就只有一个窗口本身了：</p><p><img src="https://s2.loli.net/2022/10/29/u9jSlmAc2GXr4VJ.png" alt="image-20221029111107959"></p><p>并且这个窗口是无法完成拖拽操作的，要实现拖拽还得我们自己编写（太原始了）可以看到，在默认情况下窗口的形状是一个方形的，我们可以将其调整为其他形状：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Frame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Frame</span>(<span class="string">&quot;我是窗口&quot;</span>);</span><br><span class="line">    frame.setUndecorated(<span class="literal">true</span>);</span><br><span class="line">    frame.setSize(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">  <span class="comment">//注意，只有窗口在非修饰状态下才能设定形状</span></span><br><span class="line">  <span class="comment">//这里我们使用圆角矩形，形状最好跟窗口大小一样</span></span><br><span class="line">    frame.setShape(<span class="keyword">new</span> <span class="title class_">RoundRectangle2D</span>.Double(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line">    frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们的窗口变成了这样：</p><p><img src="https://s2.loli.net/2022/10/29/areQf2g3I74mlpV.png" alt="image-20221029111439062"></p><p>变成了好看的圆角矩形（但是这个圆角处理得不太好，有点毛毛糙糙的）圆角矩形也是现代操作系统窗口的设计语言。</p><p>我们也可以自行为窗口添加标题栏，同样只需要重写一下<code>paint</code>方法自行绘制就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Frame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Frame</span>(<span class="string">&quot;我是窗口&quot;</span>) &#123;    <span class="comment">//使用匿名内部类（或者自己写个子类也行）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;</span><br><span class="line">        g.setColor(Color.LIGHT_GRAY);</span><br><span class="line">        g.fillRect(<span class="number">0</span>, <span class="number">0</span>, getWidth(), <span class="number">28</span>);   <span class="comment">//先绘制标题栏</span></span><br><span class="line">        g.setColor(Color.BLACK); </span><br><span class="line">        g.drawString(getTitle(), getWidth() / <span class="number">2</span>, <span class="number">20</span>);   <span class="comment">//绘制标题名称</span></span><br><span class="line">        <span class="built_in">super</span>.paint(g);   <span class="comment">//原本的绘制别覆盖了，该怎么做还要怎么做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们来看看效果吧：</p><p><img src="https://s2.loli.net/2022/10/29/hQ2YLjSgazM9Wkd.png" alt="image-20221029112035219"></p><p>是不是感觉不依靠操作系统，我们自己也能写一个好看的窗口出来了？</p><p>只不过这个窗口还不能拖动，我们来实现一下按住标题栏就可以拖动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">frame.addMouseMotionListener(<span class="keyword">new</span> <span class="title class_">MouseMotionAdapter</span>() &#123;   <span class="comment">//只需要写一个监听器就可以搞定了</span></span><br><span class="line">    <span class="type">int</span> oldX, oldY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseDragged</span><span class="params">(MouseEvent e)</span> &#123;   <span class="comment">//鼠标拖动时如果是标题栏，就将窗口位置修改</span></span><br><span class="line">        <span class="keyword">if</span>(e.getY() &lt;= <span class="number">28</span>)</span><br><span class="line">            frame.setLocation(e.getXOnScreen() - oldX, e.getYOnScreen() - oldY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseMoved</span><span class="params">(MouseEvent e)</span> &#123;   <span class="comment">//记录上一次的鼠标位置</span></span><br><span class="line">        oldX = e.getX();</span><br><span class="line">        oldY = e.getY();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>至此，有关AWT相关的内容，我们就讲解到这里，相信各位小伙伴肯定已经跃跃欲试想要开发一个自己的桌面应用程序了。只不过很遗憾，Java官方并没有再对AWT相关内容进行维护，因为AWT采用的是取不同操作系统交集策略，因为有些功能只有部分操作系统才有，这就导致很多功能都被砍掉，维护起来也很困难。下节课开始，我们会继续介绍Swing相关组件。</p><hr><h2 id="Swing组件介绍"><a href="#Swing组件介绍" class="headerlink" title="Swing组件介绍"></a>Swing组件介绍</h2><p>前面我们介绍了AWT，通过Java官方为我们提供的GUI框架，我们就可以编写出自己的桌面应用程序了，现在各位小伙伴应该已经有着良好的图形化界面开发基础了。</p><p>而Swing组件才是我们要学习的重点内容，它也是一套GUI框架，但是它是基于AWT编写的上层框架。</p><blockquote><p>Swing 是在AWT的基础上构建的一套新的图形界面系统，它提供了AWT 所能够提供的所有功能，并且用纯粹的Java代码对AWT 的功能进行了大幅度的扩充。例如说并不是所有的操作系统都提供了对树形控件的支持， Swing 利用了AWT 中所提供的基本作图方法对树形控件进行模拟。由于 Swing 控件是用100%的Java代码来实现的，因此在一个平台上设计的树形控件可以在其他平台上使用。由于在Swing 中没有使用本地方法来实现图形功能，我们通常把Swing控件称为轻量级控件。</p></blockquote><p>其实简单来说，这玩意就是AWT那一套东西的扩展，或者说是强化版，很多东西还是沿用的AWT中的。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>我们来看看如何使用Swing编写桌面程序，首先还是最重要的窗口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;我是窗口&quot;</span>);   <span class="comment">//Swing中的窗口叫做JFrame，对应的就是AWT中的Frame</span></span><br><span class="line">    <span class="comment">//它实际上就是Frame的子类，所以说我们之前怎么用的，现在怎么用就行了</span></span><br><span class="line">    frame.setSize(<span class="number">500</span>, <span class="number">300</span>);</span><br><span class="line">    frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉学会AWT之后再看Swing也太简单了？</p><p>当然，既然是AWT的扩展，那肯定是有更多的新增功能的，比如我们之前想要实现点击X号关闭Java程序，这里我们只需要使用一个方法就可以设定了，不需要我们自己去写监听器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们可以直接为窗口设定关闭操作，JFrame已经为我们预设好了一些常用的操作了</span></span><br><span class="line">frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  <span class="comment">//EXIT_ON_CLOSE就是直接退出程序，默认是只隐藏</span></span><br></pre></td></tr></table></figure><p>Swing为我们提供了所有原本AWT中的组件的升级版，他们的名字前面都加上了J，比如按钮组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;我是窗口&quot;</span>);</span><br><span class="line">    frame.setLayout(<span class="literal">null</span>);</span><br><span class="line">    <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;Link Start&quot;</span>);  <span class="comment">//Button组件对应的就是JButton了</span></span><br><span class="line">    button.setBounds(<span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">    frame.add(button);</span><br><span class="line">    frame.setSize(<span class="number">500</span>, <span class="number">300</span>);</span><br><span class="line">    frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swing不像AWT那样，平台组件长啥样，就用什么，它的组件都是自行绘制的：</p><p><img src="https://s2.loli.net/2022/10/29/dy6R2VNuOYIJamA.png" alt="image-20221029120313940"></p><p>这样，我们在不同的平台上，看到的组件UI样式，都会是一样的，不会出现长得不一样的情况。并且我们可以为组件自由替换皮肤，我们会在后面进行介绍。</p><p>还有，Swing在没有设定布局时，组件的坐标原点并不是窗口的左上角，而是窗口标题栏下方的左上角：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;我是窗口&quot;</span>);</span><br><span class="line">frame.setSize(<span class="number">500</span>, <span class="number">300</span>);</span><br><span class="line">frame.setLayout(<span class="literal">null</span>);</span><br><span class="line">frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line"><span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;我是按钮&quot;</span>);</span><br><span class="line">button.setBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">frame.add(button);</span><br><span class="line">frame.setVisible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/05/RMJWl576CiSDs8b.png" alt="image-20221105171035570"></p><p>这一点确实比AWT好很多，不然咱都不知道不同平台的标题栏到底是多高。至于为什么是这样，这是因为JFrame内部实际上单独维护了一个面板来存放组件，很多操作都被重定向给了内部的面板，这里就不深入说了，知道就行。</p><p>同样的，如果我们要使用菜单，直接使用对应的类即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;我是窗口&quot;</span>);</span><br><span class="line"><span class="type">JMenuBar</span> <span class="variable">bar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JMenuBar</span>();    <span class="comment">//JMenuBar对应的就是MenuBar</span></span><br><span class="line"><span class="type">JMenu</span> <span class="variable">menu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JMenu</span>(<span class="string">&quot;我是菜单&quot;</span>);</span><br><span class="line">menu.add(<span class="keyword">new</span> <span class="title class_">JMenuItem</span>(<span class="string">&quot;选项1&quot;</span>));</span><br><span class="line">menu.add(<span class="keyword">new</span> <span class="title class_">JMenuItem</span>(<span class="string">&quot;选项2&quot;</span>));</span><br><span class="line">bar.add(menu);</span><br><span class="line">frame.setJMenuBar(bar);</span><br><span class="line">frame.setSize(<span class="number">500</span>, <span class="number">300</span>);</span><br><span class="line">frame.setVisible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>这个菜单也是Swing自己绘制的，如果是AWT的话，不同系统菜单位置还不一样，虽然这里是自己画的，但是效果看着还行：</p><p><img src="https://s2.loli.net/2022/10/29/aMGHTu8sl2Sg4vm.png" alt="image-20221029120737715"></p><p>所以，Swing相关组件在使用上其实和我们之前学习的AWT是差不多的，只要前面AWT学的没问题，这里简直So Easy。</p><p>因为Swing是沿用的AWT框架体系，所以说AWT提供的旧组件，也是可以用的，但是这里不推荐：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;我是窗口&quot;</span>);</span><br><span class="line">    frame.setSize(<span class="number">500</span>, <span class="number">300</span>);</span><br><span class="line">    frame.add(<span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;我是按钮&quot;</span>));   <span class="comment">//可以继续使用AWT组件，但是有新的咱肯定用新的啊</span></span><br><span class="line">    frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关其他组件还请各位小伙伴自行了解。</p><h3 id="新增组件介绍"><a href="#新增组件介绍" class="headerlink" title="新增组件介绍"></a>新增组件介绍</h3><p>Swing除了强化AWT提供的组件之外，还自行实现了各种各样新式的组件，我们来依次介绍一下。</p><p>首先是进度条组件：</p><p><img src="https://s2.loli.net/2022/11/05/SY8wjEkdcArvxnQ.png" alt="image-20221105163846233"></p><p>很多时候我们都会用到进度条来展示某些任务的完成进度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JProgressBar</span> <span class="variable">bar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JProgressBar</span>();</span><br><span class="line">bar.setMaximum(<span class="number">100</span>);    <span class="comment">//设定进度条的最大值</span></span><br><span class="line">bar.setValue(<span class="number">50</span>);    <span class="comment">//设定进度值</span></span><br><span class="line">bar.setBounds(<span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>我们可以利用进度条来写一个很简单的案例，比如文件的拷贝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JProgressBar</span> <span class="variable">bar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JProgressBar</span>();   <span class="comment">//进度条显示文件拷贝进度</span></span><br><span class="line">bar.setMaximum(<span class="number">1000</span>);</span><br><span class="line">bar.setBounds(<span class="number">20</span>, <span class="number">50</span>, <span class="number">300</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;点击开始&quot;</span>);   <span class="comment">//点击按钮开始拷贝文件</span></span><br><span class="line">button.setBounds(<span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br><span class="line">button.addActionListener(e -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//注意，不能直接在这个线程里面处理，因为这个线程是负责图形界面的，得单独创建一个线程处理，否则图形界面会卡死</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;in.iso&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.iso&quot;</span>))&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> file.length(), current = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = in.read(bytes)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            current += len;</span><br><span class="line">            bar.setValue((<span class="type">int</span>) (bar.getMaximum() * (<span class="type">double</span>)current / size));   <span class="comment">//每次拷贝都更新进度条</span></span><br><span class="line">          bar.repaint();  <span class="comment">//因为并不是每次更新值都会使得组件重新绘制，如果视觉上比较卡，可以每次拷贝都重新绘制组件</span></span><br><span class="line">            out.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException exception) &#123;</span><br><span class="line">        exception.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start());</span><br></pre></td></tr></table></figure><p>这样，我们在拷贝文件的时候，就有一个进度条实时显示当前的进度了：</p><p><img src="https://s2.loli.net/2022/11/05/qNoT6OwylH4Y8xc.png" alt="image-20221105165756172"></p><p>我们接着来看下一个组件，开关按钮：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JToggleButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JToggleButton</span>(<span class="string">&quot;我是切换按钮&quot;</span>);   <span class="comment">//开关按钮有两个状态，一个是开一个是关</span></span><br><span class="line">button.setBounds(<span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>它就像：</p><p><img src="https://s2.loli.net/2022/11/05/1fBdjMOy4SnADHu.png" alt="image-20221105170052200"></p><p>它有着两个状态，我们点击一次会使得其切换到另一种状态：</p><p><img src="https://s2.loli.net/2022/11/05/JXpw64yHb8rCRSg.png" alt="image-20221105170125623"></p><p>还有一些大型组件，比如颜色选择器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JColorChooser</span> <span class="variable">chooser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JColorChooser</span>();</span><br><span class="line">chooser.setBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">600</span>, <span class="number">300</span>);</span><br></pre></td></tr></table></figure><p>颜色选择器的主要作用顾名思义，就是让用户选择一个颜色：</p><p><img src="https://s2.loli.net/2022/11/05/zsjxuSoYEr9lvZy.png" alt="image-20221105170623359"></p><p>这个太高级了，看着就很专业。同样的还有文件选择器JFileChooser：</p><p><img src="https://s2.loli.net/2022/11/05/T6Vld1NMB9AJfct.png" alt="image-20221105170745920"></p><p>完了，这Mac越用咋越像Windows了。</p><p>当然，Swing考虑得不止这些，甚至连工具提示都有，啥是工具提示？</p><p><img src="https://s2.loli.net/2022/11/05/mGaU6X2ILvqQT1g.png" alt="image-20221105171336948"></p><p>实际上就是当我们鼠标移动到某个组件上时，会给出一个漂浮提示，告诉我们这个组件是干嘛用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;我是按钮&quot;</span>);</span><br><span class="line">button.setBounds(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br><span class="line">button.setToolTipText(<span class="string">&quot;这个按钮是用来解决你毕设的！&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/05/izpvcCbVA3Ut81u.png" alt="image-20221105171453445"></p><p><code>setToolTipText</code>方法是<code>JComponent</code>就带有的，因此任何组件都可以设置这样的工具提示，是不是感觉很高级？</p><p>还有文件树，我们经常在窗口中看到这样的：</p><p><img src="https://s2.loli.net/2022/11/05/gcCnLterFaqPvkK.png" alt="image-20221105171728838"></p><p>我们的文件实际上在硬盘上就是以树形存储的，而Swing也为我们提供了能够显示树形关系的组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTree</span>();</span><br><span class="line">tree.setBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/05/IvjYykGRXiOAMtK.png" alt="image-20221105171813979"></p><p>这样，我们就可以用它来做一个文件资源管理器了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里我们让JTree展示.idea目录下所有文件</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.idea&quot;</span>);   <span class="comment">//这里我们列出.idea目录下所有文件</span></span><br><span class="line"><span class="type">DefaultMutableTreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMutableTreeNode</span>(file.getName()); <span class="comment">//既然是树形关系，肯定有一个根结点</span></span><br><span class="line"><span class="comment">//拿到当前目录下所有文件和文件夹</span></span><br><span class="line">File[] files = Optional.ofNullable(file.listFiles()).orElseGet(() -&gt; <span class="keyword">new</span> <span class="title class_">File</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (File f : files)</span><br><span class="line">    root.add(<span class="keyword">new</span> <span class="title class_">DefaultMutableTreeNode</span>(f.getName()));    <span class="comment">//构造子结点并连接</span></span><br><span class="line"></span><br><span class="line"><span class="type">JTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTree</span>(root);    <span class="comment">//设定默认的根结点</span></span><br><span class="line">tree.setBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><p>来看看效果吧：</p><p><img src="https://s2.loli.net/2022/11/05/YN4gKJbfstpRSCE.png" alt="image-20221105172802572"></p><p>你就说有没有内味吧。</p><h3 id="多面板和分割面板"><a href="#多面板和分割面板" class="headerlink" title="多面板和分割面板"></a>多面板和分割面板</h3><p>前面我们介绍了Swing为我们提供的丰富组件，我们接着来看多面板。</p><p><img src="https://s2.loli.net/2022/11/05/keDg2pnsJolaUZH.png" alt="image-20221105173345221"></p><p>多面板顾名思义，就是为了在一个窗口中展示多个面板，但是面板是可以自由切换的，在顶部会有一个小小的标签，我们点击之后就可以切换到对应的面板了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JTabbedPane</span> <span class="variable">pane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTabbedPane</span>();</span><br><span class="line">pane.setBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span>, <span class="number">300</span>);</span><br><span class="line">pane.addTab(<span class="string">&quot;一号&quot;</span>, <span class="keyword">new</span> <span class="title class_">JPanel</span>()&#123;&#123;setBackground(Color.ORANGE);&#125;&#125;);</span><br><span class="line">pane.addTab(<span class="string">&quot;二号&quot;</span>, <span class="keyword">new</span> <span class="title class_">JPanel</span>()&#123;&#123;setBackground(Color.PINK);&#125;&#125;);</span><br></pre></td></tr></table></figure><p>JTabbedPane跟我们之前认识的Panel很像，相当于也是将我们的组件装进了内部，但是它可以同时装很多个，并且支持自由切换，所以说是很高级的。</p><p>这里我们创建两个面板，将一号面板设定为橙色，二号面板设定为粉色，分别添加到里面：</p><p><img src="https://s2.loli.net/2022/11/05/4jp1N9LnmwJGtOl.png" alt="image-20221105173821177"></p><p>这样，我们就可以布置一号面板做某些事情，二号面板做另外一些事情了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JTabbedPane</span> <span class="variable">pane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTabbedPane</span>();</span><br><span class="line">pane.setBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span>, <span class="number">300</span>); </span><br><span class="line">pane.addTab(<span class="string">&quot;一号&quot;</span>, <span class="keyword">new</span> <span class="title class_">JColorChooser</span>());   <span class="comment">//一号面板当颜色选择器</span></span><br><span class="line">pane.addTab(<span class="string">&quot;二号&quot;</span>, <span class="keyword">new</span> <span class="title class_">JFileChooser</span>());    <span class="comment">//二号面板当文件选择器</span></span><br></pre></td></tr></table></figure><p>高级感一下就出来了不是：</p><p><img src="https://s2.loli.net/2022/11/05/QBPn8lk9tFd6sgH.png" alt="image-20221105174105955"></p><p>除了多面板这样的特殊面板组件之外，我们也可以使用分割面板：</p><p><img src="https://s2.loli.net/2022/11/05/2gMxOrFGkHCJ73o.png" alt="image-20221105174239436"></p><p>分割面板将一块完整的面板分割为两个部分，这样，我们就可以分别在左右两边进行操作了，而且中间的分割线是可以拖动的，实际上我们的IDEA也是这样的：</p><p><img src="https://s2.loli.net/2022/11/05/21l4GHg75fCaFzP.png" alt="image-20221105174326135"></p><p>IDEA的左边是文件管理器，右边就是编辑区域，同样支持拖动中间的分割线，这样的设计是非常人性化的。</p><p>我们来看看如何创建分割面板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JSplitPane</span> <span class="variable">pane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSplitPane</span>();</span><br><span class="line">pane.setOrientation(JSplitPane.HORIZONTAL_SPLIT);  <span class="comment">//设定为横向分割</span></span><br><span class="line"><span class="comment">//横向分割之后，我们需要指定左右两边的组件</span></span><br><span class="line">pane.setLeftComponent(<span class="keyword">new</span> <span class="title class_">JPanel</span>()&#123;&#123;setBackground(Color.ORANGE);&#125;&#125;);</span><br><span class="line">pane.setRightComponent(<span class="keyword">new</span> <span class="title class_">JPanel</span>()&#123;&#123;setBackground(Color.PINK);&#125;&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/05/3VjoCckOZG2qNIf.png" alt="image-20221105174609500"></p><p>配合我们之前的JTree组件和JTextArea组件，我们也可以写一个简单的IDEA软件出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JTextArea</span> <span class="variable">area</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextArea</span>();   <span class="comment">//右边就是我们需要编辑的文本域</span></span><br><span class="line"></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.idea&quot;</span>);</span><br><span class="line"><span class="type">DefaultMutableTreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMutableTreeNode</span>(file);</span><br><span class="line">File[] files = Optional.ofNullable(file.listFiles()).orElseGet(() -&gt; <span class="keyword">new</span> <span class="title class_">File</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (File f : files)</span><br><span class="line">    root.add(<span class="keyword">new</span> <span class="title class_">DefaultMutableTreeNode</span>(f.getName()));</span><br><span class="line"><span class="type">JTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTree</span>(root);   <span class="comment">//左边就是我们的文件树</span></span><br><span class="line">tree.addTreeSelectionListener(e -&gt; &#123;   <span class="comment">//点击文件之后，我们需要变换编辑窗口中的文本内容，这里加个监听器</span></span><br><span class="line">    area.setText(<span class="string">&quot;&quot;</span>);   <span class="comment">//先清空</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;.idea/&quot;</span>+e.getPath().getLastPathComponent().toString()))&#123;</span><br><span class="line">        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">128</span>];   <span class="comment">//直接开始读取内容</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = reader.read(chars)) &gt; <span class="number">0</span>)</span><br><span class="line">            area.setText(area.getText() + <span class="keyword">new</span> <span class="title class_">String</span>(chars, <span class="number">0</span>, len));   <span class="comment">//开始写入到编辑窗口中</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pane.setLeftComponent(<span class="keyword">new</span> <span class="title class_">JScrollPane</span>(tree));   <span class="comment">//文件树和编辑区域都套一个滚动面板，因为有可能会撑得很大</span></span><br><span class="line">pane.setRightComponent(<span class="keyword">new</span> <span class="title class_">JScrollPane</span>(area));</span><br></pre></td></tr></table></figure><p>我们来看看我们自己写的IDEA软件怎么样吧：</p><p><img src="https://s2.loli.net/2022/11/05/rwik4EqaOeMYWfz.png" alt="image-20221105180609195"></p><p>嗯，真不错，各位小伙伴赶紧去JetBrains投简历吧！</p><h3 id="选项窗口"><a href="#选项窗口" class="headerlink" title="选项窗口"></a>选项窗口</h3><p>前面我们介绍过对话框，但是AWT提供的对话框太过原始，很多功能都需要我们自行实现，而Swing为我们提供了一套已经实现好的预设选项对话框，我们只需要直接使用即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;我是窗口&quot;</span>);</span><br><span class="line">frame.setSize(<span class="number">500</span>, <span class="number">300</span>);</span><br><span class="line">frame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);  <span class="comment">//先将默认关闭行为设定为什么都不做</span></span><br><span class="line">frame.addWindowListener(<span class="keyword">new</span> <span class="title class_">WindowAdapter</span>() &#123;   <span class="comment">//我们自己来实现窗口关闭行为</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosing</span><span class="params">(WindowEvent e)</span> &#123;   <span class="comment">//这里我们可以直接展示一个预设好的确认对话框</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> JOptionPane.showConfirmDialog(frame, <span class="string">&quot;你真的要退出吗？&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(value == JOptionPane.OK_OPTION)    <span class="comment">//返回值就是用户的选择结果，也是预置好的，这里判断如果是OK那么就退出</span></span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们之前要实现这样的一个功能，非常麻烦，但是现在就很简单了：</p><p><img src="https://s2.loli.net/2022/11/06/ekOZLQnUR2dMXTN.png" alt="image-20221106162732123"></p><p>官方已经给我们预设好了一个对话框，我们直接用就可以了。当然，还有各种类型的，我们可以自己定义窗口的标题、图标等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JOptionPane.showConfirmDialog(frame, <span class="string">&quot;你真的要退出吗？&quot;</span>, <span class="string">&quot;退出程序&quot;</span>, JOptionPane.YES_NO_OPTION);</span><br></pre></td></tr></table></figure><p>除了这种简单的对话框，Swing还为我们提供了一些其他类型的对话框，比如单纯的消息提示框：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JOptionPane.showMessageDialog(frame, <span class="string">&quot;我是简单的提示消息！&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/06/YH8dgDRunsG9jPv.png" alt="image-20221106165351473"></p><p>还有用户输入文本的输入对话框：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;我是窗口&quot;</span>);</span><br><span class="line">frame.setSize(<span class="number">500</span>, <span class="number">300</span>);</span><br><span class="line">frame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);</span><br><span class="line">frame.addWindowListener(<span class="keyword">new</span> <span class="title class_">WindowAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">windowClosing</span><span class="params">(WindowEvent e)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> JOptionPane.showInputDialog(<span class="string">&quot;毕业后的你，将何去何从呢？&quot;</span>);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/06/ZwGfv1HqOjikEPn.png" alt="image-20221106165324954"></p><p>通过灵活使用这些对话框，用户与我们的交互就更加亲密了。</p><h3 id="自定义主题"><a href="#自定义主题" class="headerlink" title="自定义主题"></a>自定义主题</h3><p>Swing早就考虑到了不同平台可能会出现的组件样式差异，因此推出了皮肤机制。</p><p>就像我们可以给英雄换皮肤一样，我们的组件UI也是可以换皮肤的，官方名称叫做LookAndFeel，Swing官方为我们提供了很多套皮肤，这些皮肤都是可以跨平台的，当然也有某些平台专属的限定皮肤：</p><ul><li>MetalLookAndFeel  -  官方默认皮肤</li><li>WindowsLookAndFeel  -  Windows操作系统限定皮肤，其他平台无法使用</li><li>MotifLookAndFeel   -   官方皮肤</li><li>NimbusLookAndFeel   -   官方皮肤</li><li>AquaLookAndFeel    -    MacOS操作系统限定皮肤，其他平台无法使用</li></ul><p>更换皮肤很简单，我们只需要执行一个方法就可以，它是全局生效的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIManager.setLookAndFeel(<span class="keyword">new</span> <span class="title class_">AquaLookAndFeel</span>());</span><br></pre></td></tr></table></figure><p>这里我们将皮肤设定为MacOS的冰雪节限定皮肤AquaLookAndFeel：</p><p><img src="https://s2.loli.net/2022/11/06/L7HyUlVpA5P9iTZ.png" alt="image-20221106170921703"></p><p>是不是感觉视觉上和之前的皮肤不太一样？我们可以多看看其他的皮肤：</p><p><img src="https://s2.loli.net/2022/11/06/EGrWzIZuRfejXN2.png" alt="image-20221106171046755"></p><p><img src="https://s2.loli.net/2022/11/06/BOtWrIe7CuklMcZ.png" alt="image-20221106171110930"></p><p>实际上Swing组件的绘制并不是由组件本身编写的，而是在各个UI实现类中编写的，所以说要修改组件样式只需要更换皮肤即可。</p><p>除了全局设定皮肤之外，我们也可以单独对某些组件设定皮肤，每个组件都有自己的<code>getUI</code>方法，这个方法就是获取当前组件使用的UI样式的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(tree.getUI());</span><br></pre></td></tr></table></figure><p>这里得到的是：</p><p><img src="https://s2.loli.net/2022/11/06/2NChELXRkoqJGMQ.png" alt="image-20221106224348544"></p><p>我们可以自己编写一个UI样式来为组件进行设定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TestJButtonUI</span> <span class="keyword">extends</span> <span class="title class_">ButtonUI</span> &#123;   <span class="comment">//继承对应的UI父类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g, JComponent c)</span> &#123;   <span class="comment">//我们只需要重写对应UI的paint方法就可以了</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> c.getWidth(), height = c.getHeight();</span><br><span class="line">        g.setColor(Color.BLACK);</span><br><span class="line">        g.fillRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        g.setColor(Color.WHITE);</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> (JButton) c;</span><br><span class="line">        g.drawString(button.getText(), <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要使用set方法来设定即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;我是按钮&quot;</span>);</span><br><span class="line">button.setBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">30</span>);</span><br><span class="line">button.setUI(<span class="keyword">new</span> <span class="title class_">TestJButtonUI</span>());   <span class="comment">//将UI设定为我们自己定义的即可</span></span><br></pre></td></tr></table></figure><p>这样就换成我们自己的皮肤了：</p><p><img src="https://s2.loli.net/2022/11/06/53kHx2zTZ7wtUfC.png" alt="image-20221106231437842"></p><p>各位小伙伴甚至可以编写一套自己的UI，并制作成一个LookAndFeel，这样我们写出来的程序就非常个性化了。</p><hr><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><p>前面我们已经学习了Swing的全部内容，最后我们还是来做一个小项目吧！</p><h3 id="Intellij-IDEA-Extreme"><a href="#Intellij-IDEA-Extreme" class="headerlink" title="Intellij IDEA Extreme"></a>Intellij IDEA Extreme</h3><p>我们的目标是用IDEA写一个IDEA（当然不会太复杂，只需要实现基本功能就可以了）</p><p>需求分析：</p><ul><li>支持创建项目、管理项目文件</li><li>支持对源代码文件的编辑</li><li>支持一键编译、运行</li></ul><p>做Swing项目，什么五子棋、坦克大战都弱爆了，这里我们直接手撕一个IDEA出来。</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="java" scheme="https://www.hoveco.top/categories/java/"/>
    
    
    <category term="JavaSE" scheme="https://www.hoveco.top/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>Spring 6</title>
    <link href="https://www.hoveco.top/2023/10/10/spring6/"/>
    <id>https://www.hoveco.top/2023/10/10/spring6/</id>
    <published>2023-10-10T02:20:27.000Z</published>
    <updated>2023-10-10T13:51:49.658Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/10/10/p53s17LhtEvkyGT.png" alt="image-20221209110043449"></p><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><h3 id="1-1、Spring是什么？"><a href="#1-1、Spring是什么？" class="headerlink" title="1.1、Spring是什么？"></a>1.1、Spring是什么？</h3><p>Spring 是一款主流的 Java EE 轻量级开源框架 ，Spring 由“Spring 之父”Rod Johnson 提出并创立，其目的是用于简化 Java 企业级应用的开发难度和开发周期。Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring 框架除了自己提供功能外，还提供整合其他技术和框架的能力。</p><p>Spring 自诞生以来备受青睐，一直被广大开发人员作为 Java 企业级应用程序开发的首选。时至今日，Spring 俨然成为了 Java EE 代名词，成为了构建 Java EE 应用的事实标准。</p><p>自 2004 年 4 月，Spring 1.0 版本正式发布以来，Spring 已经步入到了第 6 个大版本，也就是 Spring 6。本课程采用Spring当前最新发布的正式版本<strong>6.0.2</strong>。</p><p><img src="https://s2.loli.net/2023/10/10/XPOqd6kBgaJyElb.png" alt="image-20221216223135162"></p><h3 id="1-2、Spring-的狭义和广义"><a href="#1-2、Spring-的狭义和广义" class="headerlink" title="1.2、Spring 的狭义和广义"></a>1.2、Spring 的狭义和广义</h3><p>在不同的语境中，Spring 所代表的含义是不同的。下面我们就分别从“广义”和“狭义”两个角度，对 Spring 进行介绍。</p><p><strong>广义的 Spring：Spring 技术栈</strong></p><p>广义上的 Spring 泛指以 Spring Framework 为核心的 Spring 技术栈。</p><p>经过十多年的发展，Spring 已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如 Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。</p><p>这些子项目涵盖了从企业级应用开发到云计算等各方面的内容，能够帮助开发人员解决软件发展过程中不断产生的各种实际问题，给开发人员带来了更好的开发体验。</p><p><strong>狭义的 Spring：Spring Framework</strong></p><p>狭义的 Spring 特指 Spring Framework，通常我们将它称为 Spring 框架。</p><p>Spring 框架是一个分层的、面向切面的 Java 应用程序的一站式轻量级解决方案，它是 Spring 技术栈的核心和基础，是为了解决企业级应用开发的复杂性而创建的。</p><p>Spring 有两个最核心模块： IoC 和 AOP。</p><p><strong>IoC</strong>：Inverse of Control 的简写，译为“控制反转”，指把创建对象过程交给 Spring 进行管理。</p><p><strong>AOP</strong>：Aspect Oriented Programming 的简写，译为“面向切面编程”。AOP 用来封装多个类的公共行为，将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，AOP 还解决一些系统层面上的问题，比如日志、事务、权限等。</p><h3 id="1-3、Spring-Framework特点"><a href="#1-3、Spring-Framework特点" class="headerlink" title="1.3、Spring Framework特点"></a>1.3、Spring Framework特点</h3><ul><li><p>非侵入式：使用 Spring Framework 开发应用程序时，Spring 对应用程序本身的结构影响非常小。对领域模型可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会破坏原有结构，反而能将组件结构进一步简化。这就使得基于 Spring Framework 开发应用程序时结构清晰、简洁优雅。</p></li><li><p>控制反转：IoC——Inversion of Control，翻转资源获取方向。把自己创建资源、向环境索取资源变成环境将资源准备好，我们享受资源注入。</p></li><li><p>面向切面编程：AOP——Aspect Oriented Programming，在不修改源代码的基础上增强代码功能。</p></li><li><p>容器：Spring IoC 是一个容器，因为它包含并且管理组件对象的生命周期。组件享受到了容器化的管理，替程序员屏蔽了组件创建过程中的大量细节，极大的降低了使用门槛，大幅度提高了开发效率。</p></li><li><p>组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML 和 Java 注解组合这些对象。这使得我们可以基于一个个功能明确、边界清晰的组件有条不紊的搭建超大型复杂应用系统。</p></li><li><p>一站式：在 IoC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库。而且 Spring 旗下的项目已经覆盖了广泛领域，很多方面的功能性需求可以在 Spring Framework 的基础上全部使用 Spring 来实现。</p></li></ul><h3 id="1-4、Spring模块组成"><a href="#1-4、Spring模块组成" class="headerlink" title="1.4、Spring模块组成"></a>1.4、Spring模块组成</h3><p>官网地址：<a href="https://spring.io/">https://spring.io/</a></p><p><img src="https://s2.loli.net/2023/10/10/1cMrZp4NmbE2wTG.png" alt="image-20221207142746771"></p><p><img src="https://s2.loli.net/2023/10/10/K7xv3cN9strliWy.png" alt="image-2097896352"></p><p>上图中包含了 Spring 框架的所有模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。下面分别对这些模块的作用进行简单介绍。</p><p><strong>①Spring Core（核心容器）</strong></p><p>spring core提供了IOC,DI,Bean配置装载创建的核心实现。核心概念： Beans、BeanFactory、BeanDefinitions、ApplicationContext。</p><ul><li><p>spring-core ：IOC和DI的基本实现</p></li><li><p>spring-beans：BeanFactory和Bean的装配管理(BeanFactory)</p></li><li><p>spring-context：Spring context上下文，即IOC容器(AppliactionContext)</p></li><li><p>spring-expression：spring表达式语言</p></li></ul><p><strong>②Spring AOP</strong></p><ul><li>spring-aop：面向切面编程的应用模块，整合ASM，CGLib，JDK Proxy</li><li>spring-aspects：集成AspectJ，AOP应用框架</li><li>spring-instrument：动态Class Loading模块</li></ul><p><strong>③Spring Data Access</strong></p><ul><li>spring-jdbc：spring对JDBC的封装，用于简化jdbc操作</li><li>spring-orm：java对象与数据库数据的映射框架</li><li>spring-oxm：对象与xml文件的映射框架</li><li>spring-jms： Spring对Java Message Service(java消息服务)的封装，用于服务之间相互通信</li><li>spring-tx：spring jdbc事务管理</li></ul><p><strong>④Spring Web</strong></p><ul><li>spring-web：最基础的web支持，建立于spring-context之上，通过servlet或listener来初始化IOC容器</li><li>spring-webmvc：实现web mvc</li><li>spring-websocket：与前端的全双工通信协议</li><li>spring-webflux：Spring 5.0提供的，用于取代传统java servlet，非阻塞式Reactive Web框架，异步，非阻塞，事件驱动的服务</li></ul><p><strong>⑤Spring Message</strong></p><ul><li>Spring-messaging：spring 4.0提供的，为Spring集成一些基础的报文传送服务</li></ul><p><strong>⑥Spring test</strong></p><ul><li>spring-test：集成测试支持，主要是对junit的封装</li></ul><h3 id="1-5、Spring6特点"><a href="#1-5、Spring6特点" class="headerlink" title="1.5、Spring6特点"></a>1.5、Spring6特点</h3><h4 id="1-5-1、版本要求"><a href="#1-5-1、版本要求" class="headerlink" title="1.5.1、版本要求"></a>1.5.1、版本要求</h4><p><strong>（1）Spring6要求JDK最低版本是JDK17</strong></p><p><img src="https://s2.loli.net/2023/10/10/MNW6LnSbl9wOqij.png" alt="image-20221201103138194"></p><h4 id="1-5-2、本课程软件版本"><a href="#1-5-2、本课程软件版本" class="headerlink" title="1.5.2、本课程软件版本"></a>1.5.2、本课程软件版本</h4><p>（1）IDEA开发工具：2022.1.2</p><p>（2）JDK：Java17<strong>（Spring6要求JDK最低版本是Java17）</strong></p><p>（3）Spring：6.0.2</p><h2 id="2、入门"><a href="#2、入门" class="headerlink" title="2、入门"></a>2、入门</h2><h3 id="2-1、环境要求"><a href="#2-1、环境要求" class="headerlink" title="2.1、环境要求"></a>2.1、环境要求</h3><ul><li><p>JDK：Java17+<strong>（Spring6要求JDK最低版本是Java17）</strong></p></li><li><p>Maven：3.6+</p></li><li><p>Spring：6.0.2</p></li></ul><h3 id="2-2、构建模块"><a href="#2-2、构建模块" class="headerlink" title="2.2、构建模块"></a>2.2、构建模块</h3><p><strong>（1）构建父模块spring6</strong></p><p>在idea中，依次单击 File -&gt; New -&gt; Project -&gt; New Project</p><p><img src="https://s2.loli.net/2023/10/10/TH2mMFAPuoUe8Vi.png" alt="image-20221205201741893"></p><p>点击“Create”</p><p><img src="https://s2.loli.net/2023/10/10/sUC129mlqNHXMgQ.png" alt="image-20221205202000198"></p><p>删除src目录</p><p><strong>（2）构建子模块spring6-first</strong></p><p><img src="https://s2.loli.net/2023/10/10/hWjuEebqFCN9mzk.png" alt="image-20221205202117383"></p><p>点击 Create 完成</p><p><img src="https://s2.loli.net/2023/10/10/syKrWS5DcgO16Vj.png" alt="image-20221205202154225"></p><h3 id="2-3、程序开发"><a href="#2-3、程序开发" class="headerlink" title="2.3、程序开发"></a>2.3、程序开发</h3><h4 id="2-3-1、引入依赖"><a href="#2-3-1、引入依赖" class="headerlink" title="2.3.1、引入依赖"></a>2.3.1、引入依赖</h4><p><a href="https://spring.io/projects/spring-framework#learn">https://spring.io/projects/spring-framework#learn</a></p><p><strong>添加依赖：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring context依赖--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--junit5测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>查看依赖：</strong></p><p><img src="https://s2.loli.net/2023/10/10/I9xYkLFnyzcAGWR.png" alt="image-20221201105416558"></p><h4 id="2-3-2、创建java类"><a href="#2-3-2、创建java类" class="headerlink" title="2.3.2、创建java类"></a>2.3.2、创建java类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3、创建配置文件"><a href="#2-3-3、创建配置文件" class="headerlink" title="2.3.3、创建配置文件"></a>2.3.3、创建配置文件</h4><p>在resources目录创建一个 Spring 配置文件 beans.xml（配置文件名称可随意命名，如：springs.xm）</p><p><img src="https://s2.loli.net/2023/10/10/YxaK8wEZV39S6vj.png" alt="img007"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    配置HelloWorld所对应的bean，即将HelloWorld的对象交给Spring的IOC容器管理</span></span><br><span class="line"><span class="comment">    通过bean标签配置IOC容器所管理的bean</span></span><br><span class="line"><span class="comment">    属性：</span></span><br><span class="line"><span class="comment">        id：设置bean的唯一标识</span></span><br><span class="line"><span class="comment">        class：设置bean所对应类型的全类名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloWorld&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.HelloWorld&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-4、创建测试类测试"><a href="#2-3-4、创建测试类测试" class="headerlink" title="2.3.4、创建测试类测试"></a>2.3.4、创建测试类测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHelloWorld</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="type">HelloWorld</span> <span class="variable">helloworld</span> <span class="operator">=</span> (HelloWorld) ac.getBean(<span class="string">&quot;helloWorld&quot;</span>);</span><br><span class="line">        helloworld.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-5、运行测试程序"><a href="#2-3-5、运行测试程序" class="headerlink" title="2.3.5、运行测试程序"></a>2.3.5、运行测试程序</h4><p><img src="https://s2.loli.net/2023/10/10/znLpgf87HPjOTZX.png" alt="image-20221031172354535"></p><h3 id="2-4、程序分析"><a href="#2-4、程序分析" class="headerlink" title="2.4、程序分析"></a>2.4、程序分析</h3><p><strong>1. 底层是怎么创建对象的，是通过反射机制调用无参数构造方法吗？</strong></p><p>修改HelloWorld类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloWorld</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参数构造方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://s2.loli.net/2023/10/10/sw8vCehVPBfzOxQ.png" alt="image-20221031181430720"></p><p><strong>测试得知：创建对象时确实调用了无参数构造方法。</strong></p><p><strong>2. Spring是如何创建对象的呢？原理是什么？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dom4j解析beans.xml文件，从中获取class属性值，类的全类名</span></span><br><span class="line"> <span class="comment">// 通过反射机制调用无参数构造方法创建对象</span></span><br><span class="line"> <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.spring6.bean.HelloWorld&quot;</span>);</span><br><span class="line"> <span class="comment">//Object obj = clazz.newInstance();</span></span><br><span class="line"> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> clazz.getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure><p><strong>3. 把创建好的对象存储到一个什么样的数据结构当中了呢？</strong></p><p>bean对象最终存储在spring容器中，在spring源码底层就是一个map集合，存储bean的map在<strong>DefaultListableBeanFactory</strong>类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure><p>Spring容器加载到Bean类时 , 会把这个类的描述信息, 以包名加类名的方式存到beanDefinitionMap 中,<br>Map&lt;String,BeanDefinition&gt; , 其中 String是Key , 默认是类名首字母小写 , BeanDefinition , 存的是类的定义(描述信息) , 我们通常叫BeanDefinition接口为 : bean的定义对象。</p><h3 id="2-5、启用Log4j2日志框架"><a href="#2-5、启用Log4j2日志框架" class="headerlink" title="2.5、启用Log4j2日志框架"></a>2.5、启用Log4j2日志框架</h3><h4 id="2-5-1、Log4j2日志概述"><a href="#2-5-1、Log4j2日志概述" class="headerlink" title="2.5.1、Log4j2日志概述"></a>2.5.1、Log4j2日志概述</h4><p>在项目开发中，日志十分的重要，不管是记录运行情况还是定位线上问题，都离不开对日志的分析。日志记录了系统行为的时间、地点、状态等相关信息，能够帮助我们了解并监控系统状态，在发生错误或者接近某种危险状态时能够及时提醒我们处理，同时在系统产生问题时，能够帮助我们快速的定位、诊断并解决问题。</p><p><strong>Apache Log4j2</strong>是一个开源的日志记录组件，使用非常的广泛。在工程中以易用方便代替了 System.out 等打印语句，它是JAVA下最流行的日志输入工具。 </p><p><strong>Log4j2主要由几个重要的组件构成：</strong></p><p><strong>（1）日志信息的优先级</strong>，日志信息的优先级从高到低有<strong>TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</strong><br>                TRACE：追踪，是最低的日志级别，相当于追踪程序的执行<br>                DEBUG：调试，一般在开发中，都将其设置为最低的日志级别<br>                INFO：信息，输出重要的信息，使用较多<br>                WARN：警告，输出警告的信息<br>                ERROR：错误，输出错误信息<br>                FATAL：严重错误</p><p>这些级别分别用来指定这条日志信息的重要程度；级别高的会自动屏蔽级别低的日志，也就是说，设置了WARN的日志，则INFO、DEBUG的日志级别的日志不会显示</p><p><strong>（2）日志信息的输出目的地</strong>，日志信息的输出目的地指定了日志将打印到<strong>控制台</strong>还是<strong>文件中</strong>；</p><p><strong>（3）日志信息的输出格式</strong>，而输出格式则控制了日志信息的显示内容。</p><h4 id="2-5-2、引入Log4j2依赖"><a href="#2-5-2、引入Log4j2依赖" class="headerlink" title="2.5.2、引入Log4j2依赖"></a>2.5.2、引入Log4j2依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--log4j2的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j2-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-5-3、加入日志配置文件"><a href="#2-5-3、加入日志配置文件" class="headerlink" title="2.5.3、加入日志配置文件"></a>2.5.3、加入日志配置文件</h4><p>在类的根路径下提供log4j2.xml配置文件（文件名固定为：log4j2.xml，文件必须放到类根路径下。）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            level指定日志级别，从低到高的优先级：</span></span><br><span class="line"><span class="comment">                TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</span></span><br><span class="line"><span class="comment">                trace：追踪，是最低的日志级别，相当于追踪程序的执行</span></span><br><span class="line"><span class="comment">                debug：调试，一般在开发中，都将其设置为最低的日志级别</span></span><br><span class="line"><span class="comment">                info：信息，输出重要的信息，使用较多</span></span><br><span class="line"><span class="comment">                warn：警告，输出警告的信息</span></span><br><span class="line"><span class="comment">                error：错误，输出错误信息</span></span><br><span class="line"><span class="comment">                fatal：严重错误</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;spring6log&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFile&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;log&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--输出日志信息到控制台--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">&quot;spring6log&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--控制日志输出的格式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%t] %-3level %logger&#123;1024&#125; - %msg%n&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，适合临时测试用--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">&quot;log&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;d:/spring6_log/test.log&quot;</span> <span class="attr">append</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 这个会打印出所有的信息，</span></span><br><span class="line"><span class="comment">            每次大小超过size，</span></span><br><span class="line"><span class="comment">            则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，</span></span><br><span class="line"><span class="comment">            作为存档--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;RollingFile&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;d:/spring6_log/app.log&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">filePattern</span>=<span class="string">&quot;log/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd &#x27;at&#x27; HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;50MB&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，</span></span><br><span class="line"><span class="comment">            则默认为最多同一文件夹下7个文件，这里设置了20 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-5-4、测试"><a href="#2-5-4、测试" class="headerlink" title="2.5.4、测试"></a>2.5.4、测试</h4><p>运行原测试程序</p><p><img src="https://s2.loli.net/2023/10/10/JtUHI7XYuLKdTcy.png" alt="image-20221031214305224"></p><p>运行原测试程序，多了spring打印日志</p><h4 id="2-5-5、使用日志"><a href="#2-5-5、使用日志" class="headerlink" title="2.5.5、使用日志"></a>2.5.5、使用日志</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHelloWorld</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="type">HelloWorld</span> <span class="variable">helloworld</span> <span class="operator">=</span> (HelloWorld) ac.getBean(<span class="string">&quot;helloWorld&quot;</span>);</span><br><span class="line">        helloworld.sayHello();</span><br><span class="line">        logger.info(<span class="string">&quot;执行成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台：</p><p><img src="https://s2.loli.net/2023/10/10/jQYNRyGvdtl8Pbe.png" alt="image-20221031214547501"></p><h2 id="3、容器：IoC"><a href="#3、容器：IoC" class="headerlink" title="3、容器：IoC"></a>3、容器：IoC</h2><p>IoC 是 Inversion of Control 的简写，译为“控制反转”，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。</p><p>Spring 通过 IoC 容器来管理所有 Java 对象的实例化和初始化，控制对象与对象之间的依赖关系。我们将由 IoC 容器管理的 Java 对象称为 Spring Bean，它与使用关键字 new 创建的 Java 对象没有任何区别。</p><p>IoC 容器是 Spring 框架中最重要的核心组件之一，它贯穿了 Spring 从诞生到成长的整个过程。</p><h3 id="3-1、IoC容器"><a href="#3-1、IoC容器" class="headerlink" title="3.1、IoC容器"></a>3.1、IoC容器</h3><h4 id="3-1-1、控制反转（IoC）"><a href="#3-1-1、控制反转（IoC）" class="headerlink" title="3.1.1、控制反转（IoC）"></a>3.1.1、控制反转（IoC）</h4><ul><li><p>控制反转是一种思想。</p></li><li><p>控制反转是为了降低程序耦合度，提高程序扩展力。</p></li><li><p>控制反转，反转的是什么？</p></li><li><ul><li>将对象的创建权利交出去，交给第三方容器负责。</li><li>将对象和对象之间关系的维护权交出去，交给第三方容器负责。</li></ul></li><li><p>控制反转这种思想如何实现呢？</p></li><li><ul><li>DI（Dependency Injection）：依赖注入</li></ul></li></ul><h4 id="3-1-2、依赖注入"><a href="#3-1-2、依赖注入" class="headerlink" title="3.1.2、依赖注入"></a>3.1.2、依赖注入</h4><p>DI（Dependency Injection）：依赖注入，依赖注入实现了控制反转的思想。</p><p><strong>依赖注入：</strong></p><ul><li><strong>指Spring创建对象的过程中，将对象依赖属性通过配置进行注入</strong></li></ul><p>依赖注入常见的实现方式包括两种：</p><ul><li>第一种：set注入</li><li>第二种：构造注入</li></ul><p>所以结论是：IOC 就是一种控制反转的思想， 而 DI 是对IoC的一种具体实现。</p><p><strong>Bean管理说的是：Bean对象的创建，以及Bean对象中属性的赋值（或者叫做Bean对象之间关系的维护）。</strong></p><h4 id="3-1-3、IoC容器在Spring的实现"><a href="#3-1-3、IoC容器在Spring的实现" class="headerlink" title="3.1.3、IoC容器在Spring的实现"></a>3.1.3、IoC容器在Spring的实现</h4><p>Spring 的 IoC 容器就是 IoC思想的一个落地的产品实现。IoC容器中管理的组件也叫做 bean。在创建 bean 之前，首先需要创建IoC 容器。Spring 提供了IoC 容器的两种实现方式：</p><p><strong>①BeanFactory</strong></p><p>这是 IoC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。</p><p><strong>②ApplicationContext</strong></p><p>BeanFactory 的子接口，提供了更多高级特性。面向 Spring 的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。</p><p><strong>③ApplicationContext的主要实现类</strong></p><p><img src="https://s2.loli.net/2023/10/10/5QaTfcHZmXUqMp3.png" alt="iamges"></p><table><thead><tr><th>类型名</th><th>简介</th></tr></thead><tbody><tr><td>ClassPathXmlApplicationContext</td><td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>FileSystemXmlApplicationContext</td><td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>ConfigurableApplicationContext</td><td>ApplicationContext 的子接口，包含一些扩展方法 refresh() 和 close() ，让 ApplicationContext 具有启动、关闭和刷新上下文的能力。</td></tr><tr><td>WebApplicationContext</td><td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</td></tr></tbody></table><h3 id="3-2、基于XML管理Bean"><a href="#3-2、基于XML管理Bean" class="headerlink" title="3.2、基于XML管理Bean"></a>3.2、基于XML管理Bean</h3><h4 id="3-2-1、搭建子模块spring6-ioc-xml"><a href="#3-2-1、搭建子模块spring6-ioc-xml" class="headerlink" title="3.2.1、搭建子模块spring6-ioc-xml"></a>3.2.1、搭建子模块spring6-ioc-xml</h4><p><strong>①搭建模块</strong></p><p>搭建方式如：spring-first</p><p><strong>②引入配置文件</strong></p><p>引入spring-first模块配置文件：beans.xml、log4j2.xml</p><p><strong>③添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring context依赖--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--junit5测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--log4j2的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j2-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>④引入java类</strong></p><p>引入spring-first模块java及test目录下实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloWorld</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参数构造方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHelloWorld</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2、实验一：获取bean"><a href="#3-2-2、实验一：获取bean" class="headerlink" title="3.2.2、实验一：获取bean"></a>3.2.2、实验一：获取bean</h4><h5 id="①方式一：根据id获取"><a href="#①方式一：根据id获取" class="headerlink" title="①方式一：根据id获取"></a>①方式一：根据id获取</h5><p>由于 id 属性指定了 bean 的唯一标识，所以根据 bean 标签的 id 属性可以精确获取到一个组件对象。上个实验中我们使用的就是这种方式。</p><h5 id="②方式二：根据类型获取"><a href="#②方式二：根据类型获取" class="headerlink" title="②方式二：根据类型获取"></a>②方式二：根据类型获取</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHelloWorld1</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="type">HelloWorld</span> <span class="variable">bean</span> <span class="operator">=</span> ac.getBean(HelloWorld.class);</span><br><span class="line">    bean.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="③方式三：根据id和类型"><a href="#③方式三：根据id和类型" class="headerlink" title="③方式三：根据id和类型"></a>③方式三：根据id和类型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHelloWorld2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="type">HelloWorld</span> <span class="variable">bean</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;helloworld&quot;</span>, HelloWorld.class);</span><br><span class="line">    bean.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="④注意的地方"><a href="#④注意的地方" class="headerlink" title="④注意的地方"></a>④注意的地方</h5><p>当根据类型获取bean时，要求IOC容器中指定类型的bean有且只能有一个</p><p>当IOC容器中一共配置了两个：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloworldOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.HelloWorld&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloworldTwo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.HelloWorld&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据类型获取时会抛出异常：</p><blockquote><p>org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type ‘com.atguigu.spring6.bean.HelloWorld’ available: expected single matching bean but found 2: helloworldOne,helloworldTwo</p></blockquote><h5 id="⑤扩展知识"><a href="#⑤扩展知识" class="headerlink" title="⑤扩展知识"></a>⑤扩展知识</h5><p>如果组件类实现了接口，根据接口类型可以获取 bean 吗？</p><blockquote><p>可以，前提是bean唯一</p></blockquote><p>如果一个接口有多个实现类，这些实现类都配置了 bean，根据接口类型可以获取 bean 吗？</p><blockquote><p>不行，因为bean不唯一</p></blockquote><p><strong>结论</strong></p><p>根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 <strong>instanceof</strong> 指定的类型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。</p><p>java中，instanceof运算符用于判断前面的对象是否是后面的类，或其子类、实现类的实例。如果是返回true，否则返回false。也就是说：用instanceof关键字做判断时， instanceof 操作符的左右操作必须有继承或实现关系</p><h4 id="3-2-3、实验二：依赖注入之setter注入"><a href="#3-2-3、实验二：依赖注入之setter注入" class="headerlink" title="3.2.3、实验二：依赖注入之setter注入"></a>3.2.3、实验二：依赖注入之setter注入</h4><p><strong>①创建学生类Student</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②配置bean时为属性赋值</strong></p><p>spring-di.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- property标签：通过组件类的setXxx()方法给组件对象设置属性 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name属性：指定属性名（这个属性名是getXxx()、setXxx()方法定义的，和成员变量无关） --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- value属性：指定属性值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1001&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>③测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDIBySet</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-di.xml&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">studentOne</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;studentOne&quot;</span>, Student.class);</span><br><span class="line">    System.out.println(studentOne);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-4、实验三：依赖注入之构造器注入"><a href="#3-2-4、实验三：依赖注入之构造器注入" class="headerlink" title="3.2.4、实验三：依赖注入之构造器注入"></a>3.2.4、实验三：依赖注入之构造器注入</h4><p><strong>①在Student类中添加有参构造</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(Integer id, String name, Integer age, String sex)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②配置bean</strong></p><p>spring-di.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentTwo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;1002&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;李四&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;33&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>constructor-arg标签还有两个属性可以进一步描述构造器参数：</p><ul><li>index属性：指定参数所在位置的索引（从0开始）</li><li>name属性：指定参数名</li></ul></blockquote><p><strong>③测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDIByConstructor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-di.xml&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">studentOne</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;studentTwo&quot;</span>, Student.class);</span><br><span class="line">    System.out.println(studentOne);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-5、实验四：特殊值处理"><a href="#3-2-5、实验四：特殊值处理" class="headerlink" title="3.2.5、实验四：特殊值处理"></a>3.2.5、实验四：特殊值处理</h4><h5 id="①字面量赋值"><a href="#①字面量赋值" class="headerlink" title="①字面量赋值"></a>①字面量赋值</h5><blockquote><p>什么是字面量？</p><p>int a = 10;</p><p>声明一个变量a，初始化为10，此时a就不代表字母a了，而是作为一个变量的名字。当我们引用a的时候，我们实际上拿到的值是10。</p><p>而如果a是带引号的：’a’，那么它现在不是一个变量，它就是代表a这个字母本身，这就是字面量。所以字面量没有引申含义，就是我们看到的这个数据本身。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用value属性给bean的属性赋值时，Spring会把value属性的值看做字面量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="②null值"><a href="#②null值" class="headerlink" title="②null值"></a>②null值</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">null</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;null&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上写法，为name所赋的值是字符串null</p></blockquote><h5 id="③xml实体"><a href="#③xml实体" class="headerlink" title="③xml实体"></a>③xml实体</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 小于号在XML文档中用来定义标签的开始，不能随便使用 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 解决方案一：使用XML实体来代替 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;expression&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a <span class="symbol">&amp;lt;</span> b&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="④CDATA节"><a href="#④CDATA节" class="headerlink" title="④CDATA节"></a>④CDATA节</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;expression&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 解决方案二：使用CDATA节 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 所以CDATA节中写什么符号都随意 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>&lt;![CDATA[a &lt; b]]&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-6、实验五：为对象类型属性赋值"><a href="#3-2-6、实验五：为对象类型属性赋值" class="headerlink" title="3.2.6、实验五：为对象类型属性赋值"></a>3.2.6、实验五：为对象类型属性赋值</h4><p><strong>①创建班级类Clazz</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.bean</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Clazz</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer clazzId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String clazzName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getClazzId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> clazzId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClazzId</span><span class="params">(Integer clazzId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clazzId = clazzId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getClazzName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> clazzName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClazzName</span><span class="params">(String clazzName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clazzName = clazzName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Clazz&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;clazzId=&quot;</span> + clazzId +</span><br><span class="line">                <span class="string">&quot;, clazzName=&#x27;&quot;</span> + clazzName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Clazz</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Clazz</span><span class="params">(Integer clazzId, String clazzName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clazzId = clazzId;</span><br><span class="line">        <span class="built_in">this</span>.clazzName = clazzName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②修改Student类</strong></p><p>在Student类中添加以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Clazz clazz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Clazz <span class="title function_">getClazz</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClazz</span><span class="params">(Clazz clazz)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.clazz = clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式一：引用外部bean"><a href="#方式一：引用外部bean" class="headerlink" title="方式一：引用外部bean"></a>方式一：引用外部bean</h5><p>配置Clazz类型的bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clazzOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.Clazz&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clazzId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1111&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clazzName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;财源滚滚班&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为Student中的clazz属性赋值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentFour&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1004&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;赵六&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;26&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clazz&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;clazzOne&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>错误演示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentFour&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1004&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;赵六&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;26&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clazz&quot;</span> <span class="attr">value</span>=<span class="string">&quot;clazzOne&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果错把ref属性写成了value属性，会抛出异常： Caused by: java.lang.IllegalStateException: Cannot convert value of type ‘java.lang.String’ to required type ‘com.atguigu.spring6.bean.Clazz’ for property ‘clazz’: no matching editors or conversion strategy found </p><p>意思是不能把String类型转换成我们要的Clazz类型，说明我们使用value属性时，Spring只把这个属性看做一个普通的字符串，不会认为这是一个bean的id，更不会根据它去找到bean来赋值</p></blockquote><h5 id="方式二：内部bean"><a href="#方式二：内部bean" class="headerlink" title="方式二：内部bean"></a>方式二：内部bean</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentFour&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1004&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;赵六&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;26&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clazz&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在一个bean中再声明一个bean就是内部bean --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 内部bean只能用于给属性赋值，不能在外部通过IOC容器获取，因此可以省略id属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clazzInner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.Clazz&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clazzId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2222&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clazzName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;远大前程班&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="方式三：级联属性赋值"><a href="#方式三：级联属性赋值" class="headerlink" title="方式三：级联属性赋值"></a>方式三：级联属性赋值</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentFour&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1004&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;赵六&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;26&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clazz&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;clazzOne&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clazz.clazzId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3333&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clazz.clazzName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;最强王者班&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-7、实验六：为数组类型属性赋值"><a href="#3-2-7、实验六：为数组类型属性赋值" class="headerlink" title="3.2.7、实验六：为数组类型属性赋值"></a>3.2.7、实验六：为数组类型属性赋值</h4><p><strong>①修改Student类</strong></p><p>在Student类中添加以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String[] hobbies;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String[] getHobbies() &#123;</span><br><span class="line">    <span class="keyword">return</span> hobbies;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHobbies</span><span class="params">(String[] hobbies)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.hobbies = hobbies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②配置bean</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentFour&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring.bean6.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1004&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;赵六&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;26&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clazz&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;clazzOne&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>抽烟<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>喝酒<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>烫头<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-8、实验七：为集合类型属性赋值"><a href="#3-2-8、实验七：为集合类型属性赋值" class="headerlink" title="3.2.8、实验七：为集合类型属性赋值"></a>3.2.8、实验七：为集合类型属性赋值</h4><h5 id="①为List集合类型属性赋值"><a href="#①为List集合类型属性赋值" class="headerlink" title="①为List集合类型属性赋值"></a>①为List集合类型属性赋值</h5><p>在Clazz类中添加以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Student&gt; students;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudents</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> students;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStudents</span><span class="params">(List&lt;Student&gt; students)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.students = students;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clazzTwo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.Clazz&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clazzId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;4444&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clazzName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Javaee0222&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;students&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;studentOne&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;studentTwo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;studentThree&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>若为Set集合类型属性赋值，只需要将其中的list标签改为set标签即可</p></blockquote><h5 id="②为Map集合类型属性赋值"><a href="#②为Map集合类型属性赋值" class="headerlink" title="②为Map集合类型属性赋值"></a>②为Map集合类型属性赋值</h5><p>创建教师类Teacher：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.bean;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer teacherId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String teacherName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getTeacherId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> teacherId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTeacherId</span><span class="params">(Integer teacherId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.teacherId = teacherId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTeacherName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> teacherName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTeacherName</span><span class="params">(String teacherName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.teacherName = teacherName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(Integer teacherId, String teacherName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.teacherId = teacherId;</span><br><span class="line">        <span class="built_in">this</span>.teacherName = teacherName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Teacher&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;teacherId=&quot;</span> + teacherId +</span><br><span class="line">                <span class="string">&quot;, teacherName=&#x27;&quot;</span> + teacherName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Student类中添加以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Teacher&gt; teacherMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, Teacher&gt; <span class="title function_">getTeacherMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> teacherMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTeacherMap</span><span class="params">(Map&lt;String, Teacher&gt; teacherMap)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.teacherMap = teacherMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;teacherOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.Teacher&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;teacherId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10010&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;teacherName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;大宝&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;teacherTwo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.Teacher&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;teacherId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10086&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;teacherName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;二宝&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentFour&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1004&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;赵六&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;26&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clazz&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;clazzOne&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>抽烟<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>喝酒<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>烫头<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;teacherMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>10010<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;teacherOne&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>10086<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;teacherTwo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="③引用集合类型的bean"><a href="#③引用集合类型的bean" class="headerlink" title="③引用集合类型的bean"></a>③引用集合类型的bean</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--list集合类型的bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;students&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;studentOne&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;studentTwo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;studentThree&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--map集合类型的bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:map</span> <span class="attr">id</span>=<span class="string">&quot;teacherMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>10010<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;teacherOne&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>10086<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;teacherTwo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clazzTwo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.Clazz&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clazzId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;4444&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clazzName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Javaee0222&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;students&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentFour&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1004&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;赵六&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;26&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;clazz&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;clazzOne&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>抽烟<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>喝酒<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>烫头<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;teacherMap&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;teacherMap&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用util:list、util:map标签必须引入相应的命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/util</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/util/spring-util.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="3-2-9、实验八：p命名空间"><a href="#3-2-9、实验八：p命名空间" class="headerlink" title="3.2.9、实验八：p命名空间"></a>3.2.9、实验八：p命名空间</h4><p>引入p命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/util</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/util/spring-util.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入p命名空间后，可以通过以下方式为bean的各个属性赋值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentSix&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.Student&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">p:id</span>=<span class="string">&quot;1006&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;小明&quot;</span> <span class="attr">p:clazz-ref</span>=<span class="string">&quot;clazzOne&quot;</span> <span class="attr">p:teacherMap-ref</span>=<span class="string">&quot;teacherMap&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-10、实验九：引入外部属性文件"><a href="#3-2-10、实验九：引入外部属性文件" class="headerlink" title="3.2.10、实验九：引入外部属性文件"></a>3.2.10、实验九：引入外部属性文件</h4><p><strong>①加入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>②创建外部属性文件</strong></p><p><img src="https://s2.loli.net/2023/10/10/Cg6LzPi3oJDfy1u.png" alt="images"></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">atguigu</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC</span></span><br><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p><strong>③引入属性文件</strong></p><p>引入context 名称空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入外部属性文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>注意：在使用 <a href="context:property-placeholder">context:property-placeholder</a> 元素加载外包配置文件功能前，首先需要在 XML 配置的一级标签 <beans> 中添加 context 相关的约束。</p><p><strong>④配置bean</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;druidDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.user&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>⑤测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-datasource.xml&quot;</span>);</span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> ac.getBean(DataSource.class);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">    System.out.println(connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-11、实验十：bean的作用域"><a href="#3-2-11、实验十：bean的作用域" class="headerlink" title="3.2.11、实验十：bean的作用域"></a>3.2.11、实验十：bean的作用域</h4><p><strong>①概念</strong></p><p>在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表：</p><table><thead><tr><th>取值</th><th>含义</th><th>创建对象的时机</th></tr></thead><tbody><tr><td>singleton（默认）</td><td>在IOC容器中，这个bean的对象始终为单实例</td><td>IOC容器初始化时</td></tr><tr><td>prototype</td><td>这个bean在IOC容器中有多个实例</td><td>获取bean时</td></tr></tbody></table><p>如果是在WebApplicationContext环境下还会有另外几个作用域（但不常用）：</p><table><thead><tr><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>request</td><td>在一个请求范围内有效</td></tr><tr><td>session</td><td>在一个会话范围内有效</td></tr></tbody></table><p><strong>②创建类User</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.bean;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(Integer id, String username, String password, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, password=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>③配置bean</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.User&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>④测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBeanScope</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-scope.xml&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> ac.getBean(User.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> ac.getBean(User.class);</span><br><span class="line">    System.out.println(user1==user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-12、实验十一：bean生命周期"><a href="#3-2-12、实验十一：bean生命周期" class="headerlink" title="3.2.12、实验十一：bean生命周期"></a>3.2.12、实验十一：bean生命周期</h4><p><strong>①具体的生命周期过程</strong></p><ul><li><p>bean对象创建（调用无参构造器）</p></li><li><p>给bean对象设置属性</p></li><li><p>bean的后置处理器（初始化之前）</p></li><li><p>bean对象初始化（需在配置bean时指定初始化方法）</p></li><li><p>bean的后置处理器（初始化之后）</p></li><li><p>bean对象就绪可以使用</p></li><li><p>bean对象销毁（需在配置bean时指定销毁方法）</p></li><li><p>IOC容器关闭</p></li></ul><p><strong>②修改类User</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生命周期：1、创建对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(Integer id, String username, String password, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生命周期：2、依赖注入&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生命周期：3、初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生命周期：5、销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, password=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意其中的initMethod()和destroyMethod()，可以通过配置bean指定为初始化和销毁的方法</p></blockquote><p><strong>③配置bean</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用init-method属性指定初始化方法 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用destroy-method属性指定销毁方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.User&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1001&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;admin&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>④测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLife</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-lifecycle.xml&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">bean</span> <span class="operator">=</span> ac.getBean(User.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;生命周期：4、通过IOC容器获取bean并使用&quot;</span>);</span><br><span class="line">    ac.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>⑤bean的后置处理器</strong></p><p>bean的后置处理器会在生命周期的初始化前后添加额外的操作，需要实现BeanPostProcessor接口，且配置到IOC容器中，需要注意的是，bean后置处理器不是单独针对某一个bean生效，而是针对IOC容器中所有bean都会执行</p><p>创建bean的后置处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.process;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;☆☆☆&quot;</span> + beanName + <span class="string">&quot; = &quot;</span> + bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;★★★&quot;</span> + beanName + <span class="string">&quot; = &quot;</span> + bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在IOC容器中配置后置处理器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bean的后置处理器要放入IOC容器才能生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBeanProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.process.MyBeanProcessor&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-13、实验十二：FactoryBean"><a href="#3-2-13、实验十二：FactoryBean" class="headerlink" title="3.2.13、实验十二：FactoryBean"></a>3.2.13、实验十二：FactoryBean</h4><p><strong>①简介</strong></p><p>FactoryBean是Spring提供的一种整合第三方框架的常用机制。和普通的bean不同，配置一个FactoryBean类型的bean，在获取bean的时候得到的并不是class属性中配置的这个类的对象，而是getObject()方法的返回值。通过这种机制，Spring可以帮我们把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示给我们。</p><p>将来我们整合Mybatis时，Spring就是通过FactoryBean机制来帮我们创建SqlSessionFactory对象的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2002-2020 the original author or authors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      https://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface to be implemented by objects used within a &#123;<span class="doctag">@link</span> BeanFactory&#125; which</span></span><br><span class="line"><span class="comment"> * are themselves factories for individual objects. If a bean implements this</span></span><br><span class="line"><span class="comment"> * interface, it is used as a factory for an object to expose, not directly as a</span></span><br><span class="line"><span class="comment"> * bean instance that will be exposed itself.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;NB: A bean that implements this interface cannot be used as a normal bean.&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * A FactoryBean is defined in a bean style, but the object exposed for bean</span></span><br><span class="line"><span class="comment"> * references (&#123;<span class="doctag">@link</span> #getObject()&#125;) is always the object that it creates.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;FactoryBeans can support singletons and prototypes, and can either create</span></span><br><span class="line"><span class="comment"> * objects lazily on demand or eagerly on startup. The &#123;<span class="doctag">@link</span> SmartFactoryBean&#125;</span></span><br><span class="line"><span class="comment"> * interface allows for exposing more fine-grained behavioral metadata.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This interface is heavily used within the framework itself, for example for</span></span><br><span class="line"><span class="comment"> * the AOP &#123;<span class="doctag">@link</span> org.springframework.aop.framework.ProxyFactoryBean&#125; or the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.jndi.JndiObjectFactoryBean&#125;. It can be used for</span></span><br><span class="line"><span class="comment"> * custom components as well; however, this is only common for infrastructure code.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;&#123;<span class="doctag">@code</span> FactoryBean&#125; is a programmatic contract. Implementations are not</span></span><br><span class="line"><span class="comment"> * supposed to rely on annotation-driven injection or other reflective facilities.&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #getObjectType()&#125; &#123;<span class="doctag">@link</span> #getObject()&#125; invocations may arrive early in the</span></span><br><span class="line"><span class="comment"> * bootstrap process, even ahead of any post-processor setup. If you need access to</span></span><br><span class="line"><span class="comment"> * other beans, implement &#123;<span class="doctag">@link</span> BeanFactoryAware&#125; and obtain them programmatically.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;The container is only responsible for managing the lifecycle of the FactoryBean</span></span><br><span class="line"><span class="comment"> * instance, not the lifecycle of the objects created by the FactoryBean.&lt;/b&gt; Therefore,</span></span><br><span class="line"><span class="comment"> * a destroy method on an exposed bean object (such as &#123;<span class="doctag">@link</span> java.io.Closeable#close()&#125;</span></span><br><span class="line"><span class="comment"> * will &lt;i&gt;not&lt;/i&gt; be called automatically. Instead, a FactoryBean should implement</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> DisposableBean&#125; and delegate any such close call to the underlying object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Finally, FactoryBean objects participate in the containing BeanFactory&#x27;s</span></span><br><span class="line"><span class="comment"> * synchronization of bean creation. There is usually no need for internal</span></span><br><span class="line"><span class="comment"> * synchronization other than for purposes of lazy initialization within the</span></span><br><span class="line"><span class="comment"> * FactoryBean itself (or the like).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 08.03.2003</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the bean type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.BeanFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.aop.framework.ProxyFactoryBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.jndi.JndiObjectFactoryBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The name of an attribute that can be</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> org.springframework.core.AttributeAccessor#setAttribute set&#125; on a</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.BeanDefinition&#125; so that</span></span><br><span class="line"><span class="comment">     * factory beans can signal their object type when it can&#x27;t be deduced from</span></span><br><span class="line"><span class="comment">     * the factory bean class.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 5.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">OBJECT_TYPE_ATTRIBUTE</span> <span class="operator">=</span> <span class="string">&quot;factoryBeanObjectType&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return an instance (possibly shared or independent) of the object</span></span><br><span class="line"><span class="comment">     * managed by this factory.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;As with a &#123;<span class="doctag">@link</span> BeanFactory&#125;, this allows support for both the</span></span><br><span class="line"><span class="comment">     * Singleton and Prototype design pattern.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If this FactoryBean is not fully initialized yet at the time of</span></span><br><span class="line"><span class="comment">     * the call (for example because it is involved in a circular reference),</span></span><br><span class="line"><span class="comment">     * throw a corresponding &#123;<span class="doctag">@link</span> FactoryBeanNotInitializedException&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;As of Spring 2.0, FactoryBeans are allowed to return &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * objects. The factory will consider this as normal value to be used; it</span></span><br><span class="line"><span class="comment">     * will not throw a FactoryBeanNotInitializedException in this case anymore.</span></span><br><span class="line"><span class="comment">     * FactoryBean implementations are encouraged to throw</span></span><br><span class="line"><span class="comment">     * FactoryBeanNotInitializedException themselves now, as appropriate.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an instance of the bean (can be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception in case of creation errors</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> FactoryBeanNotInitializedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the type of object that this FactoryBean creates,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> null&#125; if not known in advance.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This allows one to check for specific types of beans without</span></span><br><span class="line"><span class="comment">     * instantiating objects, for example on autowiring.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;In the case of implementations that are creating a singleton object,</span></span><br><span class="line"><span class="comment">     * this method should try to avoid singleton creation as far as possible;</span></span><br><span class="line"><span class="comment">     * it should rather estimate the type in advance.</span></span><br><span class="line"><span class="comment">     * For prototypes, returning a meaningful type here is advisable too.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method can be called &lt;i&gt;before&lt;/i&gt; this FactoryBean has</span></span><br><span class="line"><span class="comment">     * been fully initialized. It must not rely on state created during</span></span><br><span class="line"><span class="comment">     * initialization; of course, it can still use such state if available.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; Autowiring will simply ignore FactoryBeans that return</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125; here. Therefore it is highly recommended to implement</span></span><br><span class="line"><span class="comment">     * this method properly, using the current state of the FactoryBean.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the type of object that this FactoryBean creates,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> null&#125; if not known at the time of the call</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ListableBeanFactory#getBeansOfType</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Is the object managed by this factory a singleton? That is,</span></span><br><span class="line"><span class="comment">     * will &#123;<span class="doctag">@link</span> #getObject()&#125; always return the same object</span></span><br><span class="line"><span class="comment">     * (a reference that can be cached)?</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; If a FactoryBean indicates to hold a singleton object,</span></span><br><span class="line"><span class="comment">     * the object returned from &#123;<span class="doctag">@code</span> getObject()&#125; might get cached</span></span><br><span class="line"><span class="comment">     * by the owning BeanFactory. Hence, do not return &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">     * unless the FactoryBean always exposes the same reference.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The singleton status of the FactoryBean itself will generally</span></span><br><span class="line"><span class="comment">     * be provided by the owning BeanFactory; usually, it has to be</span></span><br><span class="line"><span class="comment">     * defined as singleton there.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; This method returning &#123;<span class="doctag">@code</span> false&#125; does not</span></span><br><span class="line"><span class="comment">     * necessarily indicate that returned objects are independent instances.</span></span><br><span class="line"><span class="comment">     * An implementation of the extended &#123;<span class="doctag">@link</span> SmartFactoryBean&#125; interface</span></span><br><span class="line"><span class="comment">     * may explicitly indicate independent instances through its</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> SmartFactoryBean#isPrototype()&#125; method. Plain &#123;<span class="doctag">@link</span> FactoryBean&#125;</span></span><br><span class="line"><span class="comment">     * implementations which do not implement this extended interface are</span></span><br><span class="line"><span class="comment">     * simply assumed to always return independent instances if the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> isSingleton()&#125; implementation returns &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The default implementation returns &#123;<span class="doctag">@code</span> true&#125;, since a</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> FactoryBean&#125; typically manages a singleton instance.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> whether the exposed object is a singleton</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getObject()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> SmartFactoryBean#isPrototype()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②创建类UserFactoryBean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.bean;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> User.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>③配置bean</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.bean.UserFactoryBean&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>④测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUserFactoryBean</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//获取IOC容器</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-factorybean.xml&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) ac.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-14、实验十三：基于xml自动装配"><a href="#3-2-14、实验十三：基于xml自动装配" class="headerlink" title="3.2.14、实验十三：基于xml自动装配"></a>3.2.14、实验十三：基于xml自动装配</h4><blockquote><p>自动装配：</p><p>根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型属性赋值</p></blockquote><p><strong>①场景模拟</strong></p><p>创建类UserController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.autowire.controller</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserService</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">()</span>&#123;</span><br><span class="line">        userService.saveUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建接口UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.autowire.service</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建类UserServiceImpl实现接口UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.autowire.service.impl</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.saveUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建接口UserDao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.autowire.dao</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建类UserDaoImpl实现接口UserDao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.autowire.dao.impl</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②配置bean</strong></p><blockquote><p>使用bean标签的autowire属性设置自动装配效果</p><p>自动装配方式：byType</p><p>byType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值</p><p>若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值null</p><p>若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常NoUniqueBeanDefinitionException</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userController&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.autowire.controller.UserController&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.autowire.service.impl.UserServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.autowire.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>自动装配方式：byName</p><p>byName：将自动装配的属性的属性名，作为bean的id在IOC容器中匹配相对应的bean进行赋值</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userController&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.autowire.controller.UserController&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.autowire.service.impl.UserServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.autowire.service.impl.UserServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.autowire.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.autowire.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>③测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAutoWireByXML</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;autowire-xml.xml&quot;</span>);</span><br><span class="line">    <span class="type">UserController</span> <span class="variable">userController</span> <span class="operator">=</span> ac.getBean(UserController.class);</span><br><span class="line">    userController.saveUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3、基于注解管理Bean（☆）"><a href="#3-3、基于注解管理Bean（☆）" class="headerlink" title="3.3、基于注解管理Bean（☆）"></a>3.3、基于注解管理Bean（☆）</h3><p>从 Java 5 开始，Java 增加了对注解（Annotation）的支持，它是代码中的一种特殊标记，可以在编译、类加载和运行时被读取，执行相应的处理。开发人员可以通过注解在不改变原有代码和逻辑的情况下，在源代码中嵌入补充信息。</p><p>Spring 从 2.5 版本开始提供了对注解技术的全面支持，我们可以使用注解来实现自动装配，简化 Spring 的 XML 配置。</p><p>Spring 通过注解实现自动装配的步骤如下：</p><ol><li>引入依赖</li><li>开启组件扫描</li><li>使用注解定义 Bean</li><li>依赖注入</li></ol><h4 id="3-3-1、搭建子模块spring6-ioc-annotation"><a href="#3-3-1、搭建子模块spring6-ioc-annotation" class="headerlink" title="3.3.1、搭建子模块spring6-ioc-annotation"></a>3.3.1、搭建子模块spring6-ioc-annotation</h4><p><strong>①搭建模块</strong></p><p>搭建方式如：spring6-ioc-xml</p><p><strong>②引入配置文件</strong></p><p>引入spring-ioc-xml模块日志log4j2.xml</p><p><strong>③添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring context依赖--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--junit5测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--log4j2的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j2-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-2、开启组件扫描"><a href="#3-3-2、开启组件扫描" class="headerlink" title="3.3.2、开启组件扫描"></a>3.3.2、开启组件扫描</h4><p>Spring 默认不使用注解装配 Bean，因此我们需要在 Spring 的 XML 配置中，通过 <a href="context:component-scan">context:component-scan</a> 元素开启 Spring Beans的自动扫描功能。开启此功能后，Spring 会自动从扫描指定的包（base-package 属性设置）及其子包下的所有类，如果类上使用了 @Component 注解，就将该类装配到容器中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描功能--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.spring6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：在使用 <a href="context:component-scan">context:component-scan</a> 元素开启自动扫描功能前，首先需要在 XML 配置的一级标签 <beans> 中添加 context 相关的约束。</p><p><strong>情况一：最基本的扫描方式</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.spring6&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>情况二：指定要排除的组件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.spring6&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- context:exclude-filter标签：指定排除规则 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> type：设置排除或包含的依据</span></span><br><span class="line"><span class="comment">type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名</span></span><br><span class="line"><span class="comment">type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;context:exclude-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.spring6.controller.UserController&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>情况三：仅扫描指定组件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 此时必须设置use-default-filters=&quot;false&quot;，因为默认规则即扫描指定包下所有类 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> type：设置排除或包含的依据</span></span><br><span class="line"><span class="comment">type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名</span></span><br><span class="line"><span class="comment">type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;context:include-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.spring6.controller.UserController&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-3、使用注解定义-Bean"><a href="#3-3-3、使用注解定义-Bean" class="headerlink" title="3.3.3、使用注解定义 Bean"></a>3.3.3、使用注解定义 Bean</h4><p>Spring 提供了以下多个注解，这些注解可以直接标注在 Java 类上，将它们定义成 Spring Bean。</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Component</td><td>该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。  使用时只需将该注解标注在相应类上即可。</td></tr><tr><td>@Repository</td><td>该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td></tr><tr><td>@Service</td><td>该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td></tr><tr><td>@Controller</td><td>该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td></tr></tbody></table><h4 id="3-3-4、实验一：-Autowired注入"><a href="#3-3-4、实验一：-Autowired注入" class="headerlink" title="3.3.4、实验一：@Autowired注入"></a>3.3.4、实验一：@Autowired注入</h4><p>单独使用@Autowired注解，<strong>默认根据类型装配</strong>。【默认是byType】</p><p>查看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中有两处需要注意：</p><ul><li><p>第一处：该注解可以标注在哪里？</p></li><li><ul><li>构造方法上</li><li>方法上</li><li>形参上</li><li>属性上</li><li>注解上</li></ul></li><li><p>第二处：该注解有一个required属性，默认值是true，表示在注入的时候要求被注入的Bean必须是存在的，如果不存在则报错。如果required属性设置为false，表示注入的Bean存在或者不存在都没关系，存在的话就注入，不存在的话，也不报错。</p></li></ul><h5 id="①场景一：属性注入"><a href="#①场景一：属性注入" class="headerlink" title="①场景一：属性注入"></a>①场景一：属性注入</h5><p>创建UserDao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建UserDaoImpl实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao层执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建UserService接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建UserServiceImpl实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.print();</span><br><span class="line">        System.out.println(<span class="string">&quot;Service层执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建UserController类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        userService.out();</span><br><span class="line">        System.out.println(<span class="string">&quot;Controller层执行结束。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试一</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.controller.UserController;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(UserTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAnnotation</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;Beans.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserController</span> <span class="variable">userController</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userController&quot;</span>, UserController.class);</span><br><span class="line">        userController.out();</span><br><span class="line">        logger.info(<span class="string">&quot;执行成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="https://s2.loli.net/2023/10/10/VBLD3qUGu4rKWfC.png" alt="image-20221101153556681"></p><p>以上构造方法和setter方法都没有提供，经过测试，仍然可以注入成功。</p><h5 id="②场景二：set注入"><a href="#②场景二：set注入" class="headerlink" title="②场景二：set注入"></a>②场景二：set注入</h5><p>修改UserServiceImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.print();</span><br><span class="line">        System.out.println(<span class="string">&quot;Service层执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改UserController类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserService</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        userService.out();</span><br><span class="line">        System.out.println(<span class="string">&quot;Controller层执行结束。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：成功调用</p><h5 id="③场景三：构造方法注入"><a href="#③场景三：构造方法注入" class="headerlink" title="③场景三：构造方法注入"></a>③场景三：构造方法注入</h5><p>修改UserServiceImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.print();</span><br><span class="line">        System.out.println(<span class="string">&quot;Service层执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改UserController类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        userService.out();</span><br><span class="line">        System.out.println(<span class="string">&quot;Controller层执行结束。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：成功调用</p><h5 id="④场景四：形参上注入"><a href="#④场景四：形参上注入" class="headerlink" title="④场景四：形参上注入"></a>④场景四：形参上注入</h5><p>修改UserServiceImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(<span class="meta">@Autowired</span> UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.print();</span><br><span class="line">        System.out.println(<span class="string">&quot;Service层执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改UserController类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(<span class="meta">@Autowired</span> UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        userService.out();</span><br><span class="line">        System.out.println(<span class="string">&quot;Controller层执行结束。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：成功调用</p><h5 id="⑤场景五：只有一个构造函数，无注解"><a href="#⑤场景五：只有一个构造函数，无注解" class="headerlink" title="⑤场景五：只有一个构造函数，无注解"></a>⑤场景五：只有一个构造函数，无注解</h5><p>修改UserServiceImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.print();</span><br><span class="line">        System.out.println(<span class="string">&quot;Service层执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试通过</p><p><strong>当有参数的构造方法只有一个时，@Autowired注解可以省略。</strong></p><p>说明：有多个构造方法时呢？大家可以测试（再添加一个无参构造函数），测试报错</p><h5 id="⑥场景六：-Autowired注解和-Qualifier注解联合"><a href="#⑥场景六：-Autowired注解和-Qualifier注解联合" class="headerlink" title="⑥场景六：@Autowired注解和@Qualifier注解联合"></a>⑥场景六：@Autowired注解和@Qualifier注解联合</h5><p>添加dao层实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoRedisImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Redis Dao层执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：测试异常</p><p>错误信息中说：不能装配，UserDao这个Bean的数量等于2</p><p>怎么解决这个问题呢？<strong>当然要byName，根据名称进行装配了。</strong></p><p>修改UserServiceImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userDaoImpl&quot;)</span> <span class="comment">// 指定bean的名字</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.print();</span><br><span class="line">        System.out.println(<span class="string">&quot;Service层执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>@Autowired注解可以出现在：属性上、构造方法上、构造方法的参数上、setter方法上。</li><li>当带参数的构造方法只有一个，@Autowired注解可以省略。（）</li><li>@Autowired注解默认根据类型注入。如果要根据名称注入的话，需要配合@Qualifier注解一起使用。</li></ul><h4 id="3-3-5、实验二：-Resource注入"><a href="#3-3-5、实验二：-Resource注入" class="headerlink" title="3.3.5、实验二：@Resource注入"></a>3.3.5、实验二：@Resource注入</h4><p>@Resource注解也可以完成属性注入。那它和@Autowired注解有什么区别？</p><ul><li>@Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。)</li><li>@Autowired注解是Spring框架自己的。</li><li><strong>@Resource注解默认根据名称装配byName，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型byType装配。</strong></li><li><strong>@Autowired注解默认根据类型装配byType，如果想根据名称装配，需要配合@Qualifier注解一起用。</strong></li><li>@Resource注解用在属性上、setter方法上。</li><li>@Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。</li></ul><p>@Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：【<strong>如果是JDK8的话不需要额外引入依赖。高于JDK11或低于JDK8需要引入以下依赖。</strong>】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jakarta.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Repeatable;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Repeatable(Resources.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Resource &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">lookup</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; type() <span class="keyword">default</span> Object.class;</span><br><span class="line"></span><br><span class="line">    Resource.AuthenticationType <span class="title function_">authenticationType</span><span class="params">()</span> <span class="keyword">default</span> Resource.AuthenticationType.CONTAINER;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">shareable</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">mappedName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">description</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">AuthenticationType</span> &#123;</span><br><span class="line">        CONTAINER,</span><br><span class="line">        APPLICATION;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">AuthenticationType</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="①场景一：根据name注入"><a href="#①场景一：根据name注入" class="headerlink" title="①场景一：根据name注入"></a>①场景一：根据name注入</h5><p>修改UserDaoImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository(&quot;myUserDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao层执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改UserServiceImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.service.UserService;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = &quot;myUserDao&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao myUserDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        myUserDao.print();</span><br><span class="line">        System.out.println(<span class="string">&quot;Service层执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试通过</p><h5 id="②场景二：name未知注入"><a href="#②场景二：name未知注入" class="headerlink" title="②场景二：name未知注入"></a>②场景二：name未知注入</h5><p>修改UserDaoImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository(&quot;myUserDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao层执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改UserServiceImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.service.UserService;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserDao myUserDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        myUserDao.print();</span><br><span class="line">        System.out.println(<span class="string">&quot;Service层执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试通过</p><p>当@Resource注解使用时没有指定name的时候，还是根据name进行查找，这个name是属性名。</p><h5 id="③场景三-其他情况"><a href="#③场景三-其他情况" class="headerlink" title="③场景三 其他情况"></a>③场景三 其他情况</h5><p>修改UserServiceImpl类，userDao1属性名不存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.service.UserService;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao1.print();</span><br><span class="line">        System.out.println(<span class="string">&quot;Service层执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试异常</p><p>根据异常信息得知：显然当通过name找不到的时候，自然会启动byType进行注入，以上的错误是因为UserDao接口下有两个实现类导致的。所以根据类型注入就会报错。</p><p>@Resource的set注入可以自行测试</p><p><strong>总结：</strong></p><p>@Resource注解：默认byName注入，没有指定name时把属性名当做name，根据name找不到时，才会byType注入。byType注入时，某种类型的Bean只能有一个</p><h4 id="3-3-6、Spring全注解开发"><a href="#3-3-6、Spring全注解开发" class="headerlink" title="3.3.6、Spring全注解开发"></a>3.3.6、Spring全注解开发</h4><p>全注解开发就是不再使用spring配置文件了，写一个配置类来代替配置文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//@ComponentScan(&#123;&quot;com.atguigu.spring6.controller&quot;, &quot;com.atguigu.spring6.service&quot;,&quot;com.atguigu.spring6.dao&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.spring6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Spring6Config</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAllAnnotation</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Spring6Config.class);</span><br><span class="line">    <span class="type">UserController</span> <span class="variable">userController</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userController&quot;</span>, UserController.class);</span><br><span class="line">    userController.out();</span><br><span class="line">    logger.info(<span class="string">&quot;执行成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、原理-手写IoC"><a href="#4、原理-手写IoC" class="headerlink" title="4、原理-手写IoC"></a>4、原理-手写IoC</h2><p>我们都知道，Spring框架的IOC是基于Java反射机制实现的，下面我们先回顾一下java反射。</p><h3 id="4-1、回顾Java反射"><a href="#4-1、回顾Java反射" class="headerlink" title="4.1、回顾Java反射"></a>4.1、回顾Java反射</h3><p><code>Java</code>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为<code>Java</code>语言的反射机制。简单来说，反射机制指的是程序在运行时能够获取自身的信息。</p><p>要想解剖一个类，必须先要<strong>获取到该类的Class对象</strong>。而剖析一个类或用反射解决具体的问题就是使用相关API<strong>（1）java.lang.Class（2）java.lang.reflect</strong>，所以，<strong>Class对象是反射的根源</strong>。</p><p><strong>自定义类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无参数构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参数构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(String name, <span class="type">int</span> age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有方法-run.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get和set方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Car&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编写测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCar</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、获取Class对象多种方式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1 类名.class</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Car.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2 对象.getClass()</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>().getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3 Class.forName(&quot;全路径&quot;)</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.reflect.Car&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化</span></span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> (Car)clazz3.getConstructor().newInstance();</span><br><span class="line">        System.out.println(car);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、获取构造方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Car.class;</span><br><span class="line">        <span class="comment">//获取所有构造</span></span><br><span class="line">        <span class="comment">// getConstructors()获取所有public的构造方法</span></span><br><span class="line"><span class="comment">//        Constructor[] constructors = clazz.getConstructors();</span></span><br><span class="line">        <span class="comment">// getDeclaredConstructors()获取所有的构造方法public  private</span></span><br><span class="line">        Constructor[] constructors = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c:constructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;方法名称：&quot;</span>+c.getName()+<span class="string">&quot; 参数个数：&quot;</span>+c.getParameterCount());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定有参数构造创建对象</span></span><br><span class="line">        <span class="comment">//1 构造public</span></span><br><span class="line"><span class="comment">//        Constructor c1 = clazz.getConstructor(String.class, int.class, String.class);</span></span><br><span class="line"><span class="comment">//        Car car1 = (Car)c1.newInstance(&quot;夏利&quot;, 10, &quot;红色&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(car1);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2 构造private</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">c2</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class, String.class);</span><br><span class="line">        c2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car2</span> <span class="operator">=</span> (Car)c2.newInstance(<span class="string">&quot;捷达&quot;</span>, <span class="number">15</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line">        System.out.println(car2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、获取属性</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Car.class;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> (Car)clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">        <span class="comment">//获取所有public属性</span></span><br><span class="line">        <span class="comment">//Field[] fields = clazz.getFields();</span></span><br><span class="line">        <span class="comment">//获取所有属性（包含私有属性）</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field:fields) &#123;</span><br><span class="line">            <span class="keyword">if</span>(field.getName().equals(<span class="string">&quot;name&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//设置允许访问</span></span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                field.set(car,<span class="string">&quot;五菱宏光&quot;</span>);</span><br><span class="line">                System.out.println(car);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(field.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、获取方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;奔驰&quot;</span>,<span class="number">10</span>,<span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> car.getClass();</span><br><span class="line">        <span class="comment">//1 public方法</span></span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m1:methods) &#123;</span><br><span class="line">            <span class="comment">//System.out.println(m1.getName());</span></span><br><span class="line">            <span class="comment">//执行方法 toString</span></span><br><span class="line">            <span class="keyword">if</span>(m1.getName().equals(<span class="string">&quot;toString&quot;</span>)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">invoke</span> <span class="operator">=</span> (String)m1.invoke(car);</span><br><span class="line">                <span class="comment">//System.out.println(&quot;toString执行了：&quot;+invoke);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2 private方法</span></span><br><span class="line">        Method[] methodsAll = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m:methodsAll) &#123;</span><br><span class="line">            <span class="comment">//执行方法 run</span></span><br><span class="line">            <span class="keyword">if</span>(m.getName().equals(<span class="string">&quot;run&quot;</span>)) &#123;</span><br><span class="line">                m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                m.invoke(car);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2、实现Spring的IoC"><a href="#4-2、实现Spring的IoC" class="headerlink" title="4.2、实现Spring的IoC"></a>4.2、实现Spring的IoC</h3><p>我们知道，IoC（控制反转）和DI（依赖注入）是Spring里面核心的东西，那么，我们如何自己手写出这样的代码呢？下面我们就一步一步写出Spring框架最核心的部分。</p><p><strong>①搭建子模块</strong></p><p>搭建模块：guigu-spring，搭建方式如其他spring子模块</p><p><strong>②准备测试需要的bean</strong></p><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--junit5测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建UserDao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.test.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建UserDaoImpl实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.test.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.dao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao层执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建UserService接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.test.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建UserServiceImpl实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring.test.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.core.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private UserDao userDao;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//userDao.print();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Service层执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>③定义注解</strong></p><p>我们通过注解的形式加载bean与实现依赖注入</p><p>bean注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring.core.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bean &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖注入注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring.core.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Di &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：上面两个注解可以随意取名</p><p><strong>④定义bean容器接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(Class clazz)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>⑤编写注解bean容器接口实现</strong></p><p>AnnotationApplicationContext基于注解扫描bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储bean的容器</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Class, Object&gt; beanFactory = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(Class clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory.get(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据包扫描加载bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> basePackage</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnnotationApplicationContext</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>⑥编写扫描bean逻辑</strong></p><p>我们通过构造方法传入包的base路径，扫描被@Bean注解的java对象，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.core.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储bean的容器</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Class, Object&gt; beanFactory = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String rootPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(Class clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory.get(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据包扫描加载bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> basePackage</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnnotationApplicationContext</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">packageDirName</span> <span class="operator">=</span> basePackage.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;\\\\&quot;</span>);</span><br><span class="line">            Enumeration&lt;URL&gt; dirs =Thread.currentThread().getContextClassLoader().getResources(packageDirName);</span><br><span class="line">            <span class="keyword">while</span> (dirs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> dirs.nextElement();</span><br><span class="line">                <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> URLDecoder.decode(url.getFile(),<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                rootPath = filePath.substring(<span class="number">0</span>, filePath.length()-packageDirName.length());</span><br><span class="line">                loadBean(<span class="keyword">new</span> <span class="title class_">File</span>(filePath));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">void</span> <span class="title function_">loadBean</span><span class="params">(File fileParent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fileParent.isDirectory()) &#123;</span><br><span class="line">            File[] childrenFiles = fileParent.listFiles();</span><br><span class="line">            <span class="keyword">if</span>(childrenFiles == <span class="literal">null</span> || childrenFiles.length == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (File child : childrenFiles) &#123;</span><br><span class="line">                <span class="keyword">if</span> (child.isDirectory()) &#123;</span><br><span class="line">                    <span class="comment">//如果是个文件夹就继续调用该方法,使用了递归</span></span><br><span class="line">                    loadBean(child);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//通过文件路径转变成全类名,第一步把绝对路径部分去掉</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">pathWithClass</span> <span class="operator">=</span> child.getAbsolutePath().substring(rootPath.length() - <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">//选中class文件</span></span><br><span class="line">                    <span class="keyword">if</span> (pathWithClass.contains(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">                        <span class="comment">//    com.xinzhi.dao.UserDao</span></span><br><span class="line">                        <span class="comment">//去掉.class后缀，并且把 \ 替换成 .</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> pathWithClass.replaceAll(<span class="string">&quot;\\\\&quot;</span>, <span class="string">&quot;.&quot;</span>).replace(<span class="string">&quot;.class&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Class&lt;?&gt; aClass = Class.forName(fullName);</span><br><span class="line">                            <span class="comment">//把非接口的类实例化放在map中</span></span><br><span class="line">                            <span class="keyword">if</span>(!aClass.isInterface())&#123;</span><br><span class="line">                                <span class="type">Bean</span> <span class="variable">annotation</span> <span class="operator">=</span> aClass.getAnnotation(Bean.class);</span><br><span class="line">                                <span class="keyword">if</span>(annotation != <span class="literal">null</span>)&#123;</span><br><span class="line">                                    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">                                    <span class="comment">//判断一下有没有接口</span></span><br><span class="line">                                    <span class="keyword">if</span>(aClass.getInterfaces().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                        <span class="comment">//如果有接口把接口的class当成key，实例对象当成value</span></span><br><span class="line">                                        System.out.println(<span class="string">&quot;正在加载【&quot;</span>+ aClass.getInterfaces()[<span class="number">0</span>] +<span class="string">&quot;】,实例对象是：&quot;</span> + instance.getClass().getName());</span><br><span class="line">                                        beanFactory.put(aClass.getInterfaces()[<span class="number">0</span>], instance);</span><br><span class="line">                                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                        <span class="comment">//如果有接口把自己的class当成key，实例对象当成value</span></span><br><span class="line">                                        System.out.println(<span class="string">&quot;正在加载【&quot;</span>+ aClass.getName() +<span class="string">&quot;】,实例对象是：&quot;</span> + instance.getClass().getName());</span><br><span class="line">                                        beanFactory.put(aClass, instance);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>⑦java类标识Bean注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> </span><br></pre></td></tr></table></figure><p><strong>⑧测试Bean加载</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.core.AnnotationApplicationContext;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.core.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.test.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringIocTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testIoc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationApplicationContext</span>(<span class="string">&quot;com.atguigu.spring.test&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService)applicationContext.getBean(UserService.class);</span><br><span class="line">        userService.out();</span><br><span class="line">        System.out.println(<span class="string">&quot;run success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台打印测试</p><p><strong>⑨依赖注入</strong></p><p>只要userDao.print();调用成功，说明就注入成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring.test.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.core.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.core.annotation.Di;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Di</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.print();</span><br><span class="line">        System.out.println(<span class="string">&quot;Service层执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行第八步：报错了，说明当前userDao是个空对象</p><p><strong>⑩依赖注入实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.core.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring.core.annotation.Di;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储bean的容器</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Class, Object&gt; beanFactory = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String rootPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(Class clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory.get(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据包扫描加载bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> basePackage</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnnotationApplicationContext</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">packageDirName</span> <span class="operator">=</span> basePackage.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;\\\\&quot;</span>);</span><br><span class="line">            Enumeration&lt;URL&gt; dirs =Thread.currentThread().getContextClassLoader().getResources(packageDirName);</span><br><span class="line">            <span class="keyword">while</span> (dirs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> dirs.nextElement();</span><br><span class="line">                <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> URLDecoder.decode(url.getFile(),<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                rootPath = filePath.substring(<span class="number">0</span>, filePath.length()-packageDirName.length());</span><br><span class="line">                loadBean(<span class="keyword">new</span> <span class="title class_">File</span>(filePath));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//依赖注入</span></span><br><span class="line">        loadDi();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">void</span> <span class="title function_">loadBean</span><span class="params">(File fileParent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fileParent.isDirectory()) &#123;</span><br><span class="line">            File[] childrenFiles = fileParent.listFiles();</span><br><span class="line">            <span class="keyword">if</span>(childrenFiles == <span class="literal">null</span> || childrenFiles.length == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (File child : childrenFiles) &#123;</span><br><span class="line">                <span class="keyword">if</span> (child.isDirectory()) &#123;</span><br><span class="line">                    <span class="comment">//如果是个文件夹就继续调用该方法,使用了递归</span></span><br><span class="line">                    loadBean(child);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//通过文件路径转变成全类名,第一步把绝对路径部分去掉</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">pathWithClass</span> <span class="operator">=</span> child.getAbsolutePath().substring(rootPath.length() - <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">//选中class文件</span></span><br><span class="line">                    <span class="keyword">if</span> (pathWithClass.contains(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">                        <span class="comment">//    com.xinzhi.dao.UserDao</span></span><br><span class="line">                        <span class="comment">//去掉.class后缀，并且把 \ 替换成 .</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> pathWithClass.replaceAll(<span class="string">&quot;\\\\&quot;</span>, <span class="string">&quot;.&quot;</span>).replace(<span class="string">&quot;.class&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Class&lt;?&gt; aClass = Class.forName(fullName);</span><br><span class="line">                            <span class="comment">//把非接口的类实例化放在map中</span></span><br><span class="line">                            <span class="keyword">if</span>(!aClass.isInterface())&#123;</span><br><span class="line">                                <span class="type">Bean</span> <span class="variable">annotation</span> <span class="operator">=</span> aClass.getAnnotation(Bean.class);</span><br><span class="line">                                <span class="keyword">if</span>(annotation != <span class="literal">null</span>)&#123;</span><br><span class="line">                                    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">                                    <span class="comment">//判断一下有没有接口</span></span><br><span class="line">                                    <span class="keyword">if</span>(aClass.getInterfaces().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                        <span class="comment">//如果有接口把接口的class当成key，实例对象当成value</span></span><br><span class="line">                                        System.out.println(<span class="string">&quot;正在加载【&quot;</span>+ aClass.getInterfaces()[<span class="number">0</span>] +<span class="string">&quot;】,实例对象是：&quot;</span> + instance.getClass().getName());</span><br><span class="line">                                        beanFactory.put(aClass.getInterfaces()[<span class="number">0</span>], instance);</span><br><span class="line">                                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                        <span class="comment">//如果有接口把自己的class当成key，实例对象当成value</span></span><br><span class="line">                                        System.out.println(<span class="string">&quot;正在加载【&quot;</span>+ aClass.getName() +<span class="string">&quot;】,实例对象是：&quot;</span> + instance.getClass().getName());</span><br><span class="line">                                        beanFactory.put(aClass, instance);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadDi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Class,Object&gt; entry : beanFactory.entrySet())&#123;</span><br><span class="line">            <span class="comment">//就是咱们放在容器的对象</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            Class&lt;?&gt; aClass = obj.getClass();</span><br><span class="line">            Field[] declaredFields = aClass.getDeclaredFields();</span><br><span class="line">            <span class="keyword">for</span> (Field field : declaredFields)&#123;</span><br><span class="line">                <span class="type">Di</span> <span class="variable">annotation</span> <span class="operator">=</span> field.getAnnotation(Di.class);</span><br><span class="line">                <span class="keyword">if</span>( annotation != <span class="literal">null</span> )&#123;</span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;正在给【&quot;</span>+obj.getClass().getName()+<span class="string">&quot;】属性【&quot;</span> + field.getName() + <span class="string">&quot;】注入值【&quot;</span>+ beanFactory.get(field.getType()).getClass().getName() +<span class="string">&quot;】&quot;</span>);</span><br><span class="line">                        field.set(obj,beanFactory.get(field.getType()));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行第八步：执行成功，依赖注入成功</p><h2 id="5、面向切面：AOP"><a href="#5、面向切面：AOP" class="headerlink" title="5、面向切面：AOP"></a>5、面向切面：AOP</h2><h3 id="5-1、场景模拟"><a href="#5-1、场景模拟" class="headerlink" title="5.1、场景模拟"></a>5.1、场景模拟</h3><p><strong>搭建子模块：spring6-aop</strong></p><h4 id="5-1-1、声明接口"><a href="#5-1-1、声明接口" class="headerlink" title="5.1.1、声明接口"></a>5.1.1、声明接口</h4><p>声明计算器接口Calculator，包含加减乘除的抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-2、创建实现类"><a href="#5-1-2、创建实现类" class="headerlink" title="5.1.2、创建实现类"></a>5.1.2、创建实现类</h4><p><img src="https://s2.loli.net/2023/10/10/gTziF9mYNKPGXks.png" alt="images"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorImpl</span> <span class="keyword">implements</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i + j;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;方法内部 result = &quot;</span> + result);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i - j;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;方法内部 result = &quot;</span> + result);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i * j;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;方法内部 result = &quot;</span> + result);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i / j;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;方法内部 result = &quot;</span> + result);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-3、创建带日志功能的实现类"><a href="#5-1-3、创建带日志功能的实现类" class="headerlink" title="5.1.3、创建带日志功能的实现类"></a>5.1.3、创建带日志功能的实现类</h4><p><img src="https://s2.loli.net/2023/10/10/esQvZNMG6Vkcabh.png" alt="images"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorLogImpl</span> <span class="keyword">implements</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;[日志] add 方法开始了，参数是：&quot;</span> + i + <span class="string">&quot;,&quot;</span> + j);</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i + j;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;方法内部 result = &quot;</span> + result);</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;[日志] add 方法结束了，结果是：&quot;</span> + result);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;[日志] sub 方法开始了，参数是：&quot;</span> + i + <span class="string">&quot;,&quot;</span> + j);</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i - j;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;方法内部 result = &quot;</span> + result);</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;[日志] sub 方法结束了，结果是：&quot;</span> + result);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;[日志] mul 方法开始了，参数是：&quot;</span> + i + <span class="string">&quot;,&quot;</span> + j);</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i * j;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;方法内部 result = &quot;</span> + result);</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;[日志] mul 方法结束了，结果是：&quot;</span> + result);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;[日志] div 方法开始了，参数是：&quot;</span> + i + <span class="string">&quot;,&quot;</span> + j);</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i / j;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;方法内部 result = &quot;</span> + result);</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;[日志] div 方法结束了，结果是：&quot;</span> + result);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-4、提出问题"><a href="#5-1-4、提出问题" class="headerlink" title="5.1.4、提出问题"></a>5.1.4、提出问题</h4><p><strong>①现有代码缺陷</strong></p><p>针对带日志功能的实现类，我们发现有如下缺陷：</p><ul><li>对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力</li><li>附加功能分散在各个业务功能方法中，不利于统一维护</li></ul><p><strong>②解决思路</strong></p><p>解决这两个问题，核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。</p><p><strong>③困难</strong></p><p>解决问题的困难：要抽取的代码在方法内部，靠以前把子类中的重复代码抽取到父类的方式没法解决。所以需要引入新的技术。</p><h3 id="5-2、代理模式"><a href="#5-2、代理模式" class="headerlink" title="5.2、代理模式"></a>5.2、代理模式</h3><h4 id="5-2-1、概念"><a href="#5-2-1、概念" class="headerlink" title="5.2.1、概念"></a>5.2.1、概念</h4><p><strong>①介绍</strong></p><p>二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类<strong>间接</strong>调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——<strong>解耦</strong>。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。</p><p><img src="https://s2.loli.net/2023/10/10/DJrspKjfvg92GYo.png" alt="images"></p><p>使用代理后：</p><p><img src="https://s2.loli.net/2023/10/10/GlevFVwTpNIS21J.png" alt="images"></p><p><strong>②生活中的代理</strong></p><ul><li>广告商找大明星拍广告需要经过经纪人</li><li>合作伙伴找大老板谈合作要约见面时间需要经过秘书</li><li>房产中介是买卖双方的代理</li></ul><p><strong>③相关术语</strong></p><ul><li>代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。</li><li>目标：被代理“套用”了非核心逻辑代码的类、对象、方法。</li></ul><h4 id="5-2-2、静态代理"><a href="#5-2-2、静态代理" class="headerlink" title="5.2.2、静态代理"></a>5.2.2、静态代理</h4><p>创建静态代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorStaticProxy</span> <span class="keyword">implements</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将被代理的目标对象声明为成员变量</span></span><br><span class="line">    <span class="keyword">private</span> Calculator target;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CalculatorStaticProxy</span><span class="params">(Calculator target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 附加功能由代理类中的代理方法来实现</span></span><br><span class="line">        System.out.println(<span class="string">&quot;[日志] add 方法开始了，参数是：&quot;</span> + i + <span class="string">&quot;,&quot;</span> + j);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 通过目标对象来实现核心业务逻辑</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">addResult</span> <span class="operator">=</span> target.add(i, j);</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;[日志] add 方法结束了，结果是：&quot;</span> + addResult);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> addResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。</p><p>提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。</p></blockquote><h4 id="5-2-3、动态代理"><a href="#5-2-3、动态代理" class="headerlink" title="5.2.3、动态代理"></a>5.2.3、动态代理</h4><p><img src="https://s2.loli.net/2023/10/10/lOfo1yrUK9iRZBE.png" alt="images"></p><p>生产代理对象的工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * newProxyInstance()：创建一个代理实例</span></span><br><span class="line"><span class="comment">         * 其中有三个参数：</span></span><br><span class="line"><span class="comment">         * 1、classLoader：加载动态生成的代理类的类加载器</span></span><br><span class="line"><span class="comment">         * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组</span></span><br><span class="line"><span class="comment">         * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> target.getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * proxy：代理对象</span></span><br><span class="line"><span class="comment">                 * method：代理对象需要实现的方法，即其中需要重写的方法</span></span><br><span class="line"><span class="comment">                 * args：method所对应方法的参数</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;[动态代理][日志] &quot;</span>+method.getName()+<span class="string">&quot;，参数：&quot;</span>+ Arrays.toString(args));</span><br><span class="line">                    result = method.invoke(target, args);</span><br><span class="line">                    System.out.println(<span class="string">&quot;[动态代理][日志] &quot;</span>+method.getName()+<span class="string">&quot;，结果：&quot;</span>+ result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    System.out.println(<span class="string">&quot;[动态代理][日志] &quot;</span>+method.getName()+<span class="string">&quot;，异常：&quot;</span>+e.getMessage());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;[动态代理][日志] &quot;</span>+method.getName()+<span class="string">&quot;，方法执行完毕&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-4、测试"><a href="#5-2-4、测试" class="headerlink" title="5.2.4、测试"></a>5.2.4、测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDynamicProxy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(<span class="keyword">new</span> <span class="title class_">CalculatorLogImpl</span>());</span><br><span class="line">    <span class="type">Calculator</span> <span class="variable">proxy</span> <span class="operator">=</span> (Calculator) factory.getProxy();</span><br><span class="line">    proxy.div(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//proxy.div(1,1);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3、AOP概念及相关术语"><a href="#5-3、AOP概念及相关术语" class="headerlink" title="5.3、AOP概念及相关术语"></a>5.3、AOP概念及相关术语</h3><h4 id="5-3-1、概述"><a href="#5-3-1、概述" class="headerlink" title="5.3.1、概述"></a>5.3.1、概述</h4><p>AOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的面向切面编程，它是面向对象编程的一种补充和完善，它以通过预编译方式和运行期动态代理方式实现，在不修改源代码的情况下，给程序动态统一添加额外功能的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><h4 id="5-3-2、相关术语"><a href="#5-3-2、相关术语" class="headerlink" title="5.3.2、相关术语"></a>5.3.2、相关术语</h4><h5 id="①横切关注点"><a href="#①横切关注点" class="headerlink" title="①横切关注点"></a>①横切关注点</h5><p>分散在每个各个模块中解决同一样的问题，如用户验证、日志管理、事务处理、数据缓存都属于横切关注点。</p><p>从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。</p><p>这个概念不是语法层面的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。</p><p><img src="https://s2.loli.net/2023/10/10/zB9U6gYPbdtshfi.png" alt="images"></p><h5 id="②通知（增强）"><a href="#②通知（增强）" class="headerlink" title="②通知（增强）"></a>②通知（增强）</h5><p><strong>增强，通俗说，就是你想要增强的功能，比如 安全，事务，日志等。</strong></p><p>每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。</p><ul><li>前置通知：在被代理的目标方法<strong>前</strong>执行</li><li>返回通知：在被代理的目标方法<strong>成功结束</strong>后执行（<strong>寿终正寝</strong>）</li><li>异常通知：在被代理的目标方法<strong>异常结束</strong>后执行（<strong>死于非命</strong>）</li><li>后置通知：在被代理的目标方法<strong>最终结束</strong>后执行（<strong>盖棺定论</strong>）</li><li>环绕通知：使用try…catch…finally结构围绕<strong>整个</strong>被代理的目标方法，包括上面四种通知对应的所有位置</li></ul><p><img src="https://s2.loli.net/2023/10/10/9dqzpt7hWrUivs4.png" alt="images"></p><h5 id="③切面"><a href="#③切面" class="headerlink" title="③切面"></a>③切面</h5><p>封装通知方法的类。</p><p><img src="https://s2.loli.net/2023/10/10/nLGYtFecoRKNwzX.png" alt="images"></p><h5 id="④目标"><a href="#④目标" class="headerlink" title="④目标"></a>④目标</h5><p>被代理的目标对象。</p><h5 id="⑤代理"><a href="#⑤代理" class="headerlink" title="⑤代理"></a>⑤代理</h5><p>向目标对象应用通知之后创建的代理对象。</p><h5 id="⑥连接点"><a href="#⑥连接点" class="headerlink" title="⑥连接点"></a>⑥连接点</h5><p>这也是一个纯逻辑概念，不是语法定义的。</p><p>把方法排成一排，每一个横切位置看成x轴方向，把方法从上到下执行的顺序看成y轴，x轴和y轴的交叉点就是连接点。<strong>通俗说，就是spring允许你使用通知的地方</strong></p><p><img src="https://s2.loli.net/2023/10/10/lHjTRUvkCydwrAe.png" alt="images"></p><h5 id="⑦切入点"><a href="#⑦切入点" class="headerlink" title="⑦切入点"></a>⑦切入点</h5><p>定位连接点的方式。</p><p>每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物（从逻辑上来说）。</p><p>如果把连接点看作数据库中的记录，那么切入点就是查询记录的 SQL 语句。</p><p><strong>Spring 的 AOP 技术可以通过切入点定位到特定的连接点。通俗说，要实际去增强的方法</strong></p><p>切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。</p><h4 id="5-3-3、作用"><a href="#5-3-3、作用" class="headerlink" title="5.3.3、作用"></a>5.3.3、作用</h4><ul><li><p>简化代码：把方法中固定位置的重复的代码<strong>抽取</strong>出来，让被抽取的方法更专注于自己的核心功能，提高内聚性。</p></li><li><p>代码增强：把特定的功能封装到切面类中，看哪里有需要，就往上套，被<strong>套用</strong>了切面逻辑的方法就被切面给增强了。</p></li></ul><h3 id="5-4、基于注解的AOP"><a href="#5-4、基于注解的AOP" class="headerlink" title="5.4、基于注解的AOP"></a>5.4、基于注解的AOP</h3><h4 id="5-4-1、技术说明"><a href="#5-4-1、技术说明" class="headerlink" title="5.4.1、技术说明"></a>5.4.1、技术说明</h4><p><img src="https://s2.loli.net/2023/10/10/raCmxy9sJRZQY3l.png" alt="images"></p><p><img src="https://s2.loli.net/2023/10/10/8jm5kZVTWJPtb6N.png" alt="image-20221216132844066"></p><ul><li>动态代理分为JDK动态代理和cglib动态代理</li><li>当目标类有接口的情况使用JDK动态代理和cglib动态代理，没有接口时只能使用cglib动态代理</li><li>JDK动态代理动态生成的代理类会在com.sun.proxy包下，类名为$proxy1，和目标类实现相同的接口</li><li>cglib动态代理动态生成的代理类会和目标在在相同的包下，会继承目标类</li><li>动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求<strong>代理对象和目标对象实现同样的接口</strong>（兄弟两个拜把子模式）。</li><li>cglib：通过<strong>继承被代理的目标类</strong>（认干爹模式）实现代理，所以不需要目标类实现接口。</li><li>AspectJ：是AOP思想的一种实现。本质上是静态代理，<strong>将代理逻辑“织入”被代理的目标类编译得到的字节码文件</strong>，所以最终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。</li></ul><h4 id="5-4-2、准备工作"><a href="#5-4-2、准备工作" class="headerlink" title="5.4.2、准备工作"></a>5.4.2、准备工作</h4><p><strong>①添加依赖</strong></p><p>在IOC所需依赖基础上再加入下面依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring context依赖--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--spring aop依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring aspects依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--junit5测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--log4j2的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j2-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>②准备被代理的目标资源</strong></p><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorImpl</span> <span class="keyword">implements</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i + j;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;方法内部 result = &quot;</span> + result);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i - j;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;方法内部 result = &quot;</span> + result);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i * j;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;方法内部 result = &quot;</span> + result);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i / j;</span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;方法内部 result = &quot;</span> + result);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-4-3、创建切面类并配置"><a href="#5-4-3、创建切面类并配置" class="headerlink" title="5.4.3、创建切面类并配置"></a>5.4.3、创建切面类并配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Aspect表示这个类是一个切面类</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="comment">// @Component注解保证这个切面类能够放入IOC容器</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethod</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">args</span> <span class="operator">=</span> Arrays.toString(joinPoint.getArgs());</span><br><span class="line">        System.out.println(<span class="string">&quot;Logger--&gt;前置通知，方法名：&quot;</span>+methodName+<span class="string">&quot;，参数：&quot;</span>+args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterMethod</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Logger--&gt;后置通知，方法名：&quot;</span>+methodName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturningMethod</span><span class="params">(JoinPoint joinPoint, Object result)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Logger--&gt;返回通知，方法名：&quot;</span>+methodName+<span class="string">&quot;，结果：&quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, throwing = &quot;ex&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowingMethod</span><span class="params">(JoinPoint joinPoint, Throwable ex)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Logger--&gt;异常通知，方法名：&quot;</span>+methodName+<span class="string">&quot;，异常：&quot;</span>+ex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundMethod</span><span class="params">(ProceedingJoinPoint joinPoint)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">args</span> <span class="operator">=</span> Arrays.toString(joinPoint.getArgs());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;环绕通知--&gt;目标对象方法执行之前&quot;</span>);</span><br><span class="line">            <span class="comment">//目标对象（连接点）方法的执行</span></span><br><span class="line">            result = joinPoint.proceed();</span><br><span class="line">            System.out.println(<span class="string">&quot;环绕通知--&gt;目标对象方法返回值之后&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;环绕通知--&gt;目标对象方法出现异常时&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;环绕通知--&gt;目标对象方法执行完毕&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Spring的配置文件中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        基于注解的AOP的实现：</span></span><br><span class="line"><span class="comment">        1、将目标对象和切面交给IOC容器管理（注解+扫描）</span></span><br><span class="line"><span class="comment">        2、开启AspectJ的自动代理，为目标对象自动生成代理</span></span><br><span class="line"><span class="comment">        3、将切面类通过注解@Aspect标识</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.aop.annotation&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(CalculatorTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> ac.getBean( Calculator.class);</span><br><span class="line">        <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> calculator.add(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;执行成功:&quot;</span>+add);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://s2.loli.net/2023/10/10/Fi8AHsORIlCmdn2.png" alt="image-20221102155523983"></p><h4 id="5-4-4、各种通知"><a href="#5-4-4、各种通知" class="headerlink" title="5.4.4、各种通知"></a>5.4.4、各种通知</h4><ul><li>前置通知：使用@Before注解标识，在被代理的目标方法<strong>前</strong>执行</li><li>返回通知：使用@AfterReturning注解标识，在被代理的目标方法<strong>成功结束</strong>后执行（<strong>寿终正寝</strong>）</li><li>异常通知：使用@AfterThrowing注解标识，在被代理的目标方法<strong>异常结束</strong>后执行（<strong>死于非命</strong>）</li><li>后置通知：使用@After注解标识，在被代理的目标方法<strong>最终结束</strong>后执行（<strong>盖棺定论</strong>）</li><li>环绕通知：使用@Around注解标识，使用try…catch…finally结构围绕<strong>整个</strong>被代理的目标方法，包括上面四种通知对应的所有位置</li></ul><blockquote><p>各种通知的执行顺序：</p><ul><li>Spring版本5.3.x以前：<ul><li>前置通知</li><li>目标操作</li><li>后置通知</li><li>返回通知或异常通知</li></ul></li><li>Spring版本5.3.x以后：<ul><li>前置通知</li><li>目标操作</li><li>返回通知或异常通知</li><li>后置通知</li></ul></li></ul></blockquote><h4 id="5-4-5、切入点表达式语法"><a href="#5-4-5、切入点表达式语法" class="headerlink" title="5.4.5、切入点表达式语法"></a>5.4.5、切入点表达式语法</h4><p><strong>①作用</strong></p><p><img src="https://s2.loli.net/2023/10/10/7u48oDQOHrEx1k5.png" alt="images"></p><p><strong>②语法细节</strong></p><ul><li><p>用*号代替“权限修饰符”和“返回值”部分表示“权限修饰符”和“返回值”不限</p></li><li><p>在包名的部分，一个“*”号只能代表包的层次结构中的一层，表示这一层是任意的。</p><ul><li>例如：*.Hello匹配com.Hello，不匹配com.atguigu.Hello</li></ul></li><li><p>在包名的部分，使用“*..”表示包名任意、包的层次深度任意</p></li><li><p>在类名的部分，类名部分整体用*号代替，表示类名任意</p></li><li><p>在类名的部分，可以使用*号代替类名的一部分</p><ul><li>例如：*Service匹配所有名称以Service结尾的类或接口</li></ul></li><li><p>在方法名部分，可以使用*号表示方法名任意</p></li><li><p>在方法名部分，可以使用*号代替方法名的一部分</p><ul><li>例如：*Operation匹配所有方法名以Operation结尾的方法</li></ul></li><li><p>在方法参数列表部分，使用(..)表示参数列表任意</p></li><li><p>在方法参数列表部分，使用(int,..)表示参数列表以一个int类型的参数开头</p></li><li><p>在方法参数列表部分，基本数据类型和对应的包装类型是不一样的</p><ul><li>切入点表达式中使用 int 和实际方法中 Integer 是不匹配的</li></ul></li><li><p>在方法返回值部分，如果想要明确指定一个返回值类型，那么必须同时写明权限修饰符</p><ul><li>例如：execution(public int <em>..<em>Service.</em>(.., int))    正确<br>   例如：execution(</em> int *..<em>Service.</em>(.., int))    错误</li></ul></li></ul><p><img src="https://s2.loli.net/2023/10/10/mu6YSbMJDz3nesU.png" alt="images"></p><h4 id="5-4-6、重用切入点表达式"><a href="#5-4-6、重用切入点表达式" class="headerlink" title="5.4.6、重用切入点表达式"></a>5.4.6、重用切入点表达式</h4><p><strong>①声明</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.atguigu.aop.annotation.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>②在同一个切面中使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethod</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">args</span> <span class="operator">=</span> Arrays.toString(joinPoint.getArgs());</span><br><span class="line">    System.out.println(<span class="string">&quot;Logger--&gt;前置通知，方法名：&quot;</span>+methodName+<span class="string">&quot;，参数：&quot;</span>+args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>③在不同切面中使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;com.atguigu.aop.CommonPointCut.pointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethod</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">args</span> <span class="operator">=</span> Arrays.toString(joinPoint.getArgs());</span><br><span class="line">    System.out.println(<span class="string">&quot;Logger--&gt;前置通知，方法名：&quot;</span>+methodName+<span class="string">&quot;，参数：&quot;</span>+args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-4-7、获取通知的相关信息"><a href="#5-4-7、获取通知的相关信息" class="headerlink" title="5.4.7、获取通知的相关信息"></a>5.4.7、获取通知的相关信息</h4><p><strong>①获取连接点信息</strong></p><p>获取连接点信息可以在通知方法的参数位置设置JoinPoint类型的形参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethod</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">    <span class="comment">//获取连接点的签名信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    <span class="comment">//获取目标方法到的实参信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">args</span> <span class="operator">=</span> Arrays.toString(joinPoint.getArgs());</span><br><span class="line">    System.out.println(<span class="string">&quot;Logger--&gt;前置通知，方法名：&quot;</span>+methodName+<span class="string">&quot;，参数：&quot;</span>+args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②获取目标方法的返回值</strong></p><p>@AfterReturning中的属性returning，用来将通知方法的某个形参，接收目标方法的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, returning = &quot;result&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturningMethod</span><span class="params">(JoinPoint joinPoint, Object result)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;Logger--&gt;返回通知，方法名：&quot;</span>+methodName+<span class="string">&quot;，结果：&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>③获取目标方法的异常</strong></p><p>@AfterThrowing中的属性throwing，用来将通知方法的某个形参，接收目标方法的异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, throwing = &quot;ex&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowingMethod</span><span class="params">(JoinPoint joinPoint, Throwable ex)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;Logger--&gt;异常通知，方法名：&quot;</span>+methodName+<span class="string">&quot;，异常：&quot;</span>+ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-4-8、环绕通知"><a href="#5-4-8、环绕通知" class="headerlink" title="5.4.8、环绕通知"></a>5.4.8、环绕通知</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">aroundMethod</span><span class="params">(ProceedingJoinPoint joinPoint)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">args</span> <span class="operator">=</span> Arrays.toString(joinPoint.getArgs());</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知--&gt;目标对象方法执行之前&quot;</span>);</span><br><span class="line">        <span class="comment">//目标方法的执行，目标方法的返回值一定要返回给外界调用者</span></span><br><span class="line">        result = joinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知--&gt;目标对象方法返回值之后&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知--&gt;目标对象方法出现异常时&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知--&gt;目标对象方法执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-4-9、切面的优先级"><a href="#5-4-9、切面的优先级" class="headerlink" title="5.4.9、切面的优先级"></a>5.4.9、切面的优先级</h4><p>相同目标方法上同时存在多个切面时，切面的优先级控制切面的<strong>内外嵌套</strong>顺序。</p><ul><li>优先级高的切面：外面</li><li>优先级低的切面：里面</li></ul><p>使用@Order注解可以控制切面的优先级：</p><ul><li>@Order(较小的数)：优先级高</li><li>@Order(较大的数)：优先级低</li></ul><p><img src="https://s2.loli.net/2023/10/10/x32N48qpJSfaTGl.png" alt="images"></p><h3 id="5-5、基于XML的AOP"><a href="#5-5、基于XML的AOP" class="headerlink" title="5.5、基于XML的AOP"></a>5.5、基于XML的AOP</h3><h4 id="5-5-1、准备工作"><a href="#5-5-1、准备工作" class="headerlink" title="5.5.1、准备工作"></a>5.5.1、准备工作</h4><p>参考基于注解的AOP环境</p><h4 id="5-5-2、实现"><a href="#5-5-2、实现" class="headerlink" title="5.5.2、实现"></a>5.5.2、实现</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.aop.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切面类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;loggerAspect&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointCut&quot;</span> </span></span><br><span class="line"><span class="tag">                   <span class="attr">expression</span>=<span class="string">&quot;execution(* com.atguigu.aop.xml.CalculatorImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;beforeMethod&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;afterMethod&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturningMethod&quot;</span> <span class="attr">returning</span>=<span class="string">&quot;result&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowingMethod&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;ex&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;aroundMethod&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:around</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6、单元测试：JUnit"><a href="#6、单元测试：JUnit" class="headerlink" title="6、单元测试：JUnit"></a>6、单元测试：JUnit</h2><p>在之前的测试方法中，几乎都能看到以下的两行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;xxx.xml&quot;</span>);</span><br><span class="line"><span class="type">Xxxx</span> <span class="variable">xxx</span> <span class="operator">=</span> context.getBean(Xxxx.class);</span><br></pre></td></tr></table></figure><p>这两行代码的作用是创建Spring容器，最终获取到对象，但是每次测试都需要重复编写。针对上述问题，我们需要的是程序能自动帮我们创建容器。我们都知道JUnit无法知晓我们是否使用了 Spring 框架，更不用说帮我们创建 Spring 容器了。Spring提供了一个运行器，可以读取配置文件（或注解）来创建容器。我们只需要告诉它配置文件位置就可以了。这样一来，我们通过Spring整合JUnit可以使程序创建spring容器了</p><h3 id="6-1、整合JUnit5"><a href="#6-1、整合JUnit5" class="headerlink" title="6.1、整合JUnit5"></a>6.1、整合JUnit5</h3><h4 id="6-1-1、搭建子模块"><a href="#6-1-1、搭建子模块" class="headerlink" title="6.1.1、搭建子模块"></a>6.1.1、搭建子模块</h4><p>搭建spring-junit模块</p><h4 id="6-1-2、引入依赖"><a href="#6-1-2、引入依赖" class="headerlink" title="6.1.2、引入依赖"></a>6.1.2、引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring context依赖--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--spring对junit的支持相关依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--junit5测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--log4j2的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j2-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="6-1-3、添加配置文件"><a href="#6-1-3、添加配置文件" class="headerlink" title="6.1.3、添加配置文件"></a>6.1.3、添加配置文件</h4><p>beans.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.spring6.bean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>copy日志文件：log4j2.xml</p><h4 id="6-1-4、添加java类"><a href="#6-1-4、添加java类" class="headerlink" title="6.1.4、添加java类"></a>6.1.4、添加java类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run user&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-1-5、测试"><a href="#6-1-5、测试" class="headerlink" title="6.1.5、测试"></a>6.1.5、测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.spring6.bean.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.extension.ExtendWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit.jupiter.SpringExtension;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit.jupiter.SpringJUnitConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两种方式均可</span></span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="comment">//@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="comment">//@ContextConfiguration(&quot;classpath:beans.xml&quot;)</span></span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="meta">@SpringJUnitConfig(locations = &quot;classpath:beans.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringJUnit5Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUser</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2、整合JUnit4"><a href="#6-2、整合JUnit4" class="headerlink" title="6.2、整合JUnit4"></a>6.2、整合JUnit4</h3><p>JUnit4在公司也会经常用到，在此也学习一下</p><h4 id="6-2-1、添加依赖"><a href="#6-2-1、添加依赖" class="headerlink" title="6.2.1、添加依赖"></a>6.2.1、添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="6-2-2、测试"><a href="#6-2-2、测试" class="headerlink" title="6.2.2、测试"></a>6.2.2、测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.spring6.bean.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:beans.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringJUnit4Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUser</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、事务"><a href="#7、事务" class="headerlink" title="7、事务"></a>7、事务</h2><h3 id="7-1、JdbcTemplate"><a href="#7-1、JdbcTemplate" class="headerlink" title="7.1、JdbcTemplate"></a>7.1、JdbcTemplate</h3><h4 id="7-1-1、简介"><a href="#7-1-1、简介" class="headerlink" title="7.1.1、简介"></a>7.1.1、简介</h4><p><img src="https://s2.loli.net/2023/10/10/SL9INWpPyRgVzCM.png" alt="image-20221217115515670"></p><p>Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作</p><h4 id="7-1-2、准备工作"><a href="#7-1-2、准备工作" class="headerlink" title="7.1.2、准备工作"></a>7.1.2、准备工作</h4><p><strong>①搭建子模块</strong></p><p>搭建子模块：spring-jdbc-tx</p><p><strong>②加入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring jdbc  Spring 持久化层支持jar包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>③创建jdbc.properties</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/spring?characterEncoding=utf8&amp;useSSL=false</span></span><br><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p><strong>④配置Spring的配置文件</strong></p><p>beans.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 导入外部属性文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;druidDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.user&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置 JdbcTemplate --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 装配数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;druidDataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>⑤准备数据库与测试表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE `spring`;</span><br><span class="line"></span><br><span class="line">use `spring`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `t_emp` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(<span class="number">20</span>) DEFAULT NULL COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) DEFAULT NULL COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">  `sex` varchar(<span class="number">2</span>) DEFAULT NULL COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">  PRIMARY <span class="title function_">KEY</span> <span class="params">(`id`)</span></span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure><h4 id="7-1-3、实现CURD"><a href="#7-1-3、实现CURD" class="headerlink" title="7.1.3、实现CURD"></a>7.1.3、实现CURD</h4><h5 id="①装配-JdbcTemplate"><a href="#①装配-JdbcTemplate" class="headerlink" title="①装配 JdbcTemplate"></a>①装配 JdbcTemplate</h5><p><strong>创建测试类，整合JUnit，注入JdbcTemplate</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit.jupiter.SpringJUnitConfig;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringJUnitConfig(locations = &quot;classpath:beans.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCTemplateTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="②测试增删改功能"><a href="#②测试增删改功能" class="headerlink" title="②测试增删改功能"></a>②测试增删改功能</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//测试增删改功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//添加功能</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_emp values(null,?,?,?)&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> jdbcTemplate.update(sql, <span class="string">&quot;张三&quot;</span>, <span class="number">23</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//修改功能</span></span><br><span class="line"><span class="comment">//String sql = &quot;update t_emp set name=? where id=?&quot;;</span></span><br><span class="line">    <span class="comment">//int result = jdbcTemplate.update(sql, &quot;张三atguigu&quot;, 1);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除功能</span></span><br><span class="line"><span class="comment">//String sql = &quot;delete from t_emp where id=?&quot;;</span></span><br><span class="line"><span class="comment">//int result = jdbcTemplate.update(sql, 1);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="③查询数据返回对象"><a href="#③查询数据返回对象" class="headerlink" title="③查询数据返回对象"></a>③查询数据返回对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成get和set方法</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Emp&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询：返回对象</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectObject</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//写法一</span></span><br><span class="line"><span class="comment">//        String sql = &quot;select * from t_emp where id=?&quot;;</span></span><br><span class="line"><span class="comment">//        Emp empResult = jdbcTemplate.queryForObject(sql,</span></span><br><span class="line"><span class="comment">//                (rs, rowNum) -&gt; &#123;</span></span><br><span class="line"><span class="comment">//                    Emp emp = new Emp();</span></span><br><span class="line"><span class="comment">//                    emp.setId(rs.getInt(&quot;id&quot;));</span></span><br><span class="line"><span class="comment">//                    emp.setName(rs.getString(&quot;name&quot;));</span></span><br><span class="line"><span class="comment">//                    emp.setAge(rs.getInt(&quot;age&quot;));</span></span><br><span class="line"><span class="comment">//                    emp.setSex(rs.getString(&quot;sex&quot;));</span></span><br><span class="line"><span class="comment">//                    return emp;</span></span><br><span class="line"><span class="comment">//                &#125;, 1);</span></span><br><span class="line"><span class="comment">//        System.out.println(empResult);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//写法二</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_emp where id=?&quot;</span>;</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql,</span><br><span class="line">                  <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(Emp.class),<span class="number">1</span>);</span><br><span class="line">    System.out.println(emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="④查询数据返回list集合"><a href="#④查询数据返回list集合" class="headerlink" title="④查询数据返回list集合"></a>④查询数据返回list集合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//查询多条数据为一个list集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_emp&quot;</span>;</span><br><span class="line">    List&lt;Emp&gt; list = jdbcTemplate.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(Emp.class));</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="⑤查询返回单个的值"><a href="#⑤查询返回单个的值" class="headerlink" title="⑤查询返回单个的值"></a>⑤查询返回单个的值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//查询单行单列的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(id) from t_emp&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2、声明式事务概念"><a href="#7-2、声明式事务概念" class="headerlink" title="7.2、声明式事务概念"></a>7.2、声明式事务概念</h3><h4 id="7-2-1、事务基本概念"><a href="#7-2-1、事务基本概念" class="headerlink" title="7.2.1、事务基本概念"></a>7.2.1、事务基本概念</h4><h5 id="①什么是事务"><a href="#①什么是事务" class="headerlink" title="①什么是事务"></a>①什么是事务</h5><p>数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。</p><h5 id="②事务的特性"><a href="#②事务的特性" class="headerlink" title="②事务的特性"></a>②事务的特性</h5><p><strong>A：原子性(Atomicity)</strong></p><p>一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p><p><strong>C：一致性(Consistency)</strong></p><p>事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。</p><p>如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。</p><p>如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。</p><p><strong>I：隔离性(Isolation)</strong></p><p>指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p><p><strong>D：持久性(Durability)</strong></p><p>指的是只要事务成功结束，它对数据库所做的更新就必须保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。</p><h4 id="7-2-2、编程式事务"><a href="#7-2-2、编程式事务" class="headerlink" title="7.2.2、编程式事务"></a>7.2.2、编程式事务</h4><p>事务功能的相关操作全部通过自己编写代码来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ...;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开启事务：关闭事务的自动提交</span></span><br><span class="line">    conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    conn.commit();</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回滚事务</span></span><br><span class="line">    conn.rollBack();</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放数据库连接</span></span><br><span class="line">    conn.close();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编程式的实现方式存在缺陷：</p><ul><li>细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。</li><li>代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。</li></ul><h4 id="7-2-3、声明式事务"><a href="#7-2-3、声明式事务" class="headerlink" title="7.2.3、声明式事务"></a>7.2.3、声明式事务</h4><p>既然事务控制的代码有规律可循，代码的结构基本是确定的，所以框架就可以将固定模式的代码抽取出来，进行相关的封装。</p><p>封装起来后，我们只需要在配置文件中进行简单的配置即可完成操作。</p><ul><li>好处1：提高开发效率</li><li>好处2：消除了冗余的代码</li><li>好处3：框架会综合考虑相关领域中在实际开发环境下有可能遇到的各种问题，进行了健壮性、性能等各个方面的优化</li></ul><p>所以，我们可以总结下面两个概念：</p><ul><li><strong>编程式</strong>：<strong>自己写代码</strong>实现功能</li><li><strong>声明式</strong>：通过<strong>配置</strong>让<strong>框架</strong>实现功能</li></ul><h3 id="7-3、基于注解的声明式事务"><a href="#7-3、基于注解的声明式事务" class="headerlink" title="7.3、基于注解的声明式事务"></a>7.3、基于注解的声明式事务</h3><h4 id="7-3-1、准备工作"><a href="#7-3-1、准备工作" class="headerlink" title="7.3.1、准备工作"></a>7.3.1、准备工作</h4><p><strong>①添加配置</strong></p><p>在beans.xml添加配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--扫描组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.spring6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>②创建表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_book` (</span><br><span class="line">  `book_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `book_name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;图书名称&#x27;</span>,</span><br><span class="line">  `price` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;价格&#x27;</span>,</span><br><span class="line">  `stock` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;库存（无符号）&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`book_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> `t_book`(`book_id`,`book_name`,`price`,`stock`) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">&#x27;斗破苍穹&#x27;</span>,<span class="number">80</span>,<span class="number">100</span>),(<span class="number">2</span>,<span class="string">&#x27;斗罗大陆&#x27;</span>,<span class="number">50</span>,<span class="number">100</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_user` (</span><br><span class="line">  `user_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  `balance` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;余额（无符号）&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`user_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> `t_user`(`user_id`,`username`,`balance`) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="number">50</span>);</span><br></pre></td></tr></table></figure><p><strong>③创建组件</strong></p><p>创建BookController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.controller;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyBook</span><span class="params">(Integer bookId, Integer userId)</span>&#123;</span><br><span class="line">        bookService.buyBook(bookId, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建接口BookService：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.service;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buyBook</span><span class="params">(Integer bookId, Integer userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建实现类BookServiceImpl：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.service.impl;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyBook</span><span class="params">(Integer bookId, Integer userId)</span> &#123;</span><br><span class="line">        <span class="comment">//查询图书的价格</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">price</span> <span class="operator">=</span> bookDao.getPriceByBookId(bookId);</span><br><span class="line">        <span class="comment">//更新图书的库存</span></span><br><span class="line">        bookDao.updateStock(bookId);</span><br><span class="line">        <span class="comment">//更新用户的余额</span></span><br><span class="line">        bookDao.updateBalance(userId, price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建接口BookDao：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.dao;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    Integer <span class="title function_">getPriceByBookId</span><span class="params">(Integer bookId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateStock</span><span class="params">(Integer bookId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateBalance</span><span class="params">(Integer userId, Integer price)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建实现类BookDaoImpl：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.dao.impl;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getPriceByBookId</span><span class="params">(Integer bookId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select price from t_book where book_id = ?&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, Integer.class, bookId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateStock</span><span class="params">(Integer bookId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_book set stock = stock - 1 where book_id = ?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, bookId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateBalance</span><span class="params">(Integer userId, Integer price)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_user set balance = balance - ? where user_id = ?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, price, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-2、测试无事务情况"><a href="#7-3-2、测试无事务情况" class="headerlink" title="7.3.2、测试无事务情况"></a>7.3.2、测试无事务情况</h4><p><strong>①创建测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit.jupiter.SpringJUnitConfig;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringJUnitConfig(locations = &quot;classpath:beans.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxByAnnotationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookController bookController;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBuyBook</span><span class="params">()</span>&#123;</span><br><span class="line">        bookController.buyBook(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②模拟场景</strong></p><p>用户购买图书，先查询图书的价格，再更新图书的库存和用户的余额</p><p>假设用户id为1的用户，购买id为1的图书</p><p>用户余额为50，而图书价格为80</p><p>购买图书之后，用户的余额为-30，数据库中余额字段设置了无符号，因此无法将-30插入到余额字段</p><p>此时执行sql语句会抛出SQLException</p><p><strong>③观察结果</strong></p><p>因为没有添加事务，图书的库存更新了，但是用户的余额没有更新</p><p>显然这样的结果是错误的，购买图书是一个完整的功能，更新库存和更新余额要么都成功要么都失败</p><h4 id="7-3-3、加入事务"><a href="#7-3-3、加入事务" class="headerlink" title="7.3.3、加入事务"></a>7.3.3、加入事务</h4><h5 id="①添加事务配置"><a href="#①添加事务配置" class="headerlink" title="①添加事务配置"></a>①添加事务配置</h5><p>在spring配置文件中引入tx命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Spring的配置文件中添加配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;druidDataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    开启事务的注解驱动</span></span><br><span class="line"><span class="comment">    通过注解@Transactional所标识的方法或标识的类中所有的方法，都会被事务管理器管理事务</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- transaction-manager属性的默认值是transactionManager，如果事务管理器bean的id正好就是这个默认值，则可以省略这个属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h5 id="②添加事务注解"><a href="#②添加事务注解" class="headerlink" title="②添加事务注解"></a>②添加事务注解</h5><p>因为service层表示业务逻辑层，一个方法表示一个完成的功能，因此处理事务一般在service层处理</p><p><strong>在BookServiceImpl的buybook()添加注解@Transactional</strong></p><h5 id="③观察结果"><a href="#③观察结果" class="headerlink" title="③观察结果"></a>③观察结果</h5><p>由于使用了Spring的声明式事务，更新库存和更新余额都没有执行</p><h4 id="7-3-4、-Transactional注解标识的位置"><a href="#7-3-4、-Transactional注解标识的位置" class="headerlink" title="7.3.4、@Transactional注解标识的位置"></a>7.3.4、@Transactional注解标识的位置</h4><p>@Transactional标识在方法上，则只会影响该方法</p><p>@Transactional标识的类上，则会影响类中所有的方法</p><h4 id="7-3-5、事务属性：只读"><a href="#7-3-5、事务属性：只读" class="headerlink" title="7.3.5、事务属性：只读"></a>7.3.5、事务属性：只读</h4><p><strong>①介绍</strong></p><p>对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。</p><p><strong>②使用方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyBook</span><span class="params">(Integer bookId, Integer userId)</span> &#123;</span><br><span class="line">    <span class="comment">//查询图书的价格</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">price</span> <span class="operator">=</span> bookDao.getPriceByBookId(bookId);</span><br><span class="line">    <span class="comment">//更新图书的库存</span></span><br><span class="line">    bookDao.updateStock(bookId);</span><br><span class="line">    <span class="comment">//更新用户的余额</span></span><br><span class="line">    bookDao.updateBalance(userId, price);</span><br><span class="line">    <span class="comment">//System.out.println(1/0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>③注意</strong></p><p>对增删改操作设置只读会抛出下面异常：</p><p>Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed</p><h4 id="7-3-6、事务属性：超时"><a href="#7-3-6、事务属性：超时" class="headerlink" title="7.3.6、事务属性：超时"></a>7.3.6、事务属性：超时</h4><p><strong>①介绍</strong></p><p>事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。</p><p>概括来说就是一句话：超时回滚，释放资源。</p><p><strong>②使用方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//超时时间单位秒</span></span><br><span class="line"><span class="meta">@Transactional(timeout = 3)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyBook</span><span class="params">(Integer bookId, Integer userId)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询图书的价格</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">price</span> <span class="operator">=</span> bookDao.getPriceByBookId(bookId);</span><br><span class="line">    <span class="comment">//更新图书的库存</span></span><br><span class="line">    bookDao.updateStock(bookId);</span><br><span class="line">    <span class="comment">//更新用户的余额</span></span><br><span class="line">    bookDao.updateBalance(userId, price);</span><br><span class="line">    <span class="comment">//System.out.println(1/0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>③观察结果</strong></p><p>执行过程中抛出异常：</p><p>org.springframework.transaction.<strong>TransactionTimedOutException</strong>: Transaction timed out: deadline was Fri Jun 04 16:25:39 CST 2022</p><h4 id="7-3-7、事务属性：回滚策略"><a href="#7-3-7、事务属性：回滚策略" class="headerlink" title="7.3.7、事务属性：回滚策略"></a>7.3.7、事务属性：回滚策略</h4><p><strong>①介绍</strong></p><p>声明式事务默认只针对运行时异常回滚，编译时异常不回滚。</p><p>可以通过@Transactional中相关属性设置回滚策略</p><ul><li><p>rollbackFor属性：需要设置一个Class类型的对象</p></li><li><p>rollbackForClassName属性：需要设置一个字符串类型的全类名</p></li><li><p>noRollbackFor属性：需要设置一个Class类型的对象</p></li><li><p>rollbackFor属性：需要设置一个字符串类型的全类名</p></li></ul><p><strong>②使用方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(noRollbackFor = ArithmeticException.class)</span></span><br><span class="line"><span class="comment">//@Transactional(noRollbackForClassName = &quot;java.lang.ArithmeticException&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyBook</span><span class="params">(Integer bookId, Integer userId)</span> &#123;</span><br><span class="line">    <span class="comment">//查询图书的价格</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">price</span> <span class="operator">=</span> bookDao.getPriceByBookId(bookId);</span><br><span class="line">    <span class="comment">//更新图书的库存</span></span><br><span class="line">    bookDao.updateStock(bookId);</span><br><span class="line">    <span class="comment">//更新用户的余额</span></span><br><span class="line">    bookDao.updateBalance(userId, price);</span><br><span class="line">    System.out.println(<span class="number">1</span>/<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>③观察结果</strong></p><p>虽然购买图书功能中出现了数学运算异常（ArithmeticException），但是我们设置的回滚策略是，当出现ArithmeticException不发生回滚，因此购买图书的操作正常执行</p><h4 id="7-3-8、事务属性：隔离级别"><a href="#7-3-8、事务属性：隔离级别" class="headerlink" title="7.3.8、事务属性：隔离级别"></a>7.3.8、事务属性：隔离级别</h4><p><strong>①介绍</strong></p><p>数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。一个事务与其他事务隔离的程度称为隔离级别。SQL标准中规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。</p><p>隔离级别一共有四种：</p><ul><li><p>读未提交：READ UNCOMMITTED</p><p>允许Transaction01读取Transaction02未提交的修改。</p></li><li><p>读已提交：READ COMMITTED、</p><p>要求Transaction01只能读取Transaction02已提交的修改。</p></li><li><p>可重复读：REPEATABLE READ</p><p>确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其它事务对这个字段进行更新。</p></li><li><p>串行化：SERIALIZABLE</p><p>确保Transaction01可以多次从一个表中读取到相同的行，在Transaction01执行期间，禁止其它事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。</p></li></ul><p>各个隔离级别解决并发问题的能力见下表：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>有</td><td>有</td><td>有</td></tr><tr><td>READ COMMITTED</td><td>无</td><td>有</td><td>有</td></tr><tr><td>REPEATABLE READ</td><td>无</td><td>无</td><td>有</td></tr><tr><td>SERIALIZABLE</td><td>无</td><td>无</td><td>无</td></tr></tbody></table><p>各种数据库产品对事务隔离级别的支持程度：</p><table><thead><tr><th>隔离级别</th><th>Oracle</th><th>MySQL</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>×</td><td>√</td></tr><tr><td>READ COMMITTED</td><td>√(默认)</td><td>√</td></tr><tr><td>REPEATABLE READ</td><td>×</td><td>√(默认)</td></tr><tr><td>SERIALIZABLE</td><td>√</td><td>√</td></tr></tbody></table><p><strong>②使用方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(isolation = Isolation.DEFAULT)</span><span class="comment">//使用数据库默认的隔离级别</span></span><br><span class="line"><span class="meta">@Transactional(isolation = Isolation.READ_UNCOMMITTED)</span><span class="comment">//读未提交</span></span><br><span class="line"><span class="meta">@Transactional(isolation = Isolation.READ_COMMITTED)</span><span class="comment">//读已提交</span></span><br><span class="line"><span class="meta">@Transactional(isolation = Isolation.REPEATABLE_READ)</span><span class="comment">//可重复读</span></span><br><span class="line"><span class="meta">@Transactional(isolation = Isolation.SERIALIZABLE)</span><span class="comment">//串行化</span></span><br></pre></td></tr></table></figure><h4 id="7-3-9、事务属性：传播行为"><a href="#7-3-9、事务属性：传播行为" class="headerlink" title="7.3.9、事务属性：传播行为"></a>7.3.9、事务属性：传播行为</h4><p><strong>①介绍</strong></p><p>什么是事务的传播行为？</p><p>在service类中有a()方法和b()方法，a()方法上有事务，b()方法上也有事务，当a()方法执行过程中调用了b()方法，事务是如何传递的？合并到一个事务里？还是开启一个新的事务？这就是事务传播行为。</p><p>一共有七种传播行为：</p><ul><li>REQUIRED：支持当前事务，如果不存在就新建一个(默认)<strong>【没有就新建，有就加入】</strong></li><li>SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行<strong>【有就加入，没有就不管了】</strong></li><li>MANDATORY：必须运行在一个事务中，如果当前没有事务正在发生，将抛出一个异常<strong>【有就加入，没有就抛异常】</strong></li><li>REQUIRES_NEW：开启一个新的事务，如果一个事务已经存在，则将这个存在的事务挂起<strong>【不管有没有，直接开启一个新事务，开启的新事务和之前的事务不存在嵌套关系，之前事务被挂起】</strong></li><li>NOT_SUPPORTED：以非事务方式运行，如果有事务存在，挂起当前事务<strong>【不支持事务，存在就挂起】</strong></li><li>NEVER：以非事务方式运行，如果有事务存在，抛出异常<strong>【不支持事务，存在就抛异常】</strong></li><li>NESTED：如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于外层事务进行提交或回滚。如果外层事务不存在，行为就像REQUIRED一样。<strong>【有事务的话，就在这个事务里再嵌套一个完全独立的事务，嵌套的事务可以独立的提交和回滚。没有事务就和REQUIRED一样。】</strong></li></ul><p><strong>②测试</strong></p><p>创建接口CheckoutService：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CheckoutService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">checkout</span><span class="params">(Integer[] bookIds, Integer userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建实现类CheckoutServiceImpl：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckoutServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CheckoutService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="comment">//一次购买多本图书</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkout</span><span class="params">(Integer[] bookIds, Integer userId)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer bookId : bookIds) &#123;</span><br><span class="line">            bookService.buyBook(bookId, userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在BookController中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CheckoutService checkoutService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkout</span><span class="params">(Integer[] bookIds, Integer userId)</span>&#123;</span><br><span class="line">    checkoutService.checkout(bookIds, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在数据库中将用户的余额修改为100元</p><p><strong>③观察结果</strong></p><p>可以通过@Transactional中的propagation属性设置事务传播行为</p><p>修改BookServiceImpl中buyBook()上，注解@Transactional的propagation属性</p><p>@Transactional(propagation = Propagation.REQUIRED)，默认情况，表示如果当前线程上有已经开启的事务可用，那么就在这个事务中运行。经过观察，购买图书的方法buyBook()在checkout()中被调用，checkout()上有事务注解，因此在此事务中执行。所购买的两本图书的价格为80和50，而用户的余额为100，因此在购买第二本图书时余额不足失败，导致整个checkout()回滚，即只要有一本书买不了，就都买不了</p><p>@Transactional(propagation = Propagation.REQUIRES_NEW)，表示不管当前线程上是否有已经开启的事务，都要开启新事务。同样的场景，每次购买图书都是在buyBook()的事务中执行，因此第一本图书购买成功，事务结束，第二本图书购买失败，只在第二次的buyBook()中回滚，购买第一本图书不受影响，即能买几本就买几本。</p><h4 id="7-3-10、全注解配置事务"><a href="#7-3-10、全注解配置事务" class="headerlink" title="7.3.10、全注解配置事务"></a>7.3.10、全注解配置事务</h4><p><strong>①添加配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DataSourceTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.spring6&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/spring?characterEncoding=utf8&amp;useSSL=false&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;jdbcTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">getJdbcTemplate</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">getDataSourceTransactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">dataSourceTransactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        dataSourceTransactionManager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> dataSourceTransactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.spring6.config.SpringConfig;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.spring6.controller.BookController;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit.jupiter.SpringJUnitConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxByAllAnnotationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTxAllAnnotation</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookController</span> <span class="variable">accountService</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;bookController&quot;</span>, BookController.class);</span><br><span class="line">        accountService.buyBook(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4、基于XML的声明式事务"><a href="#7-4、基于XML的声明式事务" class="headerlink" title="7.4、基于XML的声明式事务"></a>7.4、基于XML的声明式事务</h3><h4 id="7-3-1、场景模拟"><a href="#7-3-1、场景模拟" class="headerlink" title="7.3.1、场景模拟"></a>7.3.1、场景模拟</h4><p>参考基于注解的声明式事务</p><h4 id="7-3-2、修改Spring配置文件"><a href="#7-3-2、修改Spring配置文件" class="headerlink" title="7.3.2、修改Spring配置文件"></a>7.3.2、修改Spring配置文件</h4><p>将Spring配置文件中去掉tx:annotation-driven 标签，并添加配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务通知和切入点表达式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.atguigu.spring.tx.xml.service.impl.*.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tx:advice标签：配置事务通知 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- id属性：给事务通知标签设置唯一标识，便于引用 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- transaction-manager属性：关联事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- tx:method标签：配置具体的事务方法 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- name属性：指定方法名，可以使用星号代表多个字符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;query*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">&lt;!-- read-only属性：设置只读属性 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- rollback-for属性：设置回滚的异常 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- no-rollback-for属性：设置不回滚的异常 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- isolation属性：设置事务的隔离级别 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- timeout属性：设置事务的超时属性 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- propagation属性：设置事务的传播行为 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;save*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;java.lang.Exception&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRES_NEW&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;java.lang.Exception&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRES_NEW&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;java.lang.Exception&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRES_NEW&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：基于xml实现的声明式事务，必须引入aspectJ的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="8、资源操作：Resources"><a href="#8、资源操作：Resources" class="headerlink" title="8、资源操作：Resources"></a>8、资源操作：Resources</h2><h3 id="8-1、Spring-Resources概述"><a href="#8-1、Spring-Resources概述" class="headerlink" title="8.1、Spring Resources概述"></a>8.1、Spring Resources概述</h3><p><img src="https://s2.loli.net/2023/10/10/abLTKOEx9i5f67s.png" alt="image-20221218154945878"></p><p><img src="https://s2.loli.net/2023/10/10/kMKx7ncUYP24gEN.png" alt="image-20221206231535991"></p><p>Java的标准java.net.URL类和各种URL前缀的标准处理程序无法满足所有对low-level资源的访问，比如：没有标准化的 URL 实现可用于访问需要从类路径或相对于 ServletContext 获取的资源。并且缺少某些Spring所需要的功能，例如检测某资源是否存在等。<strong>而Spring的Resource声明了访问low-level资源的能力。</strong></p><h3 id="8-2、Resource接口"><a href="#8-2、Resource接口" class="headerlink" title="8.2、Resource接口"></a>8.2、Resource接口</h3><p>Spring 的 Resource 接口位于 org.springframework.core.io 中。 旨在成为一个更强大的接口，用于抽象对低级资源的访问。以下显示了Resource接口定义的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Resource</span> <span class="keyword">extends</span> <span class="title class_">InputStreamSource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isReadable</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isFile</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    URL <span class="title function_">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    URI <span class="title function_">getURI</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    File <span class="title function_">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    ReadableByteChannel <span class="title function_">readableChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">contentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">lastModified</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    Resource <span class="title function_">createRelative</span><span class="params">(String relativePath)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getFilename</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Resource接口继承了InputStreamSource接口，提供了很多InputStreamSource所没有的方法。InputStreamSource接口，只有一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InputStreamSource</span> &#123;</span><br><span class="line"></span><br><span class="line">    InputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其中一些重要的方法：</strong></p><p>getInputStream(): 找到并打开资源，返回一个InputStream以从资源中读取。预计每次调用都会返回一个新的InputStream()，调用者有责任关闭每个流<br>exists(): 返回一个布尔值，表明某个资源是否以物理形式存在<br>isOpen: 返回一个布尔值，指示此资源是否具有开放流的句柄。如果为true，InputStream就不能够多次读取，只能够读取一次并且及时关闭以避免内存泄漏。对于所有常规资源实现，返回false，但是InputStreamResource除外。<br>getDescription(): 返回资源的描述，用来输出错误的日志。这通常是完全限定的文件名或资源的实际URL。</p><p><strong>其他方法：</strong></p><p>isReadable(): 表明资源的目录读取是否通过getInputStream()进行读取。<br>isFile(): 表明这个资源是否代表了一个文件系统的文件。<br>getURL(): 返回一个URL句柄，如果资源不能够被解析为URL，将抛出IOException<br>getURI(): 返回一个资源的URI句柄<br>getFile(): 返回某个文件，如果资源不能够被解析称为绝对路径，将会抛出FileNotFoundException<br>lastModified(): 资源最后一次修改的时间戳<br>createRelative(): 创建此资源的相关资源<br>getFilename(): 资源的文件名是什么 例如：最后一部分的文件名 myfile.txt</p><h3 id="8-3、Resource的实现类"><a href="#8-3、Resource的实现类" class="headerlink" title="8.3、Resource的实现类"></a>8.3、Resource的实现类</h3><p>Resource 接口是 Spring 资源访问策略的抽象，它本身并不提供任何资源访问实现，具体的资源访问由该接口的实现类完成——每个实现类代表一种资源访问策略。Resource一般包括这些实现类：UrlResource、ClassPathResource、FileSystemResource、ServletContextResource、InputStreamResource、ByteArrayResource</p><h4 id="8-3-1、UrlResource访问网络资源"><a href="#8-3-1、UrlResource访问网络资源" class="headerlink" title="8.3.1、UrlResource访问网络资源"></a>8.3.1、UrlResource访问网络资源</h4><p>Resource的一个实现类，用来访问网络资源，它支持URL的绝对路径。</p><p>http:——该前缀用于访问基于HTTP协议的网络资源。</p><p>ftp:——该前缀用于访问基于FTP协议的网络资源</p><p>file: ——该前缀用于从文件系统中读取资源</p><p><strong>实验：访问基于HTTP协议的网络资源</strong></p><p><strong>创建一个maven子模块spring6-resources，配置Spring依赖（参考前面）</strong></p><p><img src="https://s2.loli.net/2023/10/10/veG9mxISgqzijdb.png" alt="image-20221207102315185"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.resources;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.UrlResource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UrlResourceDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadAndReadUrlResource</span><span class="params">(String path)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个 Resource 对象</span></span><br><span class="line">        <span class="type">UrlResource</span> <span class="variable">url</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            url = <span class="keyword">new</span> <span class="title class_">UrlResource</span>(path);</span><br><span class="line">            <span class="comment">// 获取资源名</span></span><br><span class="line">            System.out.println(url.getFilename());</span><br><span class="line">            System.out.println(url.getURI());</span><br><span class="line">            <span class="comment">// 获取资源描述</span></span><br><span class="line">            System.out.println(url.getDescription());</span><br><span class="line">            <span class="comment">//获取资源内容</span></span><br><span class="line">            System.out.println(url.getInputStream().read());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//访问网络资源</span></span><br><span class="line">        loadAndReadUrlResource(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实验二：在项目根路径下创建文件，从文件系统中读取资源</strong></p><p>方法不变，修改调用传递路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//1 访问网络资源</span></span><br><span class="line"><span class="comment">//loadAndReadUrlResource(&quot;http://www.atguigu.com&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2 访问文件系统资源</span></span><br><span class="line">    loadAndReadUrlResource(<span class="string">&quot;file:atguigu.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-2、ClassPathResource-访问类路径下资源"><a href="#8-3-2、ClassPathResource-访问类路径下资源" class="headerlink" title="8.3.2、ClassPathResource 访问类路径下资源"></a>8.3.2、ClassPathResource 访问类路径下资源</h4><p>ClassPathResource 用来访问类加载路径下的资源，相对于其他的 Resource 实现类，其主要优势是方便访问类加载路径里的资源，尤其对于 Web 应用，ClassPathResource 可自动搜索位于 classes 下的资源文件，无须使用绝对路径访问。</p><p><strong>实验：在类路径下创建文件atguigu.txt，使用ClassPathResource 访问</strong></p><p><img src="https://s2.loli.net/2023/10/10/BsQ1V2Fe5zfwpRJ.png" alt="image-20221207103020854"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.resources;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathResourceDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadAndReadUrlResource</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 创建一个 Resource 对象</span></span><br><span class="line">        <span class="type">ClassPathResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(path);</span><br><span class="line">        <span class="comment">// 获取文件名</span></span><br><span class="line">        System.out.println(<span class="string">&quot;resource.getFileName = &quot;</span> + resource.getFilename());</span><br><span class="line">        <span class="comment">// 获取文件描述</span></span><br><span class="line">        System.out.println(<span class="string">&quot;resource.getDescription = &quot;</span>+ resource.getDescription());</span><br><span class="line">        <span class="comment">//获取文件内容</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> resource.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>(in.read(b)!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        loadAndReadUrlResource(<span class="string">&quot;atguigu.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClassPathResource实例可使用ClassPathResource构造器显式地创建，但更多的时候它都是隐式地创建的。当执行Spring的某个方法时，该方法接受一个代表资源路径的字符串参数，当Spring识别该字符串参数中包含classpath:前缀后，系统会自动创建ClassPathResource对象。</p><h4 id="8-3-3、FileSystemResource-访问文件系统资源"><a href="#8-3-3、FileSystemResource-访问文件系统资源" class="headerlink" title="8.3.3、FileSystemResource 访问文件系统资源"></a>8.3.3、FileSystemResource 访问文件系统资源</h4><p>Spring 提供的 FileSystemResource 类用于访问文件系统资源，使用 FileSystemResource 来访问文件系统资源并没有太大的优势，因为 Java 提供的 File 类也可用于访问文件系统资源。</p><p><strong>实验：使用FileSystemResource 访问文件系统资源</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.resources;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.FileSystemResource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSystemResourceDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadAndReadUrlResource</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//相对路径</span></span><br><span class="line">        <span class="type">FileSystemResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="string">&quot;atguigu.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//绝对路径</span></span><br><span class="line">        <span class="comment">//FileSystemResource resource = new FileSystemResource(&quot;C:\\atguigu.txt&quot;);</span></span><br><span class="line">        <span class="comment">// 获取文件名</span></span><br><span class="line">        System.out.println(<span class="string">&quot;resource.getFileName = &quot;</span> + resource.getFilename());</span><br><span class="line">        <span class="comment">// 获取文件描述</span></span><br><span class="line">        System.out.println(<span class="string">&quot;resource.getDescription = &quot;</span>+ resource.getDescription());</span><br><span class="line">        <span class="comment">//获取文件内容</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> resource.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>(in.read(b)!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        loadAndReadUrlResource(<span class="string">&quot;atguigu.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FileSystemResource实例可使用FileSystemResource构造器显示地创建，但更多的时候它都是隐式创建。执行Spring的某个方法时，该方法接受一个代表资源路径的字符串参数，当Spring识别该字符串参数中包含file:前缀后，系统将会自动创建FileSystemResource对象。</p><h4 id="8-3-4、ServletContextResource"><a href="#8-3-4、ServletContextResource" class="headerlink" title="8.3.4、ServletContextResource"></a>8.3.4、ServletContextResource</h4><p>这是ServletContext资源的Resource实现，它解释相关Web应用程序根目录中的相对路径。它始终支持流(stream)访问和URL访问，但只有在扩展Web应用程序存档且资源实际位于文件系统上时才允许java.io.File访问。无论它是在文件系统上扩展还是直接从JAR或其他地方（如数据库）访问，实际上都依赖于Servlet容器。</p><h4 id="8-3-5、InputStreamResource"><a href="#8-3-5、InputStreamResource" class="headerlink" title="8.3.5、InputStreamResource"></a>8.3.5、InputStreamResource</h4><p>InputStreamResource 是给定的输入流(InputStream)的Resource实现。它的使用场景在没有特定的资源实现的时候使用(感觉和@Component 的适用场景很相似)。与其他Resource实现相比，这是已打开资源的描述符。 因此，它的isOpen()方法返回true。如果需要将资源描述符保留在某处或者需要多次读取流，请不要使用它。</p><h4 id="8-3-6、ByteArrayResource"><a href="#8-3-6、ByteArrayResource" class="headerlink" title="8.3.6、ByteArrayResource"></a>8.3.6、ByteArrayResource</h4><p>字节数组的Resource实现类。通过给定的数组创建了一个ByteArrayInputStream。它对于从任何给定的字节数组加载内容非常有用，而无需求助于单次使用的InputStreamResource。</p><h3 id="8-4、Resource类图"><a href="#8-4、Resource类图" class="headerlink" title="8.4、Resource类图"></a>8.4、Resource类图</h3><p>上述Resource实现类与Resource顶级接口之间的关系可以用下面的UML关系模型来表示</p><p><img src="https://s2.loli.net/2023/10/10/l2wuZoBz6gcTqak.png" alt="image-20221206232920494"></p><h3 id="8-5、ResourceLoader-接口"><a href="#8-5、ResourceLoader-接口" class="headerlink" title="8.5、ResourceLoader 接口"></a>8.5、ResourceLoader 接口</h3><h4 id="8-5-1、ResourceLoader-概述"><a href="#8-5-1、ResourceLoader-概述" class="headerlink" title="8.5.1、ResourceLoader 概述"></a>8.5.1、ResourceLoader 概述</h4><p>Spring 提供如下两个标志性接口：</p><p><strong>（1）ResourceLoader ：</strong> 该接口实现类的实例可以获得一个Resource实例。</p><p><strong>（2） ResourceLoaderAware ：</strong> 该接口实现类的实例将获得一个ResourceLoader的引用。</p><p>在ResourceLoader接口里有如下方法：</p><p>（1）<strong>Resource getResource（String location）</strong> ： 该接口仅有这个方法，用于返回一个Resource实例。ApplicationContext实现类都实现ResourceLoader接口，因此ApplicationContext可直接获取Resource实例。</p><h4 id="8-5-2、使用演示"><a href="#8-5-2、使用演示" class="headerlink" title="8.5.2、使用演示"></a>8.5.2、使用演示</h4><p><strong>实验一：ClassPathXmlApplicationContext获取Resource实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.resouceloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>();</span><br><span class="line"><span class="comment">//        通过ApplicationContext访问资源</span></span><br><span class="line"><span class="comment">//        ApplicationContext实例获取Resource实例时，</span></span><br><span class="line"><span class="comment">//        默认采用与ApplicationContext相同的资源访问策略</span></span><br><span class="line">        <span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> ctx.getResource(<span class="string">&quot;atguigu.txt&quot;</span>);</span><br><span class="line">        System.out.println(res.getFilename());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实验二：FileSystemApplicationContext获取Resource实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.resouceloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>();</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> ctx.getResource(<span class="string">&quot;atguigu.txt&quot;</span>);</span><br><span class="line">        System.out.println(res.getFilename());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-5-3、ResourceLoader-总结"><a href="#8-5-3、ResourceLoader-总结" class="headerlink" title="8.5.3、ResourceLoader 总结"></a>8.5.3、ResourceLoader 总结</h4><p>Spring将采用和ApplicationContext相同的策略来访问资源。也就是说，如果ApplicationContext是FileSystemXmlApplicationContext，res就是FileSystemResource实例；如果ApplicationContext是ClassPathXmlApplicationContext，res就是ClassPathResource实例</p><p>当Spring应用需要进行资源访问时，实际上并不需要直接使用Resource实现类，而是调用ResourceLoader实例的getResource()方法来获得资源，ReosurceLoader将会负责选择Reosurce实现类，也就是确定具体的资源访问策略，从而将应用程序和具体的资源访问策略分离开来</p><p>另外，使用ApplicationContext访问资源时，可通过不同前缀指定强制使用指定的ClassPathResource、FileSystemResource等实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> ctx.getResource(<span class="string">&quot;calsspath:bean.xml&quot;</span>);</span><br><span class="line"><span class="type">Resrouce</span> <span class="variable">res</span> <span class="operator">=</span> ctx.getResource(<span class="string">&quot;file:bean.xml&quot;</span>);</span><br><span class="line"><span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> ctx.getResource(<span class="string">&quot;http://localhost:8080/beans.xml&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="8-6、ResourceLoaderAware-接口"><a href="#8-6、ResourceLoaderAware-接口" class="headerlink" title="8.6、ResourceLoaderAware 接口"></a>8.6、ResourceLoaderAware 接口</h3><p>ResourceLoaderAware接口实现类的实例将获得一个ResourceLoader的引用，ResourceLoaderAware接口也提供了一个setResourceLoader()方法，该方法将由Spring容器负责调用，Spring容器会将一个ResourceLoader对象作为该方法的参数传入。</p><p>如果把实现ResourceLoaderAware接口的Bean类部署在Spring容器中，Spring容器会将自身当成ResourceLoader作为setResourceLoader()方法的参数传入。由于ApplicationContext的实现类都实现了ResourceLoader接口，Spring容器自身完全可作为ResorceLoader使用。</p><p><strong>实验：演示ResourceLoaderAware使用</strong></p><p><strong>第一步 创建类，实现ResourceLoaderAware接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.resouceloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ResourceLoaderAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ResourceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBean</span> <span class="keyword">implements</span> <span class="title class_">ResourceLoaderAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现ResourceLoaderAware接口必须实现的方法</span></span><br><span class="line"><span class="comment">//如果把该Bean部署在Spring容器中，该方法将会有Spring容器负责调用。</span></span><br><span class="line"><span class="comment">//SPring容器调用该方法时，Spring会将自身作为参数传给该方法。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回ResourceLoader对象的应用</span></span><br><span class="line">    <span class="keyword">public</span> ResourceLoader <span class="title function_">getResourceLoader</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步 创建bean.xml文件，配置TestBean</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.resouceloader.TestBean&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第三步 测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.resouceloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ResourceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Spring容器会将一个ResourceLoader对象作为该方法的参数传入</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="type">TestBean</span> <span class="variable">testBean</span> <span class="operator">=</span> ctx.getBean(<span class="string">&quot;testBean&quot;</span>,TestBean.class);</span><br><span class="line">        <span class="comment">//获取ResourceLoader对象</span></span><br><span class="line">        <span class="type">ResourceLoader</span> <span class="variable">resourceLoader</span> <span class="operator">=</span> testBean.getResourceLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;Spring容器将自身注入到ResourceLoaderAware Bean 中 ？ ：&quot;</span> + (resourceLoader == ctx));</span><br><span class="line">        <span class="comment">//加载其他资源</span></span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> resourceLoader.getResource(<span class="string">&quot;atguigu.txt&quot;</span>);</span><br><span class="line">        System.out.println(resource.getFilename());</span><br><span class="line">        System.out.println(resource.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-7、使用Resource-作为属性"><a href="#8-7、使用Resource-作为属性" class="headerlink" title="8.7、使用Resource 作为属性"></a>8.7、使用Resource 作为属性</h3><p>前面介绍了 Spring 提供的资源访问策略，但这些依赖访问策略要么需要使用 Resource 实现类，要么需要使用 ApplicationContext 来获取资源。实际上，当应用程序中的 Bean 实例需要访问资源时，Spring 有更好的解决方法：直接利用依赖注入。从这个意义上来看，Spring 框架不仅充分利用了策略模式来简化资源访问，而且还将策略模式和 IoC 进行充分地结合，最大程度地简化了 Spring 资源访问。</p><p>归纳起来，<strong>如果 Bean 实例需要访问资源，有如下两种解决方案：</strong></p><ul><li><strong>代码中获取 Resource 实例。</strong></li><li><strong>使用依赖注入。</strong></li></ul><p>对于第一种方式，当程序获取 Resource 实例时，总需要提供 Resource 所在的位置，不管通过 FileSystemResource 创建实例，还是通过 ClassPathResource 创建实例，或者通过 ApplicationContext 的 getResource() 方法获取实例，都需要提供资源位置。这意味着：资源所在的物理位置将被耦合到代码中，如果资源位置发生改变，则必须改写程序。因此，通常建议采用第二种方法，让 Spring 为 Bean 实例<strong>依赖注入</strong>资源。</p><p><strong>实验：让Spring为Bean实例依赖注入资源</strong></p><p><strong>第一步 创建依赖注入类，定义属性和方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.resouceloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceBean</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Resource res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRes</span><span class="params">(Resource res)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.res = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Resource <span class="title function_">getRes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(res.getFilename());</span><br><span class="line">        System.out.println(res.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步 创建spring配置文件，配置依赖注入</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;resourceBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.resouceloader.ResourceBean&quot;</span> &gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 可以使用file:、http:、ftp:等前缀强制Spring采用对应的资源访问策略 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 如果不采用任何前缀，则Spring将采用与该ApplicationContext相同的资源访问策略来访问资源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;res&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:atguigu.txt&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第三步 测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.resouceloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="type">ResourceBean</span> <span class="variable">resourceBean</span> <span class="operator">=</span> ctx.getBean(<span class="string">&quot;resourceBean&quot;</span>,ResourceBean.class);</span><br><span class="line">        resourceBean.parse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-8、应用程序上下文和资源路径"><a href="#8-8、应用程序上下文和资源路径" class="headerlink" title="8.8、应用程序上下文和资源路径"></a>8.8、应用程序上下文和资源路径</h3><h4 id="8-8-1、概述"><a href="#8-8-1、概述" class="headerlink" title="8.8.1、概述"></a>8.8.1、概述</h4><p>不管以怎样的方式创建ApplicationContext实例，都需要为ApplicationContext指定配置文件，Spring允许使用一份或多分XML配置文件。当程序创建ApplicationContext实例时，通常也是以Resource的方式来访问配置文件的，所以ApplicationContext完全支持ClassPathResource、FileSystemResource、ServletContextResource等资源访问方式。</p><p><strong>ApplicationContext确定资源访问策略通常有两种方法：</strong></p><p><strong>（1）使用ApplicationContext实现类指定访问策略。</strong></p><p><strong>（2）使用前缀指定访问策略。</strong></p><h4 id="8-8-2、ApplicationContext实现类指定访问策略"><a href="#8-8-2、ApplicationContext实现类指定访问策略" class="headerlink" title="8.8.2、ApplicationContext实现类指定访问策略"></a>8.8.2、ApplicationContext实现类指定访问策略</h4><p>创建ApplicationContext对象时，通常可以使用如下实现类：</p><p>（1） ClassPathXMLApplicationContext : 对应使用ClassPathResource进行资源访问。</p><p>（2）FileSystemXmlApplicationContext ： 对应使用FileSystemResource进行资源访问。</p><p>（3）XmlWebApplicationContext ： 对应使用ServletContextResource进行资源访问。</p><p>当使用ApplicationContext的不同实现类时，就意味着Spring使用响应的资源访问策略。</p><p>效果前面已经演示</p><h4 id="8-8-3、使用前缀指定访问策略"><a href="#8-8-3、使用前缀指定访问策略" class="headerlink" title="8.8.3、使用前缀指定访问策略"></a>8.8.3、使用前缀指定访问策略</h4><p><strong>实验一：classpath前缀使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过搜索文件系统路径下的xml文件创建ApplicationContext，</span></span><br><span class="line"><span class="comment">         * 但通过指定classpath:前缀强制搜索类加载路径</span></span><br><span class="line"><span class="comment">         * classpath:bean.xml</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:bean.xml&quot;</span>);</span><br><span class="line">        System.out.println(ctx);</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> ctx.getResource(<span class="string">&quot;atguigu.txt&quot;</span>);</span><br><span class="line">        System.out.println(resource.getFilename());</span><br><span class="line">        System.out.println(resource.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实验二：classpath通配符使用</strong></p><p>classpath * :前缀提供了加载多个XML配置文件的能力，当使用classpath*:前缀来指定XML配置文件时，系统将搜索类加载路径，找到所有与文件名匹配的文件，分别加载文件中的配置定义，最后合并成一个ApplicationContext。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath*:bean.xml&quot;</span>);</span><br><span class="line">System.out.println(ctx);</span><br></pre></td></tr></table></figure><p>当使用classpath * :前缀时，Spring将会搜索类加载路径下所有满足该规则的配置文件。</p><p>如果不是采用classpath * :前缀，而是改为使用classpath:前缀，Spring则只加载第一个符合条件的XML文件</p><p><strong>注意 ：</strong> </p><p>classpath * : 前缀仅对ApplicationContext有效。实际情况是，创建ApplicationContext时，分别访问多个配置文件(通过ClassLoader的getResource方法实现)。因此，classpath * :前缀不可用于Resource。</p><p><strong>使用三：通配符其他使用</strong></p><p>一次性加载多个配置文件的方式：指定配置文件时使用通配符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:bean*.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>Spring允许将classpath*:前缀和通配符结合使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath*:bean*.xml&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="9、国际化：i18n"><a href="#9、国际化：i18n" class="headerlink" title="9、国际化：i18n"></a>9、国际化：i18n</h2><p><img src="https://s2.loli.net/2023/10/10/puD7WoNTtGjO1L6.png" alt="image-20221218154728062"></p><h3 id="9-1、i18n概述"><a href="#9-1、i18n概述" class="headerlink" title="9.1、i18n概述"></a>9.1、i18n概述</h3><p>国际化也称作i18n，其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数。由于软件发行可能面向多个国家，对于不同国家的用户，软件显示不同语言的过程就是国际化。通常来讲，软件中的国际化是通过配置文件来实现的，假设要支撑两种语言，那么就需要两个版本的配置文件。</p><h3 id="9-2、Java国际化"><a href="#9-2、Java国际化" class="headerlink" title="9.2、Java国际化"></a>9.2、Java国际化</h3><p>（1）Java自身是支持国际化的，java.util.Locale用于指定当前用户所属的语言环境等信息，java.util.ResourceBundle用于查找绑定对应的资源文件。Locale包含了language信息和country信息，Locale创建默认locale对象时使用的静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method must be called only for creating the Locale.*</span></span><br><span class="line"><span class="comment"> * constants due to making shortcuts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Locale <span class="title function_">createConstant</span><span class="params">(String lang, String country)</span> &#123;</span><br><span class="line">    <span class="type">BaseLocale</span> <span class="variable">base</span> <span class="operator">=</span> BaseLocale.createInstance(lang, country);</span><br><span class="line">    <span class="keyword">return</span> getInstance(base, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）配置文件命名规则：<br> <strong>basename_language_country.properties</strong><br> 必须遵循以上的命名规则，java才会识别。其中，basename是必须的，语言和国家是可选的。这里存在一个优先级概念，如果同时提供了messages.properties和messages_zh_CN.propertes两个配置文件，如果提供的locale符合en_CN，那么优先查找messages_en_CN.propertes配置文件，如果没查找到，再查找messages.properties配置文件。最后，提示下，所有的配置文件必须放在classpath中，一般放在resources目录下</p><p><strong>（3）实验：演示Java国际化</strong></p><p><strong>第一步 创建子模块spring6-i18n，引入spring依赖</strong></p><p><img src="https://s2.loli.net/2023/10/10/MH4fgT1nZ3AylVF.png" alt="image-20221207122500801"></p><p><strong>第二步 在resource目录下创建两个配置文件：messages_zh_CN.propertes和messages_en_GB.propertes</strong></p><p><img src="https://s2.loli.net/2023/10/10/blqm5Ug97wonWFS.png" alt="image-20221207124839565"></p><p><strong>第三步 测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.javai18n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(ResourceBundle.getBundle(<span class="string">&quot;messages&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Locale</span>(<span class="string">&quot;en&quot;</span>,<span class="string">&quot;GB&quot;</span>)).getString(<span class="string">&quot;test&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(ResourceBundle.getBundle(<span class="string">&quot;messages&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Locale</span>(<span class="string">&quot;zh&quot;</span>,<span class="string">&quot;CN&quot;</span>)).getString(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3、Spring6国际化"><a href="#9-3、Spring6国际化" class="headerlink" title="9.3、Spring6国际化"></a>9.3、Spring6国际化</h3><h4 id="9-3-1、MessageSource接口"><a href="#9-3-1、MessageSource接口" class="headerlink" title="9.3.1、MessageSource接口"></a>9.3.1、MessageSource接口</h4><p>spring中国际化是通过MessageSource这个接口来支持的</p><p><strong>常见实现类</strong></p><p><strong>ResourceBundleMessageSource</strong></p><p>这个是基于Java的ResourceBundle基础类实现，允许仅通过资源名加载国际化资源</p><p><strong>ReloadableResourceBundleMessageSource</strong></p><p>这个功能和第一个类的功能类似，多了定时刷新功能，允许在不重启系统的情况下，更新资源的信息</p><p><strong>StaticMessageSource</strong></p><p>它允许通过编程的方式提供国际化信息，一会我们可以通过这个来实现db中存储国际化信息的功能。</p><h4 id="9-3-2、使用Spring6国际化"><a href="#9-3-2、使用Spring6国际化" class="headerlink" title="9.3.2、使用Spring6国际化"></a>9.3.2、使用Spring6国际化</h4><p><strong>第一步 创建资源文件</strong></p><p><strong>国际化文件命名格式：基本名称 _ 语言 _ 国家.properties</strong></p><p><strong>{0},{1}这样内容，就是动态参数</strong></p><p><img src="https://s2.loli.net/2023/10/10/SkurJvCWXoBjGaK.png" alt="image-20221207140024056"></p><p><strong>（1）创建atguigu_en_US.properties</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">www.atguigu.com</span>=<span class="string">welcome &#123;0&#125;,时间:&#123;1&#125;</span></span><br></pre></td></tr></table></figure><p><strong>（2）创建atguigu_zh_CN.properties</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">www.atguigu.com</span>=<span class="string">欢迎 &#123;0&#125;,时间:&#123;1&#125;</span></span><br></pre></td></tr></table></figure><p><strong>第二步 创建spring配置文件，配置MessageSource</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageSource&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basenames&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>atguigu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第三步 创建测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.javai18n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//传递动态参数，使用数组形式对应&#123;0&#125; &#123;1&#125;顺序</span></span><br><span class="line">        Object[] objs = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;atguigu&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>().toString()&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//www.atguigu.com为资源文件的key值,</span></span><br><span class="line">        <span class="comment">//objs为资源文件value值所需要的参数,Local.CHINA为国际化为语言</span></span><br><span class="line">        String str=context.getMessage(<span class="string">&quot;www.atguigu.com&quot;</span>, objs, Locale.CHINA);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、数据校验：Validation"><a href="#10、数据校验：Validation" class="headerlink" title="10、数据校验：Validation"></a>10、数据校验：Validation</h2><p><img src="https://s2.loli.net/2023/10/10/t4Pm9kzngKTUrLe.png" alt="image-20221218154808754"></p><h3 id="10-1、Spring-Validation概述"><a href="#10-1、Spring-Validation概述" class="headerlink" title="10.1、Spring Validation概述"></a>10.1、Spring Validation概述</h3><p><img src="https://s2.loli.net/2023/10/10/mEAJ68IdHg9ex27.png" alt="image-20221206220207266"></p><p>在开发中，我们经常遇到参数校验的需求，比如用户注册的时候，要校验用户名不能为空、用户名长度不超过20个字符、手机号是合法的手机号格式等等。如果使用普通方式，我们会把校验的代码和真正的业务处理逻辑耦合在一起，而且如果未来要新增一种校验逻辑也需要在修改多个地方。而spring validation允许通过注解的方式来定义对象校验规则，把校验和业务逻辑分离开，让代码编写更加方便。Spring Validation其实就是对Hibernate Validator进一步的封装，方便在Spring中使用。</p><p>在Spring中有多种校验的方式</p><p><strong>第一种是通过实现org.springframework.validation.Validator接口，然后在代码中调用这个类</strong></p><p><strong>第二种是按照Bean Validation方式来进行校验，即通过注解的方式。</strong></p><p><strong>第三种是基于方法实现校验</strong></p><p><strong>除此之外，还可以实现自定义校验</strong></p><h3 id="10-2、实验一：通过Validator接口实现"><a href="#10-2、实验一：通过Validator接口实现" class="headerlink" title="10.2、实验一：通过Validator接口实现"></a>10.2、实验一：通过Validator接口实现</h3><p><strong>第一步 创建子模块 spring6-validator</strong></p><p><img src="https://s2.loli.net/2023/10/10/wcZeC9JAsmhxTQz.png" alt="image-20221206221002615"></p><p><strong>第二步 引入相关依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.0.5.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.el<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第三步 创建实体类，定义属性和方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.validation.method1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第四步 创建类实现Validator接口，实现接口方法指定校验规则</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.validation.method1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.Errors;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.ValidationUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.Validator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Person.class.equals(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(Object object, Errors errors)</span> &#123;</span><br><span class="line">        ValidationUtils.rejectIfEmpty(errors, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;name.empty&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) object;</span><br><span class="line">        <span class="keyword">if</span> (p.getAge() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            errors.rejectValue(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;error value &lt; 0&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.getAge() &gt; <span class="number">110</span>) &#123;</span><br><span class="line">            errors.rejectValue(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;error value too old&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义的类，其实就是实现接口中对应的方法，</p><p>supports方法用来表示此校验用在哪个类型上，</p><p>validate是设置校验逻辑的地点，其中ValidationUtils，是Spring封装的校验工具类，帮助快速实现校验。</p><p><strong>第五步 使用上述Validator进行测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.validation.method1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.BindingResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.DataBinder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMethod1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建person对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.setName(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        person.setAge(-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建Person对应的DataBinder</span></span><br><span class="line">        <span class="type">DataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataBinder</span>(person);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置校验</span></span><br><span class="line">        binder.setValidator(<span class="keyword">new</span> <span class="title class_">PersonValidator</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于Person对象中的属性为空，所以校验不通过</span></span><br><span class="line">        binder.validate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        <span class="type">BindingResult</span> <span class="variable">results</span> <span class="operator">=</span> binder.getBindingResult();</span><br><span class="line">        System.out.println(results.getAllErrors());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3、实验二：Bean-Validation注解实现"><a href="#10-3、实验二：Bean-Validation注解实现" class="headerlink" title="10.3、实验二：Bean Validation注解实现"></a>10.3、实验二：Bean Validation注解实现</h3><p>使用Bean Validation校验方式，就是如何将Bean Validation需要使用的javax.validation.ValidatorFactory 和javax.validation.Validator注入到容器中。spring默认有一个实现类LocalValidatorFactoryBean，它实现了上面Bean Validation中的接口，并且也实现了org.springframework.validation.Validator接口。</p><p><strong>第一步 创建配置类，配置LocalValidatorFactoryBean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.spring6.validation.method2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidationConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LocalValidatorFactoryBean <span class="title function_">validator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalValidatorFactoryBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步 创建实体类，使用注解定义校验规则</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.validation.method2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.validation.constraints.Max;</span><br><span class="line"><span class="keyword">import</span> jakarta.validation.constraints.Min;</span><br><span class="line"><span class="keyword">import</span> jakarta.validation.constraints.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min(0)</span></span><br><span class="line">    <span class="meta">@Max(120)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常用注解说明</strong><br>@NotNull    限制必须不为null<br>@NotEmpty    只作用于字符串类型，字符串不为空，并且长度不为0<br>@NotBlank    只作用于字符串类型，字符串不为空，并且trim()后不为空串<br>@DecimalMax(value)    限制必须为一个不大于指定值的数字<br>@DecimalMin(value)    限制必须为一个不小于指定值的数字<br>@Max(value)    限制必须为一个不大于指定值的数字<br>@Min(value)    限制必须为一个不小于指定值的数字<br>@Pattern(value)    限制必须符合指定的正则表达式<br>@Size(max,min)    限制字符长度必须在min到max之间<br>@Email    验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式</p><p><strong>第三步 使用两种不同的校验器实现</strong></p><p><strong>（1）使用jakarta.validation.Validator校验</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.validation.method2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.validation.ConstraintViolation;</span><br><span class="line"><span class="keyword">import</span> jakarta.validation.Validator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Validator validator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="type">boolean</span> <span class="title function_">validator</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        Set&lt;ConstraintViolation&lt;User&gt;&gt; sets =  validator.validate(user);</span><br><span class="line">        <span class="keyword">return</span> sets.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）使用org.springframework.validation.Validator校验</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.validation.method2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.BindException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.Validator;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Validator validator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validaPersonByValidator</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">BindException</span> <span class="variable">bindException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BindException</span>(user, user.getName());</span><br><span class="line">        validator.validate(user, bindException);</span><br><span class="line">        <span class="keyword">return</span> bindException.hasErrors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第四步 测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.validation.method2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMethod2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMyService1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ValidationConfig.class);</span><br><span class="line">        <span class="type">MyService1</span> <span class="variable">myService</span> <span class="operator">=</span> context.getBean(MyService1.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setAge(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">validator</span> <span class="operator">=</span> myService.validator(user);</span><br><span class="line">        System.out.println(validator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMyService2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ValidationConfig.class);</span><br><span class="line">        <span class="type">MyService2</span> <span class="variable">myService</span> <span class="operator">=</span> context.getBean(MyService2.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">130</span>);</span><br><span class="line">        user.setAge(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">validator</span> <span class="operator">=</span> myService.validaPersonByValidator(user);</span><br><span class="line">        System.out.println(validator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-4、实验三：基于方法实现校验"><a href="#10-4、实验三：基于方法实现校验" class="headerlink" title="10.4、实验三：基于方法实现校验"></a>10.4、实验三：基于方法实现校验</h3><p><strong>第一步 创建配置类，配置MethodValidationPostProcessor</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.validation.method3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.beanvalidation.MethodValidationPostProcessor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.spring6.validation.method3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidationConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MethodValidationPostProcessor <span class="title function_">validationPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MethodValidationPostProcessor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步 创建实体类，使用注解设置校验规则</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.validation.method3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.validation.constraints.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min(0)</span></span><br><span class="line">    <span class="meta">@Max(120)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;^1(3|4|5|7|8)\\d&#123;9&#125;$&quot;,message = &quot;手机号码格式错误&quot;)</span></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;手机号码不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三步 定义Service类，通过注解操作对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.validation.method3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.validation.Valid;</span><br><span class="line"><span class="keyword">import</span> jakarta.validation.constraints.NotNull;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.annotation.Validated;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testParams</span><span class="params">(<span class="meta">@NotNull</span> <span class="meta">@Valid</span> User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第四步 测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.validation.method3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMethod3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMyService1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ValidationConfig.class);</span><br><span class="line">        <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> context.getBean(MyService.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setAge(-<span class="number">1</span>);</span><br><span class="line">        myService.testParams(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-5、实验四：实现自定义校验"><a href="#10-5、实验四：实现自定义校验" class="headerlink" title="10.5、实验四：实现自定义校验"></a>10.5、实验四：实现自定义校验</h3><p><strong>第一步 自定义校验注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.validation.method4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.validation.Constraint;</span><br><span class="line"><span class="keyword">import</span> jakarta.validation.Payload;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123;CannotBlankValidator.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CannotBlank &#123;</span><br><span class="line">    <span class="comment">//默认错误消息</span></span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;不能包含空格&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分组</span></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//负载</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定多个时使用</span></span><br><span class="line">    <span class="meta">@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)</span></span><br><span class="line">    <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@interface</span> List &#123;</span><br><span class="line">        CannotBlank[] value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步 编写真正的校验类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spring6.validation.method4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.validation.ConstraintValidator;</span><br><span class="line"><span class="keyword">import</span> jakarta.validation.ConstraintValidatorContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CannotBlankValidator</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;CannotBlank, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(CannotBlank constraintAnnotation)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> &#123;</span><br><span class="line">                <span class="comment">//null时不进行校验</span></span><br><span class="line">                <span class="keyword">if</span> (value != <span class="literal">null</span> &amp;&amp; value.contains(<span class="string">&quot; &quot;</span>)) &#123;</span><br><span class="line">                        <span class="comment">//获取默认提示信息</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">defaultConstraintMessageTemplate</span> <span class="operator">=</span> context.getDefaultConstraintMessageTemplate();</span><br><span class="line">                        System.out.println(<span class="string">&quot;default message :&quot;</span> + defaultConstraintMessageTemplate);</span><br><span class="line">                        <span class="comment">//禁用默认提示信息</span></span><br><span class="line">                        context.disableDefaultConstraintViolation();</span><br><span class="line">                        <span class="comment">//设置提示语</span></span><br><span class="line">                        context.buildConstraintViolationWithTemplate(<span class="string">&quot;can not contains blank&quot;</span>).addConstraintViolation();</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11、提前编译：AOT"><a href="#11、提前编译：AOT" class="headerlink" title="11、提前编译：AOT"></a>11、提前编译：AOT</h2><p><img src="https://s2.loli.net/2023/10/10/yf6bPGpmAXn2edv.png" alt="image-20221218154841001"></p><h3 id="11-1、AOT概述"><a href="#11-1、AOT概述" class="headerlink" title="11.1、AOT概述"></a>11.1、AOT概述</h3><h4 id="11-1-1、JIT与AOT的区别"><a href="#11-1-1、JIT与AOT的区别" class="headerlink" title="11.1.1、JIT与AOT的区别"></a>11.1.1、JIT与AOT的区别</h4><p>JIT和AOT 这个名词是指两种不同的编译方式，这两种编译方式的主要区别在于是否在“运行时”进行编译</p><p><strong>（1）JIT， Just-in-time,动态(即时)编译，边运行边编译；</strong></p><p>在程序运行时，根据算法计算出热点代码，然后进行 JIT 实时编译，这种方式吞吐量高，有运行时性能加成，可以跑得更快，并可以做到动态生成代码等，但是相对启动速度较慢，并需要一定时间和调用频率才能触发 JIT 的分层机制。JIT 缺点就是编译需要占用运行时资源，会导致进程卡顿。</p><p><strong>（2）AOT，Ahead Of Time，指运行前编译，预先编译。</strong></p><p>AOT 编译能直接将源代码转化为机器码，内存占用低，启动速度快，可以无需 runtime 运行，直接将 runtime 静态链接至最终的程序中，但是无运行时性能加成，不能根据程序运行情况做进一步的优化，AOT 缺点就是在程序运行前编译会使程序安装的时间增加。                                                           </p><p><strong>简单来讲：</strong>JIT即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.java -&gt; .class -&gt; (使用jaotc编译工具) -&gt; .so（程序函数库,即编译好的可以供其他程序使用的代码和数据）</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/10/10/fL9mMCHTc3D6kOV.png" alt="image-20221207113544080"></p><p><strong>（3）AOT的优点</strong></p><p><strong>简单来讲，</strong>Java 虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少 Java 应用给人带来“第一次运行慢” 的不良体验。</p><p>在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗<br>可以在程序运行初期就达到最高性能，程序启动速度快<br>运行产物只有机器码，打包体积小</p><p><strong>AOT的缺点</strong></p><p>由于是静态提前编译，不能根据硬件情况或程序运行情况择优选择机器指令序列，理论峰值性能不如JIT<br>没有动态能力，同一份产物不能跨平台运行</p><p>第一种即时编译 (JIT) 是默认模式，Java Hotspot 虚拟机使用它在运行时将字节码转换为机器码。后者提前编译 (AOT)由新颖的 GraalVM 编译器支持，并允许在构建时将字节码直接静态编译为机器码。</p><p>现在正处于云原生，降本增效的时代，Java 相比于 Go、Rust 等其他编程语言非常大的弊端就是启动编译和启动进程非常慢，这对于根据实时计算资源，弹性扩缩容的云原生技术相冲突，Spring6 借助 AOT 技术在运行时内存占用低，启动速度快，逐渐的来满足 Java 在云原生时代的需求，对于大规模使用 Java 应用的商业公司可以考虑尽早调研使用 JDK17，通过云原生技术为公司实现降本增效。</p><h4 id="11-1-2、Graalvm"><a href="#11-1-2、Graalvm" class="headerlink" title="11.1.2、Graalvm"></a>11.1.2、Graalvm</h4><p>Spring6 支持的 AOT 技术，这个 GraalVM  就是底层的支持，Spring 也对 GraalVM 本机映像提供了一流的支持。GraalVM 是一种高性能 JDK，旨在加速用 Java 和其他 JVM 语言编写的应用程序的执行，同时还为 JavaScript、Python 和许多其他流行语言提供运行时。 GraalVM 提供两种运行 Java 应用程序的方法：在 HotSpot JVM 上使用 Graal 即时 (JIT) 编译器或作为提前 (AOT) 编译的本机可执行文件。 GraalVM 的多语言能力使得在单个应用程序中混合多种编程语言成为可能，同时消除了外语调用成本。GraalVM 向 HotSpot Java 虚拟机添加了一个用 Java 编写的高级即时 (JIT) 优化编译器。</p><p>GraalVM 具有以下特性：</p><p>（1）一种高级优化编译器，它生成更快、更精简的代码，需要更少的计算资源</p><p>（2）AOT 本机图像编译提前将 Java 应用程序编译为本机二进制文件，立即启动，无需预热即可实现最高性能</p><p>（3）Polyglot 编程在单个应用程序中利用流行语言的最佳功能和库，无需额外开销</p><p>（4）高级工具在 Java 和多种语言中调试、监视、分析和优化资源消耗</p><p>总的来说对云原生的要求不算高短期内可以继续使用 2.7.X 的版本和 JDK8，不过 Spring 官方已经对 Spring6 进行了正式版发布。</p><h4 id="11-1-3、Native-Image"><a href="#11-1-3、Native-Image" class="headerlink" title="11.1.3、Native Image"></a>11.1.3、Native Image</h4><p>目前业界除了这种在JVM中进行AOT的方案，还有另外一种实现Java AOT的思路，那就是直接摒弃JVM，和C/C++一样通过编译器直接将代码编译成机器代码，然后运行。这无疑是一种直接颠覆Java语言设计的思路，那就是GraalVM Native Image。它通过C语言实现了一个超微缩的运行时组件 —— Substrate VM，基本实现了JVM的各种特性，但足够轻量、可以被轻松内嵌，这就让Java语言和工程摆脱JVM的限制，能够真正意义上实现和C/C++一样的AOT编译。这一方案在经过长时间的优化和积累后，已经拥有非常不错的效果，基本上成为Oracle官方首推的Java AOT解决方案。<br>Native Image 是一项创新技术，可将 Java 代码编译成独立的本机可执行文件或本机共享库。在构建本机可执行文件期间处理的 Java 字节码包括所有应用程序类、依赖项、第三方依赖库和任何所需的 JDK 类。生成的自包含本机可执行文件特定于不需要 JVM 的每个单独的操作系统和机器体系结构。</p><h3 id="11-2、演示Native-Image构建过程"><a href="#11-2、演示Native-Image构建过程" class="headerlink" title="11.2、演示Native Image构建过程"></a>11.2、演示Native Image构建过程</h3><h4 id="11-2-1、GraalVM安装"><a href="#11-2-1、GraalVM安装" class="headerlink" title="11.2.1、GraalVM安装"></a>11.2.1、GraalVM安装</h4><h5 id="（1）下载GraalVM"><a href="#（1）下载GraalVM" class="headerlink" title="（1）下载GraalVM"></a>（1）下载GraalVM</h5><p>进入官网下载：<a href="https://www.graalvm.org/downloads/">https://www.graalvm.org/downloads/</a></p><p><img src="https://s2.loli.net/2023/10/10/Z6V4UJd7OshFL5b.png" alt="image-20221207153944132"></p><p><img src="https://s2.loli.net/2023/10/10/bJe736qNG9cmjha.png" alt="image-20221207152841304"></p><h5 id="（2）配置环境变量"><a href="#（2）配置环境变量" class="headerlink" title="（2）配置环境变量"></a>（2）配置环境变量</h5><p><strong>添加GRAALVM_HOME</strong></p><p><img src="https://s2.loli.net/2023/10/10/Il9sKwPABSyinCe.png" alt="image-20221207110539954"></p><p><strong>把JAVA_HOME修改为graalvm的位置</strong></p><p><img src="https://s2.loli.net/2023/10/10/539lBJp16sMXFKY.png" alt="image-20221207153724340"></p><p><strong>把Path修改位graalvm的bin位置</strong></p><p><img src="https://s2.loli.net/2023/10/10/rkBNDstOGxoPi6J.png" alt="image-20221207153755732"></p><p><strong>使用命令查看是否安装成功</strong></p><p><img src="https://s2.loli.net/2023/10/10/bdCscMLe94vfQIi.png" alt="image-20221207153642253"></p><h5 id="（3）安装native-image插件"><a href="#（3）安装native-image插件" class="headerlink" title="（3）安装native-image插件"></a>（3）安装native-image插件</h5><p><strong>使用命令 gu install native-image下载安装</strong></p><p><img src="https://s2.loli.net/2023/10/10/crDPsj2yVnQ8eq1.png" alt="image-20221207155009832"></p><h4 id="11-2-2、安装C-的编译环境"><a href="#11-2-2、安装C-的编译环境" class="headerlink" title="11.2.2、安装C++的编译环境"></a>11.2.2、安装C++的编译环境</h4><h5 id="（1）下载Visual-Studio安装软件"><a href="#（1）下载Visual-Studio安装软件" class="headerlink" title="（1）下载Visual Studio安装软件"></a>（1）下载Visual Studio安装软件</h5><p><a href="https://visualstudio.microsoft.com/zh-hans/downloads/">https://visualstudio.microsoft.com/zh-hans/downloads/</a></p><p><img src="https://s2.loli.net/2023/10/10/vHeqFzxr59cLJO2.png" alt="image-20221219112426052"></p><h5 id="（2）安装Visual-Studio"><a href="#（2）安装Visual-Studio" class="headerlink" title="（2）安装Visual Studio"></a>（2）安装Visual Studio</h5><p><img src="https://s2.loli.net/2023/10/10/5M4IVShdfRZLr9X.png" alt="image-20221207155726572"></p><p><img src="https://s2.loli.net/2023/10/10/BLvsumVPbdFt7NR.png" alt="image-20221207155756512"></p><h5 id="（3）添加Visual-Studio环境变量"><a href="#（3）添加Visual-Studio环境变量" class="headerlink" title="（3）添加Visual Studio环境变量"></a>（3）添加Visual Studio环境变量</h5><p>配置INCLUDE、LIB和Path</p><p><img src="https://s2.loli.net/2023/10/10/iT2V8klHC1IEg5z.png" alt="image-20221207110947997"></p><p><img src="https://s2.loli.net/2023/10/10/erY8N5XlPUB4kuw.png" alt="image-20221207111012582"></p><p><img src="https://s2.loli.net/2023/10/10/iTOt3vJuML7d6QF.png" alt="image-20221207111105569"></p><h5 id="（4）打开工具，在工具中操作"><a href="#（4）打开工具，在工具中操作" class="headerlink" title="（4）打开工具，在工具中操作"></a>（4）打开工具，在工具中操作</h5><p><img src="https://s2.loli.net/2023/10/10/y24mPojzwnaTQZk.png" alt="image-20221207111206279"></p><h4 id="11-2-3、编写代码，构建Native-Image"><a href="#11-2-3、编写代码，构建Native-Image" class="headerlink" title="11.2.3、编写代码，构建Native Image"></a>11.2.3、编写代码，构建Native Image</h4><h5 id="（1）编写Java代码"><a href="#（1）编写Java代码" class="headerlink" title="（1）编写Java代码"></a>（1）编写Java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）复制文件到目录，执行编译"><a href="#（2）复制文件到目录，执行编译" class="headerlink" title="（2）复制文件到目录，执行编译"></a>（2）复制文件到目录，执行编译</h5><p><img src="https://s2.loli.net/2023/10/10/5zj8AZqTofutBJH.png" alt="image-20221207111420059"></p><h5 id="（3）Native-Image-进行构建"><a href="#（3）Native-Image-进行构建" class="headerlink" title="（3）Native Image 进行构建"></a>（3）Native Image 进行构建</h5><p><img src="https://s2.loli.net/2023/10/10/mQn53YGkJ9orM8F.png" alt="image-20221207111509837"></p><p><img src="https://s2.loli.net/2023/10/10/HkBt2rvAy1KRhXP.png" alt="image-20221207111609878"></p><h5 id="（4）查看构建的文件"><a href="#（4）查看构建的文件" class="headerlink" title="（4）查看构建的文件"></a>（4）查看构建的文件</h5><p><img src="https://s2.loli.net/2023/10/10/bOKgT5ZFINmSydo.png" alt="image-20221207111644950"></p><h5 id="（5）执行构建的文件"><a href="#（5）执行构建的文件" class="headerlink" title="（5）执行构建的文件"></a>（5）执行构建的文件</h5><p><img src="https://s2.loli.net/2023/10/10/opmYiyzEKORWsT3.png" alt="image-20221207111731150"></p><p>可以看到这个Hello最终打包产出的二进制文件大小为11M，这是包含了SVM和JDK各种库后的大小，虽然相比C/C++的二进制文件来说体积偏大，但是对比完整JVM来说，可以说是已经是非常小了。</p><p>相比于使用JVM运行，Native Image的速度要快上不少，cpu占用也更低一些，从官方提供的各类实验数据也可以看出Native Image对于启动速度和内存占用带来的提升是非常显著的：</p><p><img src="https://s2.loli.net/2023/10/10/7VRShPBXxACYvry.png" alt="image-20221207111947283"></p><p><img src="https://s2.loli.net/2023/10/10/axWjnYCIEtLsFSy.png" alt="image-20221207112009852"></p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="spring" scheme="https://www.hoveco.top/categories/spring/"/>
    
    
    <category term="spring" scheme="https://www.hoveco.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>前端基础-JavaScript篇(三)</title>
    <link href="https://www.hoveco.top/2023/08/24/qianduan_3/"/>
    <id>https://www.hoveco.top/2023/08/24/qianduan_3/</id>
    <published>2023-08-24T02:20:27.000Z</published>
    <updated>2023-10-09T08:41:53.821Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开始写第一行-JavaScript：hello-world"><a href="#开始写第一行-JavaScript：hello-world" class="headerlink" title="开始写第一行 JavaScript：hello world"></a><strong>开始写第一行 JavaScript：hello world</strong></h3><p>JS 代码的书写位置在哪里呢？这个问题，也可以理解成：引入 JS 代码，有哪几种方式？有三种方式：（和 CSS 的引入方式类似）</p><ol><li><strong>行内式</strong>：写在标签内部。</li><li><strong>内嵌式</strong>（内联式）：写在 head 标签中。</li><li><strong>外链式</strong>：引入外部 JS 文件。</li></ol><h4 id="方式-1：行内式"><a href="#方式-1：行内式" class="headerlink" title="方式 1：行内式"></a><strong>方式 1：行内式</strong></h4><p><strong>代码举例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;点我点我&quot;</span> onclick=<span class="string">&quot;alert(&#x27;Hoveco Hello 方式1&#x27;)&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>1</p><p>完整的可执行代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点我点我&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;Hoveco Hello 方式1&#x27;)&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><ul><li>可以将单行或少量 JS 代码写在 HTML 标签的事件属性中（以 on 开头的属性），比如放在上面的 <code>onclick</code>点击事件中。</li><li>这种书写方式，不推荐使用，原因是：可读性差，尤其是需要编写大量 JS 代码时，很难维护；引号多层嵌套时，也容易出错。</li><li>关于代码中的「引号」，在 HTML 标签中，我们推荐使用双引号，JS 中我们推荐使用单引号。</li></ul><h4 id="方式-2、内嵌式（内联式）"><a href="#方式-2、内嵌式（内联式）" class="headerlink" title="方式 2、内嵌式（内联式）"></a><strong>方式 2、内嵌式（内联式）</strong></h4><p>我们可以在 HTML 页面的 <code>&lt;body&gt;</code> 标签里放入<code>&lt;script type=”text/javascript”&gt;&lt;/script&gt;</code>标签对，并在<code>&lt;script&gt;</code>里书写 JavaScript 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 在这里写 js 代码</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&#x27;千古壹号 hello 方式2&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;qianguyihao hello 方式2&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>：</p><ul><li>text 表示纯文本，因为 JavaScript 代码本身就是纯文本。</li><li>可以将多行 JS 代码写到 <code>&lt;script&gt;</code> 标签中。</li><li>内嵌式 JS 是学习时常用的方式。</li></ul><h4 id="方式-3：外链式"><a href="#方式-3：外链式" class="headerlink" title="方式 3：外链式"></a><strong>方式 3：外链式</strong></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 外链式：引入外部的 js 文件：这个 utils.js 文件与当前的 html 文件，处于同一级目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;utils.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>：</p><ul><li>上面这段代码，依然是放到 body 标签里，可以和内嵌的 JS 代码并列。</li><li>上方代码的 script 标签已经引入了外部 JS 文件，所以这个标签里面，不可以再写 JS 代码。</li></ul><p><strong>总结</strong>：</p><p>我们在实战开发中，基本都是采用方式 3，因为将 html 文件和 js 文件分开的方式，有利于代码的结构化和复用，符合高内聚、低耦合的思想。很少会有人把一大堆 JS 代码塞到 html 文件里。</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="前端" scheme="https://www.hoveco.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端学习" scheme="https://www.hoveco.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>碎碎念</title>
    <link href="https://www.hoveco.top/2023/08/15/suisuinian/"/>
    <id>https://www.hoveco.top/2023/08/15/suisuinian/</id>
    <published>2023-08-15T02:20:27.000Z</published>
    <updated>2024-08-14T09:29:19.559Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="70a068820bef7905153e8dc6d24b7b58e442a725c488834dba92bf9267e8ab09">613e4b9014e949bba82c811e65e7ada006c427aae3bd97cd7b90f5fa1304a44e3c77f9266790a3db13166297de8678d2b01dbfc2e0688e4575af25a0ea38914e202e5586f52b1d8ce123fc33149fa21536176aa7820cd922ed7b76bc0c5df67aefd85fb57d4a9a7ae5efd39a0eec5c6beb2d218073ef9bad87bff2d8166f3d4acbe0ab1be454f32544ead29c8a66722fa40af91a8ffc19c0e4b7d7a2f6925a2bb3ce27e1488fb7f24d507a1b5672760b1568bb151e19c40ce8f4bac33dd94347565c341d9091753cfe9ccd0c003aa6a2ad955fc01a0d48c447653ac675ce06b2e14df84fab8358ea36d49ca0a6ddbdf601a198ab445ff61b31764fd663cc69d83a66c38119449f3a2d196318d7d8a330faf19abb8245dafb60b4858a4bbf1344b26db9d13de902787776b012a97bd476e6b09b6fa937412b09a09e34cd862b25b93032ce4402e808c17757c66850e82657e6d24404fbfd3d6a63b396c51a75fde6c7955174e9a35a8ad92c79030c154408cc31ecd722a037c208a92d8a2fd4dbb8eadaa082118ffd9957962949a0ea9aef6336683be6ebc2b83136b2235f699565e892f62079b668b3c9e4f0a155f7505101446a52d2ead600f196f0682942098e70cc02d18b508e9e9f9e9a93c06910cc2a6d300a543e2c990bfcbf4768991ba29e15de6d2defdd2157167450f2605aeb967b9df9c6da9e59407fa0c2d7bffbc43eab0c21fd42062ba43347263e4afa83dc82afc7eaef6c559002e1ac164a57d2b1257c6bd040c35b0b67079ceff36fd302b4869ca921ac8d414eda07ced1f5bfe1813cbff12acf2784b93910bc9e037a70ee80d30b8708f53adf1024002389844b6d2324c8ae8ddd790f3f19bc20810db33d85a223128de6088764784303914f327f0e27515a100af2466be6e19b6a33a60cc034f3d8993130d9e68102deb1a267dfd202f714282d26d7898ef04bf016215359909c4b7cae7f99b35aa2b9f8a77d3416930a56c1eb96683c4ea81388e081b6c0ea9679ef298ea9ebba2fbaf935ff82f02ae4dd8acf2f42e7c15ab2776d35139879950b2428a476d5f5f3a1e6b5322c173d01d2f1962062951f66fb622050ab48c329d049f5bb153274fbf68451a55c38837572ceadcb9d6d682905c125792bd6c1d9ac7c9e791dee2d04409a2d88577fac7b08d1576f56b8f9c446f6c284311f383985f04de5b56ff34e2e053aa214a62d99995f3f582251d1c94c3c515df5be33a529d1212a6b60f5417a9f9912d6b0eba45532000eab5e6440406bdf77be707a43568a57aa13a08ddee0dd1e0a624bf1213362dcc0bb90cd68ff72752b78ae50fca6738f4cd70731c655e069897ae846c5c0f2fe27817782523e458767e41deba40cfac76a8e103b38130e1db8d9f502f06e4f9a806b57852f8cf8a7754f82c04b64845cf606e3b156f0e2e6741ab3e6b5532e1df8ac2532c87b7b598cc829cdaad17e982099d661636bdde499a5e4b4f7068b71b8239ae3c04a7fd7a6f4dc9893134faa2fb5c25c41608599bdea69e53df7c259b85a02a18d207fc8be307fe07d7ac30f5fadbb5ccf3059c0de603b7ca1137ba563a76ee1623a88d560cfd37e3febf2aedef6012fb03f3e9b583bcde74c65d93e15eb4c8226ee57ed884a987295bbd2a475e50dac56ff0afeaa388eafda8bbffbca8187b340eb04ef47ede637c4ea1958bc2d1f7b2b9f08bf4c78a6bcd9f25da799915707136b5d8aea589d9169eee554ddaedf99658d1eb2923ef7d06e0e2db8b37d6499f34fc9ae801aa4be643dad5b212dd231c1133f33afa5e60af32acde518b3e2e2110d59c1385fe8a0061434a26daf9824c71e4fe26690b064f6bd00789fcdeddfe40331a324fc462aab02a9bf421e35aa161d8f689c43b4545aa03991706e872c52cf3b0bc6eab789c4d91babc3b2f94671281c24d0a65b4141c4fe2309fbce579520d719bbfabfd019be09e71a88764c538c6cfa7e0d978be61ecefee8fcd2d48e940d6ab9e368eb6aed70240c84d9d6725b5b8e2fa35c54f24ae8e2ed842a12d8d719b061c7265e8d7c1b4b611eff387b05f1df02d19ca5f298cd770880931a0cbcfebff9c87f58d2e79bf2f13089324f37bc9674c9a2fcca7454bce823d95f43618cf57e9b8b7cb2dcfdac3525b713517a270d1e3457b79d7704629eba22474e0cd39433697e8f3d709e15d88c093db8469d09440ceda8c2d96ec678f6d270e047a4db7123e100e686446d9ff2fc9e01b3d366fff6d5fb851f7d4980ea98c63e0a8ac469d86a73490bc632369cbcb3a68441f3378de24c985c57823e7485ebc59e6d55b61ea5bbe135e029ab4b292d84fea8cb982816456788a6d810d0fb32006d4ed25ea921ea0ecbaba8837b751df67786eaf921136a364bac17d8d0766509beb039f98d07c329b72a8a52faf3d0f0be60b1ae270ca78f36b2448ae0ec6fee022d069eb65457aa2e45ad3482b2d36c5226559cde236de0ae8e7e9c45f4e1182f06634eac2d8760001319916455fc93695b090fac4311fd9dfe69218b6f7f30b03f443931eaa528bb6016fc9404f87f196995156ad9cb42345c7ae83d63f50bfa2443f3b449bfc3bc6cd2fa78c1ae4d4d3c70f765d3704f2f72ff3543f519855869d137f975033d6004a4b2bb9992bbba143585166bc5581bd156cea6abe348be0dcb2734513e76e420c2b96278d08dea411758eb4dc4c9e47e5aa93a9df786b6633f3a446abbc37c2236dd15afb5971193fed46d89851de3f5a62abf849ea3c16c88e42283af58c6920ce04df80856889a9367b26e1facc50d251bd07164d58bdf66b4f0c87e6426cce96a4bdf5ba353b9e005f1211b9670f9a1a016bc59f77e6d47aeb6e46b7bd718efdeffb078e99f17a3a2a2ac9ea2f9031f5c2c676ed4c1de9df338dd15d470c86242383079e5388cd11f2542006d9c643f0b4fd833437954d60892af164ddf4f88fc65c60369bab9c12aa45a74873dd24542654a936fb3d60361b378c01b3aea7615189eab31287ea16bfd3198ff9aedcee160078b3381a711be9c51c977801760e482bda2165cf967d9ca9ff71f5bbeec035e997d7d7c9ed9fb5497565f31c4bd8810877e240a7b41ee15e08750dbdc984f1ff2a85af2f00b1323fb97120ce973eb6c04b60c4d5768d1296052a00310a97f57c904403b559a4df7759ff41e51f39c0d8df3dca0a6dbea3da7d560e9fa4a30dae84202f1bded1851977c11b19008709f292ad077d6bb72723969a0d4c8e204cb3ee413d36417d942da35b08512640fc8b18c0742fccea59d1a2d8ced7f853eaf43cca1869cb8aa52970933a516ed4b9b37de1e84cc2402cf69cb61655c305fc155f7820ed0d134251cd21250f121b1557e59b52896d49a63f391bc611c5fc350aa89fa1f95aed7f9879c72de0afe1a2608a7059f9157a80f4e3936135e581fe9e53ee796967a159f4a6a94a1220c236f6a1285e8584535ab63b19df71b062d524493944ae3e0c420e76bd22fd2d438f8921887f752ac7fb367e10cb6674f067b9302ef0e0addd4713edc4c0fee2d1260e4df043758491dd47d391522bbc7f95cc779375b09fe0e695d2dfb4d6fb7345ecc95651cb1f12003aa970da31369193fe57da0fe22e536322eba014977e1f909a78404cf6a3b6c5a626e453be5de4e6a640f1bef51c91cb60fb9ed8dd7535748e0bf4b7d43d8bf778ae021c0c1a9a382c71f55c42a8f5fce4ef8a16ecf368e1457201a14bcd31f6bb13ba096d3e9278ad6116048156eb78b77725d55f57d80f7711443f12dc9d91b46266b61295cc5399ed3420d7d60094cb175d572c3db2342c429d8c1a713cb4b6417f8e4d18a23c1dc24f513b25f4928e90448eb2a3a1119310a7f905d669ab2e7bc2ef161c9ebe3c5baa8b759d704f2e53b0c6364d6dacde752abe5fb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="个人" scheme="https://www.hoveco.top/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
    <category term="个人" scheme="https://www.hoveco.top/tags/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>前端基础-css篇(二)</title>
    <link href="https://www.hoveco.top/2023/08/14/qianduan_2/"/>
    <id>https://www.hoveco.top/2023/08/14/qianduan_2/</id>
    <published>2023-08-14T02:20:27.000Z</published>
    <updated>2023-08-15T15:30:42.555Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文重要内容</strong></p><ul><li>CSS的单位</li><li>字体属性</li><li>文本属性</li><li>定位属性：position、float、overflow等</li></ul><h3 id="CSS的单位"><a href="#CSS的单位" class="headerlink" title="CSS的单位"></a>CSS的单位</h3><p>html中的单位只有一种，那就是像素px，所以单位是可以省略的，但是在CSS中不一样。 <strong>CSS中的单位是必须要写的</strong>，因为它没有默认单位。</p><p><strong>绝对单位</strong></p><p>1 <code>in</code>=2.54<code>cm</code>=25.4<code>mm</code>=72<code>pt</code>=6<code>pc</code>。</p><p>各种单位的含义：</p><ul><li><code>in</code>：英寸Inches (1 英寸 = 2.54 厘米)</li><li><code>cm</code>：厘米Centimeters</li><li><code>mm</code>：毫米Millimeters</li><li><code>pt</code>：点Points，或者叫英镑 (1点 = 1/72英寸)</li><li><code>pc</code>：皮卡Picas (1 皮卡 = 12 点)</li></ul><p><strong>相对单位</strong></p><p><code>px</code>：像素 <code>em</code>：印刷单位相当于12个点 <code>%</code>：百分比，相对周围的文字的大小</p><p>为什么说像素px是一个相对单位呢，这也很好理解。比如说，电脑屏幕的的尺寸是不变的，但是我们可以让其显示不同的分辨率，在不同的分辨率下，单个像素的长度肯定是不一样的啦。</p><p>百分比<code>%</code>这个相对单位要怎么用呢？这里也举个例子：</p><p><img src="http://img.smyhvae.com/2015-10-03-css-17.png" alt="img"></p><h3 id="font-字体属性"><a href="#font-字体属性" class="headerlink" title="font 字体属性"></a>font 字体属性</h3><p>CSS中，有很多<strong>非布局样式</strong>（与布局无关），包括：字体、行高、颜色、大小、背景、边框、滚动、换行、装饰性属性（粗体、斜体、下划线）等。</p><p>这一段，我们先来讲一下字体属性。</p><p>css样式中，常见的字体属性有以下几种：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">50px</span>; <span class="comment">/*字体大小*/</span></span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">30px</span>;      <span class="comment">/*行高*/</span></span><br><span class="line"><span class="attribute">font-family</span>: 幼圆,黑体; <span class="comment">/*字体类型：如果没有幼圆就显示黑体，没有黑体就显示默认*/</span></span><br><span class="line"><span class="attribute">font-style</span>: italic ;<span class="comment">/*italic表示斜体，normal表示不倾斜*/</span></span><br><span class="line"><span class="attribute">font-weight</span>: bold;<span class="comment">/*粗体*/</span></span><br><span class="line"><span class="attribute">font-variant</span>: small-caps;  <span class="comment">/*小写变大写*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>行高</strong></p><p>CSS中，所有的行，都有行高。盒子模型的padding，绝对不是直接作用在文字上的，而是作用在“行”上的。</p><p>垂直方向来看，文字在自己的行里是居中的。比如，文字是14px，行高是24px，那么padding就是5px：</p><p><img src="http://img.smyhvae.com/20170808_2220.png" alt="img"></p><p>为了严格保证字在行里面居中，我们的工程师有一个约定： <strong>行高、字号，一般都是偶数</strong>。这样可以保证，它们的差一定偶数，就能够被2整除。</p><p><strong>如何让单行文本垂直居中</strong></p><p>小技巧：如果一段文本只有一行，如果此时设置<strong>行高 = 盒子高</strong>，就可以保证单行文本垂直居中。这个很好理解。</p><p>上面这个小技巧，只适用于单行文本垂直居中，不适用于多行。如果想让多行文本垂直居中，还需要计算盒子的padding。计算方式如下：</p><p><img src="http://img.smyhvae.com/20170808_2240.png" alt="img"></p><p><strong>vertical-align: middle; 属性</strong></p><p><code>vertical-align</code>属性可用于指定<strong>行内元素</strong>（inline）、<strong>行内块元素</strong>（inline-block）、<strong>表格的单元格</strong>（table-cell）的垂直对齐方式。主要是用于图片、表格、文本的对齐。</p><p>代码举例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vertical-align</span>: middle; <span class="comment">/*指定行级元素的垂直对齐方式。*/</span></span><br></pre></td></tr></table></figure><p>关于这一点，连 MDN 上都没我讲得详细。MDN上的原话是 “vertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。” MDN上的这种描述是不完整的，漏掉了行内块元素（inline-block）。</p><p><strong>字号、行高、字体三大属性</strong></p><p>（1）字号：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-size:14px;</span><br></pre></td></tr></table></figure><p>（2）行高：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">line-height:24px;</span><br></pre></td></tr></table></figure><p>（3）字体：（font-family就是“字体”，family是“家庭”的意思）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family:&quot;宋体&quot;;</span><br></pre></td></tr></table></figure><p>是否加粗属性以及上面这三个属性，我们可以连写：（是否加粗、字号 font-size、行高 line-height、字体 font-family）</p><p>格式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font: 加粗 字号/行高/ 字体</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font: 400 14px/24px &quot;宋体&quot;;</span><br></pre></td></tr></table></figure><p>PS：400是nomal，700是bold。</p><p>上面这几个属性可以连写，但是有一个要求，font属性连写至少要有<strong>字号和字体</strong>，否则连写是不生效的（相当于没有这一行代码）。</p><p><strong>2、字体属性的说明：</strong></p><p>（1）网页中不是所有字体都能用，因为这个字体要看用户的电脑里面装没装，比如你设置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;华文彩云&quot;;</span><br></pre></td></tr></table></figure><p>上方代码中，如果用户的 Windows 电脑里面没有这个字体，那么就会变成宋体。</p><p>页面中，中文我们一般使用：微软雅黑、宋体、黑体。英文使用：Arial、Times New Roman。页面中如果需要其他的字体，就需要单独安装字体，或者切图。</p><p>（2）为了防止用户电脑里，没有微软雅黑这个字体。就要用英语的逗号，提供备选字体。如下：（可以备选多个）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;微软雅黑&quot;,&quot;宋体&quot;;</span><br></pre></td></tr></table></figure><p>上方代码表示：如果用户电脑里没有安装微软雅黑字体，那么就是宋体。</p><p>（3）我们须将英语字体放在最前面，这样所有的中文，就不能匹配英语字体，就自动的变为后面的中文字体：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;Times New Roman&quot;,&quot;微软雅黑&quot;,&quot;宋体&quot;;</span><br></pre></td></tr></table></figure><p>上方代码的意思是，英文会采用Times New Roman字体，而中文会采用微软雅黑字体（因为美国人设计的Times New Roman字体并不针对中文，所以中文会采用后面的微软雅黑）。比如说，对于<code>smyhvae哈哈哈</code>这段文字，<code>smyhvae</code>会采用Times New Roman字体，而<code>哈哈哈</code>会采用微软雅黑字体。</p><p>可是，如果我们把中文字体写在前面：(错误写法)</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;微软雅黑&quot;,&quot;Times New Roman&quot;,&quot;宋体&quot;;</span><br></pre></td></tr></table></figure><p>上方代码会导致，中文和英文都会采用微软雅黑字体。</p><p>（4）所有的中文字体，都有英语别名。</p><p>微软雅黑的英语别名：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;Microsoft YaHei&quot;;</span><br></pre></td></tr></table></figure><p>宋体的英语别名：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: &quot;SimSun&quot;;</span><br></pre></td></tr></table></figure><p>于是，当我们把字号、行高、字体这三个属性合二为一时，也可以写成：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font:12px/30px  &quot;Times New Roman&quot;,&quot;Microsoft YaHei&quot;,&quot;SimSun&quot;;</span><br></pre></td></tr></table></figure><p>（5）行高可以用百分比，表示字号的百分之多少。</p><p>一般来说，百分比都是大于100%的，因为行高一定要大于字号。</p><p>比如说， <code>font:12px/200% “宋体”</code>等价于<code>font:12px/24px “宋体”</code>。<code>200%</code>可以理解成word里面的2倍行高。</p><p>反过来， <code>font:16px/48px “宋体”;</code>等价于<code>font:16px/300% “宋体”</code>。</p><p><strong>字体加粗属性</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line"><span class="attribute">font-weight</span>: normal; <span class="comment">/*正常*/</span></span><br><span class="line"><span class="attribute">font-weight</span>: bold;  <span class="comment">/*加粗*/</span></span><br><span class="line"><span class="attribute">font-weight</span>: <span class="number">100</span>;</span><br><span class="line"><span class="attribute">font-weight</span>: <span class="number">200</span>;</span><br><span class="line"><span class="attribute">font-weight</span>: <span class="number">900</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在设置字体是否加粗时，属性值既可以填写<code>normal</code>、<code>bold</code>这样的加粗字体，也可以直接填写 100至900 这样的数字。<code>normal</code>的值相当于400，<code>bold</code>的值相当于700。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="前端" scheme="https://www.hoveco.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端学习" scheme="https://www.hoveco.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>前端基础-HTML篇(一)</title>
    <link href="https://www.hoveco.top/2023/08/03/qianduan_1/"/>
    <id>https://www.hoveco.top/2023/08/03/qianduan_1/</id>
    <published>2023-08-03T02:20:27.000Z</published>
    <updated>2023-08-07T13:22:02.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、认识Web和Web标准"><a href="#一、认识Web和Web标准" class="headerlink" title="一、认识Web和Web标准"></a>一、认识Web和Web标准</h2><h3 id="Web、网页、浏览器"><a href="#Web、网页、浏览器" class="headerlink" title="Web、网页、浏览器"></a>Web、网页、浏览器</h3><h4 id="Web"><a href="#Web" class="headerlink" title="Web"></a><strong>Web</strong></h4><p>Web（World Wide Web）即全球广域网，也称为万维网。</p><p>我们常说的<code>Web端</code>就是网页端。</p><h4 id="网页"><a href="#网页" class="headerlink" title="网页"></a><strong>网页</strong></h4><p><strong>网页是构成网站的基本元素</strong>。网页主要由文字、图像和超链接等元素构成。当然，除了这些元素，网页中还可以包含音频、视频以及Flash等。</p><p>我们在浏览器上输入网址后，打开的任何一个页面，都是属于网页。</p><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a><strong>浏览器</strong></h4><p>浏览器是网页运行的平台，常见的浏览器有谷歌（Chrome）、Safari、火狐（Firefox）、IE、Edge、Opera等。</p><h3 id="Web标准以及W3C组织"><a href="#Web标准以及W3C组织" class="headerlink" title="Web标准以及W3C组织"></a>Web标准以及W3C组织</h3><h4 id="W3C组织"><a href="#W3C组织" class="headerlink" title="W3C组织"></a><strong>W3C组织</strong></h4><p><strong>W3C</strong>：World Wide Web Consortium，万维网联盟组织，用来制定web标准的机构（组织）。</p><p>W3C 万维网联盟是国际最著名的标准化组织。1994年成立后，至今已发布近百项相关万维网的标准，对万维网发展做出了杰出的贡献。</p><p>W3C 组织就类似于现实世界中的联合国。</p><p>为什么要遵循WEB标准呢？因为很多浏览器的浏览器内核不同，导致页面解析出来的效果可能会有差异，给开发者增加无谓的工作量。因此需要指定统一的标准。</p><h4 id="Web-标准"><a href="#Web-标准" class="headerlink" title="Web 标准"></a><strong>Web 标准</strong></h4><p><strong>Web标准</strong>：制作网页要遵循的规范。</p><p>Web标准不是某一个标准，而是由W3C组织和其他标准化组织制定的一系列标准的集合。</p><p><strong>Web标准包括三个方面</strong>：</p><ul><li>结构标准（HTML）：用于对网页元素进行整理和分类。</li><li>表现标准（CSS）：用于设置网页元素的版式、颜色、大小等外观样式。</li><li>行为标准（JS）：用于定义网页的交互和行为。</li></ul><p>根据上面的Web标准，可以将 Web前端分为三层，如下。</p><p><strong>Web前端分三层</strong>：</p><ul><li>HTML（HyperText Markup Language）：超文本标记语言。从<strong>语义</strong>的角度描述页面的<strong>结构</strong>。相当于人的身体组织结构。</li><li>CSS（Cascading Style Sheets）：层叠样式表。从<strong>审美</strong>的角度美化页面的<strong>样式</strong>。相当于人的衣服和打扮。</li><li>JS：JavaScript。从<strong>交互</strong>的角度描述页面的<strong>行为</strong>。相当于人的动作，让人有生命力。</li></ul><h2 id="二、浏览器的介绍"><a href="#二、浏览器的介绍" class="headerlink" title="二、浏览器的介绍"></a>二、浏览器的介绍</h2><h3 id="常见的浏览器"><a href="#常见的浏览器" class="headerlink" title="常见的浏览器"></a>常见的浏览器</h3><p>浏览器是网页运行的平台，常见的浏览器有谷歌（Chrome）、Safari、火狐（Firefox）、IE、Edge、Opera等。如下图所示：</p><p><img src="http://img.smyhvae.com/20191204_1900.png"></p><h3 id="浏览器的组成"><a href="#浏览器的组成" class="headerlink" title="浏览器的组成"></a>浏览器的组成</h3><p>浏览器分成两部分：</p><ul><li>1、渲染引擎（即：浏览器内核）</li><li>2、JS 引擎</li></ul><h4 id="渲染引擎（浏览器内核）"><a href="#渲染引擎（浏览器内核）" class="headerlink" title="渲染引擎（浏览器内核）"></a><strong>渲染引擎（浏览器内核）</strong></h4><p>浏览器所采用的「渲染引擎」也称之为「浏览器内核」，用来解析 HTML与CSS。渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。</p><p><strong>渲染引擎是浏览器兼容性问题出现的根本原因。</strong></p><p>渲染引擎的英文叫做 Rendering Engine。通俗来说，它的作用就是：读取网页内容，计算网页的显示方式并显示在页面上。</p><p>常见浏览器的内核如下：</p><table><thead><tr><th align="center">浏览器</th><th align="center">内核</th></tr></thead><tbody><tr><td align="center">chrome</td><td align="center">Blink</td></tr><tr><td align="center">欧鹏</td><td align="center">Blink</td></tr><tr><td align="center">360安全浏览器</td><td align="center">Blink</td></tr><tr><td align="center">360极速浏览器</td><td align="center">Blink</td></tr><tr><td align="center">Safari</td><td align="center">Webkit</td></tr><tr><td align="center">Firefox 火狐</td><td align="center">Gecko</td></tr><tr><td align="center">IE</td><td align="center">Trident</td></tr></tbody></table><p>备注：360的浏览器，以前使用的IE浏览器的Trident内核，但是现在已经改为使用 chrome 浏览器的 Blink内核。</p><p>另外，移动端的浏览器内核是什么？大家可以自行查阅资料。</p><h4 id="JS-引擎"><a href="#JS-引擎" class="headerlink" title="JS 引擎"></a><strong>JS 引擎</strong></h4><p>也称为 JS 解释器。 用来解析网页中的JavaScript代码，对其处理后再运行。</p><p>浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时会逐行解释每一句源码（转换为机器语言），然后由计算机去执行。所以 JavaScript 语言归为脚本语言，会逐行解释执行。</p><p>常见浏览器的 JS 引擎如下：</p><table><thead><tr><th align="center">浏览器</th><th align="center">JS 引擎</th></tr></thead><tbody><tr><td align="center">chrome / 欧鹏</td><td align="center">V8</td></tr><tr><td align="center">Safari</td><td align="center">Nitro</td></tr><tr><td align="center">Firefox 火狐</td><td align="center">SpiderMonkey（1.0-3.0）/ TraceMonkey（3.5-3.6）/ JaegerMonkey（4.0-）</td></tr><tr><td align="center">Opera</td><td align="center">Linear A（4.0-6.1）/ Linear B（7.0-9.2）/ Futhark（9.5-10.2）/ Carakan（10.5-）</td></tr><tr><td align="center">IE</td><td align="center">Trident</td></tr></tbody></table><h2 id="三、初识HTML"><a href="#三、初识HTML" class="headerlink" title="三、初识HTML"></a>三、初识HTML</h2><h4 id="HTML的概述"><a href="#HTML的概述" class="headerlink" title="HTML的概述"></a><strong>HTML的概述</strong></h4><p><strong>HTML</strong> 全称为 HyperText Markup Language，译为<strong>超文本标记语言</strong>。</p><p>HTML 不是一种编程语言，是一种描述性的<strong>标记语言</strong>。</p><p><strong>作用</strong>：HTML是负责描述文档<strong>语义</strong>的语言。</p><h4 id="概念：超文本"><a href="#概念：超文本" class="headerlink" title="概念：超文本"></a><strong>概念：超文本</strong></h4><p>所谓的超文本，有两层含义：</p><p>（1）图片、音频、视频、动画、多媒体等内容，成为超文本，因为它们超出了文本的限制。</p><p>（2）不仅如此，它还可以从一个文件跳转到另一个文件，与世界各地主机的文件进行连接。即：超级链接文本。</p><h4 id="概念：标记语言"><a href="#概念：标记语言" class="headerlink" title="概念：标记语言"></a><strong>概念：标记语言</strong></h4><p>HTML 不是一种编程语言，是一种描述性的<strong>标记语言</strong>。这主要有两层含义：</p><p>（1）<strong>标记语言是一套标记标签</strong>。比如：标签<code>&lt;a&gt;</code>表示超链接、标签<code>&lt;img&gt;</code>表示图片、标签<code>&lt;h1&gt;</code>表示一级标题等等，它们都是属于 HTML 标签。</p><p>说的通俗一点就是：网页是由网页元素组成的，这些元素是由 HTML 标签描述出来，然后通过浏览器解析，就可以显示给用户看了。</p><p>（2）编程语言是有编译过程的，而标记语言没有编译过程，HTML标签是直接由浏览器解析执行。</p><h4 id="HTML是负责描述文档语义的语言"><a href="#HTML是负责描述文档语义的语言" class="headerlink" title="HTML是负责描述文档语义的语言"></a><strong>HTML是负责描述文档语义的语言</strong></h4><p>HTML 格式的文件是一个纯本文文件（就是用txt文件改名而成），用一些标签来描述语义，这些标签在浏览器页面上是无法直观看到的，所以称之为“超文本标记语言”。</p><p>接下来，我们需要学习 HTML 中的很多“标签对儿”，这些“标签对儿”能够给文本不同的语义。</p><p>比如，面试的时候问你，<code>&lt;h1&gt;</code> 标签有什么作用？</p><ul><li>正确答案：给文本增加主标题的语义。</li><li>错误答案：给文字加粗、加黑、变大。</li></ul><p>关乎“语义”的更深刻理解，等接下来我们学习了各种标签，就明白了。</p><h4 id="HTML的历史"><a href="#HTML的历史" class="headerlink" title="HTML的历史"></a><strong>HTML的历史</strong></h4><p><img src="http://img.smyhvae.com/20151001_1001.png"></p><p>其中，我们专门来对XHTML做一个介绍。</p><p><strong>XHTML介绍：</strong> XHTML：Extensible Hypertext Markup Language，可扩展超文本标注语言。 XHTML的主要目的是为了<strong>取代HTML</strong>，也可以理解为HTML的升级版。 HTML的标记书写很不规范，会造成其它的设备(ipad、手机、电视等)无法正常显示。 XHTML与HTML4.0的标记基本上一样。 XHTML是<strong>严格的、纯净的</strong>HTML。</p><h4 id="HTML的专有名词"><a href="#HTML的专有名词" class="headerlink" title="HTML的专有名词"></a><strong>HTML的专有名词</strong></h4><ul><li>网页 ：由各种标记组成的一个页面就叫网页。</li><li>主页(首页) : 一个网站的起始页面或者导航页面。</li><li>标记： 比如<code>&lt;p&gt;</code>称为开始标记 ，<code>&lt;/p&gt;</code>称为结束标记，也叫标签。每个标签都规定好了特殊的含义。</li><li>元素：比如<code>&lt;p&gt;内容&lt;/p&gt;</code>称为元素.</li><li>属性：给每一个标签所做的辅助信息。</li><li>XHTML：符合XML语法标准的HTML。</li><li>DHTML：dynamic，动态的。<code>javascript + css + html</code>合起来的页面就是一个 DHTML。</li><li>HTTP：超文本传输协议。用来规定客户端浏览器和服务端交互时数据的一个格式。SMTP：邮件传输协议，FTP：文件传输协议。</li></ul><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.jd.com&quot;</span>&gt;</span>我是超链接，可以点击一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="四、HTML标签"><a href="#四、HTML标签" class="headerlink" title="四、HTML标签"></a>四、HTML标签</h2><p>常见的标签有<strong>排版标签</strong>、<strong>字体标签</strong>、<strong>图片标签</strong>和<strong>超链接</strong>等等</p><h3 id="排版标签"><a href="#排版标签" class="headerlink" title="排版标签"></a><strong>排版标签</strong></h3><ul><li><code>&lt;h1&gt;</code></li><li><code>&lt;p&gt;</code></li><li><code>&lt;hr /&gt;</code></li><li><code>&lt;br /&gt;</code></li><li><code>&lt;div&gt;</code></li><li><code>&lt;span&gt;</code></li><li><code>&lt;center&gt;</code></li><li><code>&lt;pre&gt;</code></li></ul><h2 id="五、HTML5详解"><a href="#五、HTML5详解" class="headerlink" title="五、HTML5详解"></a>五、HTML5详解</h2><h3 id="HTML5的介绍"><a href="#HTML5的介绍" class="headerlink" title="HTML5的介绍"></a><strong>HTML5的介绍</strong></h3><h4 id="Web-技术发展时间线"><a href="#Web-技术发展时间线" class="headerlink" title="Web 技术发展时间线"></a><strong>Web 技术发展时间线</strong></h4><ul><li>1991 HTML</li><li>1994 HTML2</li><li>1996 CSS1 + JavaScript</li><li>1997 HTML4</li><li>1998 CSS2</li><li>2000 XHTML1（严格的html）</li><li>2002 Tableless Web Design（表格布局）</li><li>2005 AJAX</li><li>2009 HTML5</li><li>2014 HTML5 Finalized</li></ul><p>2002年的表格布局逐渐被淘汰，是因为：表格是用来承载数据的，并不是用来划分网页结构的。</p><p>2009年就已经推出了HTML5的草案，但直到2014年才有定稿，是因为有移动端的推动。</p><p>H5草案的前身是叫：Web Application，最早是由<a href="https://baike.baidu.com/item/WHATWG/5803339?fr=aladdin">WHATWG</a>这个组织在2004年提出的。</p><p>2007年被 W3C 组织接纳，并在 2008-01-22 发布 HTML5 的第一个草案。</p><h3 id="什么是-HTML5"><a href="#什么是-HTML5" class="headerlink" title="什么是 HTML5"></a>什么是 HTML5</h3><p>HTML5并不仅仅只是做为HTML标记语言的一个最新版本，更重要的是它<strong>制定了Web应用开发的一系列标准</strong>，成为第一个将Web做为应用开发平台的HTML语言。</p><p>HTML5定义了一系列新元素，如新语义标签、智能表单、多媒体标签等，可以帮助开发者创建富互联网应用，还提供了一些Javascript API，如地理定位、重力感应、硬件访问等，可以在浏览器内实现类原生应用。我们甚至可以结合 Canvas 开发网页版游戏。</p><p><strong><code>HTML5</code>的广义概念</strong>：HTML5代表浏览器端技术的一个发展阶段。在这个阶段，浏览器的呈现技术得到了飞跃发展和广泛支持，它包括：HTML5、CSS3、Javascript API在内的一套技术组合。</p><p><code>HTML5</code>不等于 <code>HTML next version</code>。<code>HTML5</code> 包含： <code>HTML</code>的升级版、<code>CSS</code>的升级版、<code>JavaScript API</code>的升级版。</p><p><strong>总结</strong>：<code>HTML5</code>是新一代开发 <strong>Web 富客户端</strong>应用程序整体<strong>解决方案</strong>。包括：HTML5，CSS3，Javascript API在内的一套<strong>技术组合</strong>。</p><p><strong>富客户端</strong>：具有很强的<strong>交互性</strong>和体验的客户端程序。比如说，浏览博客，是比较简单的客户端；一个在线听歌的网站、即时聊天网站就是富客户端。</p><p><strong>PS：</strong></p><p>单纯地从技术的角度讲，兼容性问题只会让开发者徒增烦恼。</p><p>如果网页端的程序能做到PC客户端的体验，就会对后者构成威胁。</p><h3 id="HTML5-的应用场景"><a href="#HTML5-的应用场景" class="headerlink" title="HTML5 的应用场景"></a>HTML5 的应用场景</h3><p>列举几个HTML5 的应用场景：</p><p>（1）极具表现力的网页：内容简约而不简单。</p><p>（2）网页应用程序：</p><ul><li>代替PC端的软件：iCloud、百度脑图、Office 365等。</li><li>APP端的网页：淘宝、京东、美团等。</li><li>微信端：公众号、小程序等。</li></ul><p>（3）混合式本地应用。</p><p>（4）简单的游戏。</p><h3 id="HTML5-新增的内容"><a href="#HTML5-新增的内容" class="headerlink" title="HTML5 新增的内容"></a>HTML5 新增的内容</h3><p><img src="http://img.smyhvae.com/20180206_1540.png" alt="img"></p><p><img src="http://img.smyhvae.com/20180206_1545.png" alt="img"></p><p><img src="http://img.smyhvae.com/20180206_1541.png" alt="img"></p><h3 id="语义化的标签"><a href="#语义化的标签" class="headerlink" title="语义化的标签"></a>语义化的标签</h3><h4 id="语义化的作用"><a href="#语义化的作用" class="headerlink" title="语义化的作用"></a><strong>语义化的作用</strong></h4><p>语义标签对于我们并不陌生，如<code>&lt;p&gt;</code>表示一个段落、<code>&lt;ul&gt;</code>表示一个无序列表。<strong>标签语义化的作用：</strong></p><ul><li>能够便于开发者阅读和写出更优雅的代码。</li><li>同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容。</li><li>更好地搜索引擎优化。</li></ul><p>总结：HTML的职责是描述一块内容是什么（或其意义），而不是它长什么样子；它的外观应该由CSS来决定。</p><h4 id="H5在语义上的改进"><a href="#H5在语义上的改进" class="headerlink" title="H5在语义上的改进"></a><strong>H5在语义上的改进</strong></h4><p>在此基础上，HTML5 增加了大量有意义的语义标签，更有利于搜索引擎或辅助设备理解 HTML 页面内容。HTML5会让HTML代码的内容更结构化、标签更语义化。</p><p>我们常见的 css+div 布局是：</p><p><img src="http://img.smyhvae.com/20180206_1546.png" alt="img"></p><p>在html5中，我们可以这样写：</p><p><img src="http://img.smyhvae.com/20180206_1550.png" alt="img"></p><p>传统的做法中，我们通过增加类名如<code>class=&quot;header&quot;</code>、<code>class=&quot;footer&quot;</code>，使HTML页面具有语义性，但是不具有通用性。</p><p>HTML5 则是通过新增语义标签的形式来解决这个问题，例如<code>&lt;header&gt;&lt;/header&gt;</code>、<code>&lt;footer&gt;&lt;/footer&gt;</code>等，这样就可以使其具有通用性。</p><h4 id="传统网页布局："><a href="#传统网页布局：" class="headerlink" title="传统网页布局："></a><strong>传统网页布局：</strong></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 头部 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 主体部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 文章 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 侧边栏 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aside&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 底部 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="H5-的经典网页布局："><a href="#H5-的经典网页布局：" class="headerlink" title="H5 的经典网页布局："></a><strong>H5 的经典网页布局：</strong></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 头部 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 主体部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 文章 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 侧边栏 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 底部 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="H5中新增的语义标签"><a href="#H5中新增的语义标签" class="headerlink" title="H5中新增的语义标签"></a>H5中新增的语义标签</h3><ul><li><code>&lt;section&gt;</code> 表示区块</li><li><code>&lt;article&gt;</code> 表示文章。如文章、评论、帖子、博客</li><li><code>&lt;header&gt;</code> 表示页眉</li><li><code>&lt;footer&gt;</code> 表示页脚</li><li><code>&lt;nav&gt;</code> 表示导航</li><li><code>&lt;aside&gt;</code> 表示侧边栏。如文章的侧栏</li><li><code>&lt;figure&gt;</code> 表示媒介内容分组。</li><li><code>&lt;mark&gt;</code> 表示标记 (用得少)</li><li><code>&lt;progress&gt;</code> 表示进度 (用得少)</li><li><code>&lt;time&gt;</code> 表示日期</li></ul><p>本质上新语义标签与<code>&lt;div&gt;</code>、<code>&lt;span&gt;</code>没有区别，只是其具有表意性，使用时除了在HTML结构上需要注意外，其它和普通标签的使用无任何差别，可以理解成<code>&lt;div class=&quot;nav&quot;&gt;</code> 相当于<code>&lt;nav&gt;</code>。</p><p>PS：单标签不用写关闭符号。</p><h4 id="新语义标签的兼容性处理"><a href="#新语义标签的兼容性处理" class="headerlink" title="新语义标签的兼容性处理"></a><strong>新语义标签的兼容性处理</strong></h4><p>IE8 及以下版本的浏览器不支持 H5 和 CSS3。解决办法：引入<code>html5shiv.js</code>文件。</p><p>引入时，需要做if判断，具体代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  条件注释 只有ie能够识别--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--[if lte ie 8]&gt;</span></span><br><span class="line"><span class="comment">    &lt;script src=&quot;html5shiv.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><p>上方代码是<strong>条件注释</strong>：虽然是注释，但是IE浏览器可以识别出来。解释一下：</p><ul><li>l：less 更小</li><li>t：than 比</li><li>e：equal等于</li><li>g：great 更大</li></ul><p>PS:我们在测试 IE 浏览器的兼容的时候，可以使用软件 ietest，模拟IE6-IE11。</p><p>在不支持HTML5新标签的浏览器，会将这些新的标签解析成行内元素(inline)对待，所以我们只需要将其转换成块元素(block)即可使用。</p><p>但是在IE9版本以下，并不能正常解析这些新标签，但是可以识别通过document.createElement(‘tagName’)创建的自定义标签。于是我们的解决方案就是：将HTML5的新标签全部通过document.createElement(‘tagName’)来创建一遍，这样IE低版本也能正常解析HTML5新标签了。</p><p>当然，在实际开发中我们更多采用的办法是：检测IE浏览器的版本，来加载第三方的JS库来解决兼容问题（如上方代码所示）。</p><h3 id="H5中的表单"><a href="#H5中的表单" class="headerlink" title="H5中的表单"></a>H5中的表单</h3><p>传统的Web表单已经越来越不能满足开发的需求，HTML5 在 Web 表单方向做了很大的改进，如拾色器、日期/时间组件等，使表单处理更加高效。</p><h4 id="H5中新增的表单类型"><a href="#H5中新增的表单类型" class="headerlink" title="H5中新增的表单类型"></a><strong>H5中新增的表单类型</strong></h4><ul><li><code>email</code> 只能输入email格式。自动带有验证功能。</li><li><code>tel</code> 手机号码。</li><li><code>url</code> 只能输入url格式。</li><li><code>number</code> 只能输入数字。</li><li><code>search</code> 搜索框</li><li><code>range</code> 滑动条</li><li><code>color</code> 拾色器</li><li><code>time</code> 时间</li><li><code>date</code> 日期</li><li><code>datetime</code> 时间日期</li><li><code>month</code> 月份</li><li><code>week</code> 星期</li></ul><p>上面的部分类型是针对移动设备生效的，且具有一定的兼容性，在实际应用当中可选择性的使用。</p><p>代码举例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, user-scalable=no&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>表单类型<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#F7F7F7</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">form</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">max-width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">32px</span> auto <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">16px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">label</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">input</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">25px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-top</span>: <span class="number">2px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">legend</span>&gt;</span>表单类型<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            email: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            color: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;color&quot;</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            url: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;url&quot;</span> <span class="attr">name</span>=<span class="string">&#x27;url&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            number: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">step</span>=<span class="string">&quot;3&quot;</span> <span class="attr">name</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            range: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">name</span>=<span class="string">&quot;range&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            search: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span> <span class="attr">name</span>=<span class="string">&quot;search&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            tel: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            time: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;time&quot;</span> <span class="attr">name</span>=<span class="string">&quot;time&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            date: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">name</span>=<span class="string">&quot;date&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            datetime: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;datetime&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            week: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;week&quot;</span> <span class="attr">name</span>=<span class="string">&quot;week&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            month: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;month&quot;</span> <span class="attr">name</span>=<span class="string">&quot;month&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            datetime-local: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;datetime-local&quot;</span> <span class="attr">name</span>=<span class="string">&quot;datetime-local&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码解释：</p><p><code>&lt;fieldset&gt;</code> 标签将表单里的内容进行打包，代表一组；而<code>&lt;legend&gt;</code>标签的则是 fieldset 里的元素定义标题。</p><h4 id="表单元素（标签）"><a href="#表单元素（标签）" class="headerlink" title="表单元素（标签）"></a><strong>表单元素（标签）</strong></h4><p>这里讲两个表单元素。</p><p><strong>1、<code>&lt;datalist&gt;</code> 数据列表：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">list</span>=<span class="string">&quot;myData&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;myData&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>本科<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>研究生<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>不明<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上方代码中，input里的list属性和 datalist 进行了绑定。</p><p>效果：</p><p><img src="http://img.smyhvae.com/20180206_1845.gif" alt="img"></p><p>上图可以看出，数据列表可以自动提示。</p><p>2、<code>&lt;keygen&gt;</code>元素：</p><p>keygen 元素的作用是提供一种验证用户的可靠方法。</p><p>keygen 元素是密钥对生成器（key-pair generator）。当提交表单时，会生成两个键：一个公钥，一个私钥。</p><p>私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。</p><p>3、<code>&lt;meter&gt;</code>元素：度量器</p><ul><li>low：低于该值后警告</li><li>high：高于该值后警告</li><li>value：当前值</li><li>max：最大值</li><li>min：最小值。</li></ul><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meter  value=<span class="string">&quot;81&quot;</span>    min=<span class="string">&quot;0&quot;</span> max=<span class="string">&quot;100&quot;</span>  low=<span class="string">&quot;60&quot;</span>  high=<span class="string">&quot;80&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>1</p><h4 id="表单属性"><a href="#表单属性" class="headerlink" title="表单属性"></a><strong>表单属性</strong></h4><ul><li><code>placeholder</code> 占位符（提示文字）</li><li><code>autofocus</code> 自动获取焦点</li><li><code>multiple</code> 文件上传多选或多个邮箱地址</li><li><code>autocomplete</code> 自动完成（填充的）。on 开启（默认），off 取消。用于表单元素，也可用于表单自身(on/off)</li><li><code>form</code> 指定表单项属于哪个form，处理复杂表单时会需要</li><li><code>novalidate</code> 关闭默认的验证功能（只能加给form）</li><li><code>required</code> 表示必填项</li><li><code>pattern</code> 自定义正则，验证表单。例如</li></ul><p>代码举例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">form</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* 最大宽度*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">max-width</span>: <span class="number">640px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* 最小宽度*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">min-width</span>: <span class="number">320px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-family</span>: <span class="string">&quot;Microsoft Yahei&quot;</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">input</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">legend</span>&gt;</span>表单属性<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;例如：smyhvae&quot;</span> <span class="attr">autofocus</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;on&quot;</span> <span class="attr">required</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            电话：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">pattern</span>=<span class="string">&quot;1\d&#123;10&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            multiple的表单: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 上传文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">multiple</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a><strong>表单事件</strong></h4><ul><li><code>oninput()</code>：用户输入内容时触发，可用于输入字数统计。</li><li><code>oninvalid()</code>：验证不通过时触发。比如，如果验证不通过时，想弹出一段提示文字，就可以用到它。</li></ul><p>举例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">form</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* 最大宽度*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">max-width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* 最小宽度*/</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">min-width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-family</span>: <span class="string">&quot;Microsoft Yahei&quot;</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">input</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">legend</span>&gt;</span>表单事件<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            邮箱：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txt1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            输入的次数统计：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txt2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> txt1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;txt1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> txt2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;txt2&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> num = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    txt1.<span class="property">oninput</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;  <span class="comment">//用户输入时触发</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        num++;  <span class="comment">//用户每输入一次，num自动加 1</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//将统计数显示在txt2中</span></span></span><br><span class="line"><span class="language-javascript">        txt2.<span class="property">value</span> = num;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    txt1.<span class="property">oninvalid</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;  <span class="comment">//验证不通过时触发</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="title function_">setCustomValidity</span>(<span class="string">&#x27;亲，请输入正确哦&#x27;</span>);  <span class="comment">//设置验证不通过时的提示文字</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="http://img.smyhvae.com/20180206_1920.gif" alt="img"></p><h3 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h3><p>在HTML5之前，在网页上播放音频/视频的通用方法是利用Flash来播放。但是大多情况下，并非所有用户的浏览器都安装了Flash插件，由此使得音频、视频播放的处理变得非常复杂；并且移动设备的浏览器并不支持Flash插件。</p><p>H5里面提供了视频和音频的标签。</p><h4 id="音频"><a href="#音频" class="headerlink" title="音频"></a><strong>音频</strong></h4><p>HTML5通过<code>&lt;audio&gt;</code>标签来解决音频播放的问题。</p><p>使用举例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;music/yinyue.mp3&quot;</span> <span class="attr">autoplay</span> <span class="attr">controls</span>&gt;</span> <span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://img.smyhvae.com/20180206_1958.png" alt="img"></p><p>我们可以通过附加属性，来更友好地控制音频的播放，如：</p><ul><li><code>autoplay</code> 自动播放。写成<code>autoplay</code> 或者 <code>autoplay = &quot;&quot;</code>，都可以。</li><li><code>controls</code> 控制条。（建议把这个选项写上，不然都看不到控件在哪里）</li><li><code>loop</code> 循环播放。</li><li><code>preload</code> 预加载 同时设置 autoplay 时，此属性将失效。</li></ul><p><strong>处理兼容性问题：</strong></p><p>由于版权等原因，不同的浏览器可支持播放的格式是不一样的：</p><p><img src="http://img.smyhvae.com/20180206_1945.png" alt="img"></p><p>为了做到多浏览器支持，可以采取以下兼容性写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--推荐的兼容写法：--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span> <span class="attr">loop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;music/yinyue.mp3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;music/yinyue.ogg&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;music/yinyue.wav&quot;</span>/&gt;</span></span><br><span class="line">    抱歉，你的浏览器暂不支持此音频格式</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码解释：如果识别不出音频格式，就弹出那句“抱歉”。</p><h4 id="视频"><a href="#视频" class="headerlink" title="视频"></a><strong>视频</strong></h4><p>HTML5通过<code>&lt;video&gt;</code>标签来解决视频播放的问题。</p><p>使用举例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;video/movie.mp4&quot;</span> <span class="attr">controls</span> <span class="attr">autoplay</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以通过附加属性，来更友好地控制视频的播放，如：</p><ul><li><code>autoplay</code> 自动播放。写成<code>autoplay</code> 或者 <code>autoplay = &quot;&quot;</code>，都可以。</li><li><code>controls</code> 控制条。（建议把这个选项写上，不然都看不到控件在哪里）</li><li><code>loop</code> 循环播放。</li><li><code>preload</code> 预加载 同时设置 autoplay 时，此属性将失效。</li><li><code>width</code>：设置播放窗口宽度。</li><li><code>height</code>：设置播放窗口的高度。</li></ul><p>由于版权等原因，不同的浏览器可支持播放的格式是不一样的：</p><p><img src="http://img.smyhvae.com/20180206_2025.png" alt="img"></p><p>兼容性写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--&lt;video src=&quot;video/movie.mp4&quot; controls  autoplay &gt;&lt;/video&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  行内块 display:inline-block --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">autoplay</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;video/movie.mp4&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;video/movie.ogg&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;video/movie.webm&quot;</span>/&gt;</span></span><br><span class="line">    抱歉，不支持此视频</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h3><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a><strong>获取元素</strong></h4><ul><li>document.querySelector(“selector”) 通过CSS选择器获取符合条件的第一个元素。</li><li>document.querySelectorAll(“selector”) 通过CSS选择器获取符合条件的所有元素，以类数组形式存在。</li></ul><h4 id="类名操作"><a href="#类名操作" class="headerlink" title="类名操作"></a><strong>类名操作</strong></h4><ul><li>Node.classList.add(“class”) 添加class</li><li>Node.classList.remove(“class”) 移除class</li><li>Node.classList.toggle(“class”) 切换class，有则移除，无则添加</li><li>Node.classList.contains(“class”) 检测是否存在class</li></ul><h4 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a><strong>自定义属性</strong></h4><p>js 里可以通过 <code>box1.index=100;</code> <code>box1.title</code> 来自定义属性和获取属性。</p><p>H5可以直接在标签里添加自定义属性，<strong>但必须以 <code>data-</code> 开头</strong>。</p><p>举例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 给标签添加自定义属性 必须以data-开头 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">title</span>=<span class="string">&quot;盒子&quot;</span> <span class="attr">data-my-name</span>=<span class="string">&quot;smyhvae&quot;</span> <span class="attr">data-content</span>=<span class="string">&quot;我是一个div&quot;</span>&gt;</span>div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//自定义的属性 需要通过 dateset[]方式来获取</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(box.<span class="property">dataset</span>[<span class="string">&quot;content&quot;</span>]);  <span class="comment">//打印结果：我是一个div</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(box.<span class="property">dataset</span>[<span class="string">&quot;myName&quot;</span>]);    <span class="comment">//打印结果：smyhvae</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//设置自定义属性的值</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> num = <span class="number">100</span>;</span></span><br><span class="line"><span class="language-javascript">    num.<span class="property">index</span> = <span class="number">10</span>;</span></span><br><span class="line"><span class="language-javascript">    box.<span class="property">index</span> = <span class="number">100</span>;</span></span><br><span class="line"><span class="language-javascript">    box.<span class="property">dataset</span>[<span class="string">&quot;content&quot;</span>] = <span class="string">&quot;aaaa&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="举例：鼠标点击时，tab栏切换"><a href="#举例：鼠标点击时，tab栏切换" class="headerlink" title="举例：鼠标点击时，tab栏切换"></a><strong>举例：鼠标点击时，tab栏切换</strong></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Tab 标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#F7F7F7</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.tabs</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">30px</span> auto;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#FFF</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#C0DCC0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.tabs</span> <span class="selector-tag">nav</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">line-height</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#C0DCC0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">nav</span> <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-right</span>: <span class="number">1px</span> solid <span class="number">#FFF</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#000</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:last-child</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-right</span>: <span class="number">0</span> none;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-class">.active</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#9BAF9B</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.cont</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: none;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.cont</span> <span class="selector-tag">ol</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">line-height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tabs&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span> <span class="attr">data-cont</span>=<span class="string">&quot;local&quot;</span>&gt;</span>国内新闻<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span> <span class="attr">data-cont</span>=<span class="string">&quot;global&quot;</span>&gt;</span>国际新闻<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span> <span class="attr">data-cont</span>=<span class="string">&quot;sports&quot;</span>&gt;</span>体育新闻<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span> <span class="attr">data-cont</span>=<span class="string">&quot;funny&quot;</span>&gt;</span>娱乐新闻<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;cont&quot;</span> <span class="attr">id</span>=<span class="string">&quot;local&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>国内新闻1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>国内新闻2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>国内新闻3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>国内新闻4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>国内新闻5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>国内新闻6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>国内新闻7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;cont&quot;</span> <span class="attr">id</span>=<span class="string">&quot;global&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>国内新闻1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>国际新闻2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>国际新闻3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>国际新闻4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>国际新闻5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>国际新闻6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;cont&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sports&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>体育新闻1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>体育新闻2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>体育新闻3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>体育新闻4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>体育新闻5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>体育新闻6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>体育新闻7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;cont&quot;</span> <span class="attr">id</span>=<span class="string">&quot;funny&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>娱乐新闻1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>娱乐新闻2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>娱乐新闻3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>娱乐新闻4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>娱乐新闻5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>娱乐新闻6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>娱乐新闻7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 目标： 默认显示一个 当前的样式</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 点击导航，实现切换</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// key 表示的当前显示的是第几个</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        (<span class="keyword">function</span> (<span class="params">key</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 获取所有的导航</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> navs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;nav a&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 遍历 给导航 绑定事件，并且添加当前样式</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; navs.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 如果是用户指定的当前样式</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (key == i) &#123;</span></span><br><span class="line"><span class="language-javascript">                    navs[i].<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;active&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 拿到要显示内容section的id</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">var</span> secId = navs[i].<span class="property">dataset</span>[<span class="string">&#x27;cont&#x27;</span>];</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 获取对应的section标签</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#&#x27;</span> + secId).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;block&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 给每一个导航绑定点击事件</span></span></span><br><span class="line"><span class="language-javascript">                navs[i].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 排他</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 之前有active样式的清除, 之前显示的section 隐藏</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">var</span> currentNav = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.active&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 获取对应的内容区域 ，让其隐藏</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">var</span> currentId = currentNav.<span class="property">dataset</span>[<span class="string">&#x27;cont&#x27;</span>];</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 去掉导航的active 样式</span></span></span><br><span class="line"><span class="language-javascript">                    currentNav.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;active&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 对应的内容区域</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#&#x27;</span> + currentId).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 突出显示自己 导航添加样式  对应的section 显示</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 给自己添加active样式</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">this</span>.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;active&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 对应的section模块显示出来</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">var</span> myId = <span class="variable language_">this</span>.<span class="property">dataset</span>[<span class="string">&#x27;cont&#x27;</span>];</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#&#x27;</span> + myId).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;block&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        &#125;)(<span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="前端" scheme="https://www.hoveco.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端学习" scheme="https://www.hoveco.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Nginx篇-win的安装(二)</title>
    <link href="https://www.hoveco.top/2023/07/23/nginx_2/"/>
    <id>https://www.hoveco.top/2023/07/23/nginx_2/</id>
    <published>2023-07-23T06:20:27.000Z</published>
    <updated>2023-08-03T11:51:00.613Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下载Nginx安装包"><a href="#下载Nginx安装包" class="headerlink" title="下载Nginx安装包"></a>下载Nginx安装包</h3><p>前往<a href="https://nginx.org/en/download.html">Nginx官方下载页面</a>，下载一个稳定版(Stable version)的Nginx。</p><p><img src="https://s2.loli.net/2023/07/24/6KxNMOjE8XVShBq.png" alt="image-20230626140304163"></p><p>解压到本地。<strong>注意</strong>：<strong>解压路径不要出现中文和空格！</strong></p><p><img src="https://s2.loli.net/2023/07/24/FKB3RIJnU4aXD12.png" alt="image-20230626140425285"></p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>环境变量中将Nginx的路径追加到Path。</p><p><img src="https://s2.loli.net/2023/07/24/1EZLyW59abGvYwp.png"></p><p>重启电脑或者重启explorer.exe即可生效。</p><p>这里介绍下重启explorer.exe的方法：</p><p>在记事本里，输入以下内容，并保存为Reflash.<a href="https://so.csdn.net/so/search?q=Bat%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020">Bat文件</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span> explorer.exe已关闭！</span><br><span class="line">taskkill /im explorer.exe /f</span><br><span class="line"><span class="built_in">echo</span> 正在开启explorer.exe</span><br><span class="line">start <span class="string">&quot;&quot;</span> <span class="string">&quot;C:\WINDOWS\explorer.exe&quot;</span></span><br><span class="line"><span class="built_in">echo</span> explorer.exe已开启！</span><br><span class="line">ping -n 4 127.1&gt;nul</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>单击即可。</p><p><img src="https://s2.loli.net/2023/07/24/34utf5EXAnFvW78.png"></p><h3 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h3><p>Nginx配置文件路径为，/conf/nginx.conf 如下图所示。用记事本打开就可以修改配置参数。</p><p><img src="https://s2.loli.net/2023/07/25/WNf5q7m9HAJpOny.png"></p><h3 id="设置报错日志路径"><a href="#设置报错日志路径" class="headerlink" title="设置报错日志路径"></a>设置报错日志路径</h3><p>我们可以指定错误日志的输出路径。值得注意的是，Nginx有时会把路径中的\识别为转义字符，如\n、\t、\r。因此路劲可以用双斜杠\防止转义。</p><p><img src="https://s2.loli.net/2023/07/24/APXNMhpuqykZBlm.png"></p><h3 id="设置Nginx的启动端口号"><a href="#设置Nginx的启动端口号" class="headerlink" title="设置Nginx的启动端口号"></a>设置Nginx的启动端口号</h3><p>如果您的电脑80端口已经被占用了，且不方便修改，只能修改Nginx默认启动端口了。</p><p>(80端口未占用的可以跳过本步骤)</p><p>入图，我们可以将listen的默认端口号80改成我们想要的端口号即可。</p><p><img src="https://s2.loli.net/2023/07/24/URkm1W8l9NBKedq.png"></p><h3 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h3><p>使用以下命令启动Nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:</span><br><span class="line"><span class="built_in">cd</span> D:\Nginx</span><br><span class="line">nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/24/tEvas1HOKpiSWYq.png"></p><p><img src="https://s2.loli.net/2023/07/24/XRdJKAibzNkcjVf.png"></p><p>启动成功。</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="Nginx" scheme="https://www.hoveco.top/categories/Nginx/"/>
    
    
    <category term="Nginx学习" scheme="https://www.hoveco.top/tags/Nginx%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Nginx篇(一)</title>
    <link href="https://www.hoveco.top/2023/07/20/nginx_1/"/>
    <id>https://www.hoveco.top/2023/07/20/nginx_1/</id>
    <published>2023-07-20T06:20:27.000Z</published>
    <updated>2023-08-03T11:51:00.679Z</updated>
    
    <content type="html"><![CDATA[<img src="https://www.w3schools.cn/wp-content/uploads/nginx/nginx-logo.png" style="zoom:33%;" /><h2 id="什么是-Nginx？"><a href="#什么是-Nginx？" class="headerlink" title="什么是 Nginx？"></a>什么是 Nginx？</h2><ul><li>Nginx 读作 “engine-ex”。</li><li>Nginx 是由俄罗斯程序员 Igor Sysoev 编写，2004年10月作为一个试图回答公众发布 C10K 问题。其中 C10k 是同时管理 10,000 个连接的挑战。Nginx 采用了事件驱动和异步架构，此设计使 Nginx 成为可扩展、高性能的服务器。</li><li>它是一个开源、轻量级和高性能的 Web 服务器，也用作 HTTP、HTTPS、SMTP、IMAP、POP3 协议的反向代理服务器，另一方面，它也用作 IMAP、POP3 和 IMAP 的 HTTP 负载均衡器、HTTP 缓存和电子邮件代理。</li><li>简而言之，我们可以说 Nginx 是一种用于处理并发请求的软件。</li></ul><h2 id="为什么要使用-Nginx？"><a href="#为什么要使用-Nginx？" class="headerlink" title="为什么要使用 Nginx？"></a>为什么要使用 Nginx？</h2><p>随着当今互联网的迅速发展，单点服务器早已无法承载上万个乃至数十万个用户的持续访问。比如一台Tomcat服务器在理想状态下只能够可以承受住2000个左右的并发量，为了解决这个问题，就需要多台Tomcat服务器来进行负载均衡。</p><p>那么，应该如何实现负载均衡？Nginx就是其中的一种解决方案，当用户访问网站时，Nginx拦截到这个访问请求，并将其通过轮询的方式均匀地分配到不同的服务器上。</p><p><img src="https://pic4.zhimg.com/v2-19ad1edacec5c87d918b7fcc6574de0f_r.jpg" alt="img"></p><p>并且，在Nginx中有一种ip_hash策略，它可以获取到用户的真实IP，计算出hash值来选择服务器，这也是一种优秀的负载均衡方式。 所以，掌握Nginx成为了Web开发学习道路上不可缺少的一部分。</p><h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><h4 id="正向代理："><a href="#正向代理：" class="headerlink" title="正向代理："></a>正向代理：</h4><p><img src="https://pic2.zhimg.com/v2-d1da364c1b6c2f0024867c3f8ce49c59_r.jpg"></p><p>​       正向代理就是代理服务器介于用户客户端和目标服务器之间，用户指定想要获取的目标内容，通过客户端先向代理服务器发送请求，再由代理服务器发送到目标服务器，随后将获得的内容返回用户客户端。正向代理的情况下，客户端必须要进行一些需求设置，在有确定目标的前提下发送请求。</p><p>​        正向代理是代理用户客户端，为客户端发送请求，使真实的用户客户端对服务器不可见。它最典型的用途就是可以用来访问受地理限制的内容、保护用户隐私、帮助爬虫爬取数据、广告效果测试、网站测试等等。</p><h4 id="反向代理："><a href="#反向代理：" class="headerlink" title="反向代理："></a>反向代理：</h4><p><img src="https://pic1.zhimg.com/v2-55476d2362c5706329c5693326b303bc_r.jpg"></p><p>反向代理是用户客户端发送请求于代理服务器，然后代理服务器将请求转发给相对的目标服务器，并将结果返回给客户端。对于客户端来说，它没有确定想要访问的目标服务器，这里的代理服务器就相当于是目标服务器，此时也不需要客户端进行任何的设置。</p><p>反向代理是代理服务器，为服务器收发请求，使得真实的服务器对于用户客户端不可见。它的作用是隐藏服务器的IP地址、提高访问速度、保持负载平衡、保护免受黑客攻击。</p><h4 id="正向代理与反向代理的区别："><a href="#正向代理与反向代理的区别：" class="headerlink" title="正向代理与反向代理的区别："></a>正向代理与反向代理的区别：</h4><p>正向代理和反向代理都是介于用户客户端与服务器之间的，它在中间都起到了连接与保护的作用。它们的区别在于，正向代理是用户客户端代理，而反向代理是服务器代理，在代理对象不同的情况下，都可以起到隐藏信息的作用；其次，正向代理一般是用户客户端设置的，而反向代理是由服务器设置的。</p><p>正向代理与反向代理的应用很广泛，但总的来说，普通用户们日常使用的大多是正向代理，而反向代理则主要应用于网站服务器之中，适用于大公司业务处理。</p><h2 id="Nginx-是如何工作的？"><a href="#Nginx-是如何工作的？" class="headerlink" title="Nginx 是如何工作的？"></a>Nginx 是如何工作的？</h2><h3 id="Nginx进程"><a href="#Nginx进程" class="headerlink" title="Nginx进程"></a>Nginx进程</h3><p>nginx 在启动后，会以 daemon 的方式在后台运行，后台进程包含一个 master 进程和多个 worker 进程，worker 进程以非 root 用户运行，可以在配置文件中配置运行 worker 进程的用户。</p><p>master 进程主要用来管理 worker 进程，包含：接收来自外界的信号，向各 worker 进程发送信号，监控 worker 进程的运行状态，当 worker 进程退出后(异常情况下)，会自动重新启动新的 worker 进程。</p><p>worker 进程则是处理基本的网络事件。多个 worker 进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。一个请求，只可能在一个 worker 进程中处理，一个 worker 进程，不可能处理其它进程的请求。</p><p>总结其主要功能分别如下：</p><p>主进程(master process)的功能：</p><ol><li>读取 Nginx 配置文件并验证其有效性和正确性</li><li>按照配置启动、管理和关闭工作进程</li><li>接受外界指令，比如重启、升级及关闭服务器等指令</li><li>不中断服务，实现平滑升级，重启服务并应用新的配置</li><li>开启日志文件</li></ol><p>工作进程（woker process）的功能：</p><ol><li>接收处理客户端的请求</li><li>将请求以此送入各个功能模块进行处理</li><li>IO 调用，获取响应数据</li><li>与后端服务器通信，接收后端服务器的处理结果</li><li>缓存数据，访问缓存索引，查询和调用缓存数据</li><li>发送请求结果，响应客户端的请求</li><li>接收主程序指令，比如重启、升级和退出等</li></ol><p><img src="https://www.cainiaojc.com/article/image/2022/0213/b5fd8b357a4d68dfd8d731fb1a9b0f51.png" alt="img"></p><p>master 进程：负责加载和分析配置文件、管理 worker 进程，平滑升级<br>worker 进程：接收客户端请求、将请求一次送入各模块过滤、I/O 调用、数据缓存、发送响应<br>cache相关进程：cache loader (缓存索引重建)与 cache manager( 缓存索引管理)组成<br>–Cache loader 在 Nginx 服务启动后由主进程生成,根据本地磁盘上缓存建立索引元数据库后退出。<br>–Cache manager 在元数据更新完成后，对元数据是否过期做出判断。</p><h3 id="Nginx的模块结构"><a href="#Nginx的模块结构" class="headerlink" title="Nginx的模块结构"></a>Nginx的模块结构</h3><p>Nginx 的各种功能和操作都由模块来实现。Nginx 由内核和一系列模块组成，内核提供web服务的基本功能，如启用网络协议，创建运行环境，接收和分配客户端请求，处理模块之间的交互。Nginx 的模块从结构上分为核心模块、基础模块和第三方模块。 </p><p>核心模块： HTTP 模块、EVENT 模块和 MAIL 模块 </p><p>基础模块： HTTP Access 模块、HTTP FastCGI 模块、HTTP Proxy 模块和 HTTP Rewrite 模块 </p><p>第三方模块： HTTP Upstream Request Hash 模块、Notice 模块和 HTTP Access Key 模块及用户自己开发的模块。</p><p>这样的设计使 Nginx 方便开发和扩展，Nginx的模块默认编译进 nginx 中，如果需要增加或删除模块，需要重新编译 nginx，这一点不如 Apache 的动态加载模块方便，最新版本Nginx 已经支持动态模块</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="Nginx" scheme="https://www.hoveco.top/categories/Nginx/"/>
    
    
    <category term="Nginx学习" scheme="https://www.hoveco.top/tags/Nginx%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>建站篇(四)</title>
    <link href="https://www.hoveco.top/2023/07/16/jianzhan_4/"/>
    <id>https://www.hoveco.top/2023/07/16/jianzhan_4/</id>
    <published>2023-07-16T09:16:27.000Z</published>
    <updated>2023-11-15T13:10:56.855Z</updated>
    
    <content type="html"><![CDATA[<h3 id="今日开发进展：完成了评论功能的添加"><a href="#今日开发进展：完成了评论功能的添加" class="headerlink" title="今日开发进展：完成了评论功能的添加"></a>今日开发进展：完成了评论功能的添加</h3><p>开发过程：</p><p>​        省流版：经过多个评论系统测试，选用了livere （来必力）评论系统</p><p>​        啰嗦版：市面上常见的评论插件千奇百怪，数不胜数。所以说，选一个适合自己的评论系统可见是多么重要的，常见的插件有以下（Disqus Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo）等等。一个好的博客评论标准你觉得是什么呢？我觉得吧，应该是这样的。首先，一定要和你的博客兼容（一句废话）；其次，适应要强，支持多种不同的账号登陆评论，比如其中有个插件（名曰：Gitalk），它限制的是 只有 GitHub 用户才能登录评论！对于非专业人员可能都不清楚这是个啥，可以说非常”歧视”他们，所以就跳过它了；最后一点也是最重要的一点，配置一定要简单，比如 某些插件限制流量和内存数据空间，注册需要域名，国外手机实名验证等等，比较烦。希望大家听人劝，不踩坑，顺利搭建成功属于自己的网站</p><h3 id="2023-11-15补充"><a href="#2023-11-15补充" class="headerlink" title="2023.11.15补充"></a><strong>2023.11.15补充</strong></h3><p>在使用livere （来必力）评论系统后，电脑端没有发现什么问题，可是手机端页面后出现广告的问题（电脑端不显示可能是被浏览器的广告拦截脚本拦截了），刚开始还以为是网站被黑了，后来看到广告的内容都是韩文的，联想到livere （来必力）就是韩国的。固抛弃了它，换了<a href="https://valine.js.org/">Valine</a>这个评论系统，后续根据情况再做调整。</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="网站建设" scheme="https://www.hoveco.top/categories/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"/>
    
    
    <category term="Hexo建站" scheme="https://www.hoveco.top/tags/Hexo%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>建站篇(三)</title>
    <link href="https://www.hoveco.top/2023/07/15/jianzhan_3/"/>
    <id>https://www.hoveco.top/2023/07/15/jianzhan_3/</id>
    <published>2023-07-15T02:46:27.000Z</published>
    <updated>2023-08-03T11:51:00.696Z</updated>
    
    <content type="html"><![CDATA[<h3 id="改千日头晕脑涨，毁一时神清气爽"><a href="#改千日头晕脑涨，毁一时神清气爽" class="headerlink" title="改千日头晕脑涨，毁一时神清气爽"></a>改千日头晕脑涨，毁一时神清气爽</h3><p>经历前几日不断的修改bug，一直实现不了自己想要的效果，终于今天决定丢弃之前的网站，重新搞现在的这个，也就是最后呈现在各位面前的这一版。<img src="https://s2.loli.net/2023/07/15/nxiXHEVy1394ZWh.jpg" alt="预览图.jpg">相较与之前的那一个功能更多一点，并且最重要是之前想实现的在这一版都得到了不同的改善。</p><h4 id="今日更新："><a href="#今日更新：" class="headerlink" title="今日更新："></a>今日更新：</h4><p>图库模块：</p><p>之前见识短浅，不知道还有”图床”这个东西，可以托管第三方图片，并且可以生成外链。这样，加载图片的时候，就可以到第三方网站去进行加载网站，就不在本网站的服务器进行加载图片了，省去很多问题。目前本站使用的是<a href="https://smms.app/">Image Upload - SM.MS - Simple Free Image Hosting (smms.app)</a>网站进行图片的托管，之后有更好的会进行替换，或者后面会自己搭建</p><p>音乐模块：</p><p>音乐歌单目前使用的网易云的，当然也可以换别的(ps:单纯网易云听得多而已，别问，问就是10级大佬)。背景音乐部分（也就是网页左下角的播放器）使用的是个人的外语歌单（即全是英文歌曲）。音乐模块是个人喜欢的歌曲。希望你也喜欢，后续歌单也可能会更换。</p><p>今天的”碎碎念”就这样吧，后续再见！</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="网站建设" scheme="https://www.hoveco.top/categories/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"/>
    
    
    <category term="Hexo建站" scheme="https://www.hoveco.top/tags/Hexo%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>建站篇(二)</title>
    <link href="https://www.hoveco.top/2023/07/12/jianzhan_2/"/>
    <id>https://www.hoveco.top/2023/07/12/jianzhan_2/</id>
    <published>2023-07-12T02:46:27.000Z</published>
    <updated>2023-08-03T11:51:00.721Z</updated>
    
    <content type="html"><![CDATA[<h3 id="今天又是元气满满的一天"><a href="#今天又是元气满满的一天" class="headerlink" title="今天又是元气满满的一天"></a>今天又是元气满满的一天</h3><p><img src="https://s2.loli.net/2023/07/15/Ne8D6pQM5d2ugXb.png" alt="旧blog.png">今天给博客网站添加了部分功能，评论功能以及背景音乐播放窗口。</p><p>评论功能：使用的是“畅言”网络组件，支持用QQ、微信等等登陆进行评论，后台管理也比较方便。当然也考虑过用别的评论插件，比如：gitalk等，要求用githup登陆，并且需要科学上网才能使用就放弃了。目前评论组件会存在一些显示问题，还需要后期进行打磨调试，基本功能使用正常。还有就是评论现在不多，就没设置审核功能，评价就会立即显示，后续会添加敏感字筛选和过滤展示</p><p>背景音乐播放：耗费时间较长的一个模块。使用的是Aplayer，相关githup项目地址是：<a href="https://github.com/DIYgod/APlayer">DIYgod/APlayer: :lollipop: Wow, such a beautiful HTML5 music player (github.com)</a>，按照教程配置相关的参数，就可以实现页面播放器的功能。但是，比较鸡肋的是使用该插件就不能刷新网页，不然会重置播放器，打断当前播放的音乐。所以又引入了pjax防止出现跳转页面音乐暂停的问题，禁止刷新网页之后，又出现了部分图片刷新不出来的新bug，分析是hexo开启懒加载后与pjax插件冲突导致的问题，后续会进一步分析解决。</p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="网站建设" scheme="https://www.hoveco.top/categories/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"/>
    
    
    <category term="Hexo建站" scheme="https://www.hoveco.top/tags/Hexo%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>建站篇(一)</title>
    <link href="https://www.hoveco.top/2023/07/08/jianzhan_1/"/>
    <id>https://www.hoveco.top/2023/07/08/jianzhan_1/</id>
    <published>2023-07-08T02:46:27.000Z</published>
    <updated>2023-08-03T11:51:00.837Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hi，大家好"><a href="#Hi，大家好" class="headerlink" title="Hi，大家好"></a>Hi，大家好</h3><p>​       欢迎来到我的博客空间。平时闲来无事，在网上随便瞎逛，突然就逛到了不知名的某人的博客里面去了，当看到别人炫酷的页面之后，自己也就萌生了一个自己要做一个博客的想法。于是查阅了很多的网站教程，也考虑了自己要不要购买一个服务器，搭建一个属于自己的网站。后来心想还是先将网站先做出来再做进一步的打算吧！最开始我用的建站工具是Halo这个工具也就是这个<img src="https://s2.loli.net/2023/07/15/Ud6abKzCPNlBgZi.webp" alt="halo.webp">怎么说呢。这个工具还是蛮不错的，主题虽然不是很多，但是效果还行。于是乎自己就在虚拟机上搭建了一个网站摹本。</p><p>​        就在我以为自己的网站就是要用这个的时候，后来发现了hexo这个博客工具，听说是可以使用Githup Pages进行建站，无需租用任何服务器，突然就感觉真是太香了。于是就找了一个比较简单的博客主题，按照步骤进行了搭建，所以就有了现在的版本，虽然现在的博客版本还是最开始的版本，功能什么的还不是很完善。之后也会慢慢进行维护滴，还是小小的期待一下吧。</p><p>​       这个因为代码平台（Githup）存储库的局限，所以之后的内容也会尽可能的精简，上传的图片当然也不可能是原图（原图的话加载也会比较慢）,其他的功能模块也会依照自己的兴趣后续再做添加，就这样吧！  </p>]]></content>
    
    
    <summary type="html">底部打赏杯奶茶奖励作者吧~</summary>
    
    
    
    <category term="网站建设" scheme="https://www.hoveco.top/categories/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"/>
    
    
    <category term="Hexo建站" scheme="https://www.hoveco.top/tags/Hexo%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
</feed>
